<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Symmetry - Group Theory Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 50%, #3c3c5a 100%);
            color: #e8e8f0;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .container {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        .screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 50%, #3c3c5a 100%);
        }

        .screen.active {
            display: block;
        }

        /* ‰∏ªËèúÂçï */
        .main-menu {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }

        .game-title {
            font-size: clamp(36px, 8vw, 72px);
            font-weight: 300;
            color: #7c9ad9;
            margin-bottom: 50px;
            text-shadow: 0 2px 20px rgba(124, 154, 217, 0.3);
            letter-spacing: 8px;
            font-family: 'SF Pro Display', -apple-system, system-ui, sans-serif;
        }

        .menu-button {
            display: block;
            width: 280px;
            max-width: 80vw;
            padding: 18px 24px;
            margin: 12px 0;
            background: rgba(124, 154, 217, 0.1);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
        }

        .menu-button:hover {
            background: rgba(124, 154, 217, 0.2);
            border-color: rgba(124, 154, 217, 0.6);
            color: #7c9ad9;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(124, 154, 217, 0.2);
        }

        /* Ê∏∏ÊàèËèúÂçï */
        .game-menu {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            position: relative;
        }

        .game-menu h2 {
            text-align: center;
            color: #7c9ad9;
            font-size: 32px;
            font-weight: 300;
            margin-bottom: 40px;
            text-shadow: 0 2px 10px rgba(124, 154, 217, 0.3);
        }

        .level-list {
            max-width: 800px;
            margin: 0 auto;
        }

        .level-row {
            margin: 20px 0;
            padding: 24px;
            background: rgba(124, 154, 217, 0.05);
            border: 1px solid rgba(124, 154, 217, 0.2);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .level-row:hover {
            background: rgba(124, 154, 217, 0.1);
            border-color: rgba(124, 154, 217, 0.4);
            transform: translateX(8px);
        }

        .level-label {
            font-size: 22px;
            font-weight: 600;
            color: #7c9ad9;
            min-width: 140px;
        }

        .level-content {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 12px;
        }

        .level-buttons {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .level-button {
            padding: 12px 24px;
            background: rgba(68, 88, 126, 0.3);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            backdrop-filter: blur(5px);
        }

        .level-button:hover:not(.disabled) {
            background: rgba(124, 154, 217, 0.2);
            border-color: rgba(124, 154, 217, 0.6);
            color: #7c9ad9;
            transform: translateY(-2px);
        }

        .level-button.disabled {
            color: #666;
            border-color: #444;
            cursor: not-allowed;
            background: rgba(40, 40, 50, 0.3);
        }

        .puzzle-hint {
            font-size: 13px;
            color: #9ca3af;
            font-style: italic;
        }

        /* Ê∏∏ÊàèÂå∫Âüü */
        .game-area {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .game-header {
            padding: 20px 24px;
            background: rgba(124, 154, 217, 0.05);
            border-bottom: 1px solid rgba(124, 154, 217, 0.2);
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .game-title-text {
            font-size: 28px;
            color: #7c9ad9;
            font-weight: 500;
        }

        .game-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .table-area {
            flex: 1;
            overflow: auto;
            padding: 30px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        .multiplication-table {
            display: inline-grid;
            gap: 2px;
            background: rgba(124, 154, 217, 0.1);
            padding: 8px;
            border-radius: 12px;
            margin: 0 auto;
            min-width: max-content;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(124, 154, 217, 0.2);
        }

        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            border: 1px solid rgba(124, 154, 217, 0.2);
            background: rgba(45, 45, 68, 0.8);
            color: #e8e8f0;
            transition: all 0.2s ease;
            position: relative;
            border-radius: 4px;
        }

        .cell:hover {
            border-color: rgba(124, 154, 217, 0.6);
            background: rgba(124, 154, 217, 0.2);
            transform: scale(1.05);
        }

        .cell.header {
            background: rgba(124, 154, 217, 0.3);
            color: #fff;
            border-color: rgba(124, 154, 217, 0.5);
            font-weight: 700;
        }

        .cell.header.selected {
            background: rgba(255, 107, 107, 0.8);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
            transform: scale(1.1);
        }

        .cell.selected {
            background: rgba(124, 154, 217, 0.4);
            border-color: rgba(124, 154, 217, 0.8);
            box-shadow: 0 0 10px rgba(124, 154, 217, 0.4);
            transform: scale(1.05);
        }

        .cell.immutable {
            background: rgba(139, 69, 19, 0.3) !important;
            color: #deb887 !important;
            cursor: not-allowed;
            box-shadow: inset 0 0 8px rgba(139, 69, 19, 0.4);
            border-color: rgba(139, 69, 19, 0.6) !important;
        }

        .control-panel {
            width: 320px;
            max-width: 100%;
            background: rgba(124, 154, 217, 0.05);
            border-left: 1px solid rgba(124, 154, 217, 0.2);
            padding: 24px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }

        .info-section {
            margin-bottom: 24px;
            padding: 20px;
            background: rgba(68, 88, 126, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(124, 154, 217, 0.2);
        }

        .info-section strong {
            color: #7c9ad9;
            display: block;
            margin-bottom: 12px;
            font-size: 16px;
            font-weight: 600;
        }

        .control-button {
            width: 100%;
            padding: 14px;
            margin: 12px 0;
            background: rgba(124, 154, 217, 0.1);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }

        .control-button:hover {
            background: rgba(124, 154, 217, 0.2);
            border-color: rgba(124, 154, 217, 0.6);
            color: #7c9ad9;
            transform: translateY(-2px);
        }

        .control-button.primary {
            background: rgba(124, 154, 217, 0.3);
            border-color: rgba(124, 154, 217, 0.6);
            box-shadow: 0 4px 15px rgba(124, 154, 217, 0.2);
        }

        /* ÁîªÂªä */
        .gallery {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 24px;
        }

        .gallery h2 {
            text-align: center;
            color: #7c9ad9;
            font-size: 32px;
            font-weight: 300;
            margin-bottom: 40px;
            text-shadow: 0 2px 10px rgba(124, 154, 217, 0.3);
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 24px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .group-card {
            border: 1px solid rgba(124, 154, 217, 0.3);
            padding: 24px;
            background: rgba(124, 154, 217, 0.05);
            border-radius: 16px;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .group-card:hover {
            border-color: rgba(124, 154, 217, 0.6);
            background: rgba(124, 154, 217, 0.1);
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(124, 154, 217, 0.15);
        }

        .group-card.unknown {
            color: #9ca3af;
            border-color: rgba(156, 163, 175, 0.3);
            background: rgba(75, 85, 99, 0.1);
        }

        .group-info h3 {
            color: #7c9ad9;
            font-size: 24px;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .group-info .order {
            color: #f59e0b;
            font-size: 16px;
            font-weight: 600;
            margin: 8px 0;
        }

        .group-info .description {
            color: #d1d5db;
            font-size: 14px;
            margin-top: 12px;
            line-height: 1.5;
        }

        .group-table-preview {
            width: 90px;
            height: 90px;
            display: grid;
            gap: 1px;
            background: rgba(45, 45, 68, 0.5);
            margin: 16px auto 0;
            padding: 4px;
            border-radius: 8px;
            border: 1px solid rgba(124, 154, 217, 0.2);
        }

        .preview-cell {
            background: rgba(124, 154, 217, 0.3);
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            border-radius: 2px;
        }

        /* ÊïôÁ®ãÂíåËÆæÁΩÆ */
        .tutorial, .settings {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 24px;
        }

        .tutorial h1, .settings h2 {
            text-align: center;
            color: #7c9ad9;
            font-size: 32px;
            font-weight: 300;
            margin-bottom: 40px;
            text-shadow: 0 2px 10px rgba(124, 154, 217, 0.3);
        }

        .tutorial h2 {
            color: #7c9ad9;
            font-size: 22px;
            font-weight: 500;
            margin: 32px 0 16px;
            border-bottom: 1px solid rgba(124, 154, 217, 0.3);
            padding-bottom: 8px;
        }

        .tutorial p {
            margin: 16px 0;
            line-height: 1.7;
            color: #d1d5db;
            font-size: 15px;
        }

        .tutorial strong {
            color: #f59e0b;
            font-weight: 600;
        }

        .setting-item {
            margin: 28px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: rgba(124, 154, 217, 0.05);
            border: 1px solid rgba(124, 154, 217, 0.2);
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        .toggle {
            width: 56px;
            height: 32px;
            background: rgba(75, 85, 99, 0.8);
            border: 1px solid rgba(156, 163, 175, 0.3);
            border-radius: 16px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle.on {
            background: rgba(124, 154, 217, 0.8);
            border-color: rgba(124, 154, 217, 0.6);
        }

        .toggle-slider {
            width: 26px;
            height: 26px;
            background: linear-gradient(145deg, #ffffff, #e5e7eb);
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .toggle.on .toggle-slider {
            transform: translateX(24px);
        }

        select {
            padding: 10px 12px;
            background: rgba(68, 88, 126, 0.8);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        /* ËøîÂõûÊåâÈíÆÂíåÊèêÁ§∫ÂõæÊ†á */
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 16px;
            background: rgba(124, 154, 217, 0.1);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.3);
            border-radius: 8px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .back-button:hover {
            background: rgba(124, 154, 217, 0.2);
            border-color: rgba(124, 154, 217, 0.6);
            color: #7c9ad9;
            transform: translateX(-4px);
        }

        .hint-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            background: rgba(124, 154, 217, 0.2);
            border: 1px solid rgba(124, 154, 217, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            color: #7c9ad9;
            font-weight: 600;
            z-index: 100;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .hint-icon:hover {
            background: rgba(124, 154, 217, 0.3);
            border-color: rgba(124, 154, 217, 0.6);
            transform: scale(1.05);
        }

        .hint-tooltip {
            position: absolute;
            top: 60px;
            right: 0;
            background: rgba(45, 45, 68, 0.95);
            color: #f59e0b;
            padding: 16px;
            border-radius: 8px;
            max-width: 320px;
            display: none;
            border: 1px solid rgba(124, 154, 217, 0.3);
            font-size: 13px;
            line-height: 1.5;
            z-index: 101;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .hint-icon:hover .hint-tooltip {
            display: block;
        }

        /* Ê®°ÊÄÅÊ°Ü */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(45, 45, 68, 0.95);
            padding: 32px;
            border: 1px solid rgba(124, 154, 217, 0.4);
            border-radius: 16px;
            max-width: 85vw;
            max-height: 80vh;
            text-align: center;
            overflow-y: auto;
            backdrop-filter: blur(20px);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .modal-content h3 {
            color: #7c9ad9;
            margin-bottom: 16px;
            font-size: 24px;
            font-weight: 500;
        }

        .modal-content p {
            color: #d1d5db;
            margin-bottom: 24px;
            line-height: 1.6;
            font-size: 16px;
        }

        .modal-button {
            padding: 12px 24px;
            background: rgba(124, 154, 217, 0.2);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.4);
            border-radius: 8px;
            font-family: inherit;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-button:hover {
            background: rgba(124, 154, 217, 0.3);
            border-color: rgba(124, 154, 217, 0.6);
            color: #7c9ad9;
        }

        /* ÁßªÂä®Á´ØËæìÂÖ•Ê°Ü */
        .mobile-input-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px);
        }

        .mobile-input-overlay.active {
            display: flex;
        }

        .mobile-input-dialog {
            background: rgba(45, 45, 68, 0.95);
            padding: 32px;
            border: 1px solid rgba(124, 154, 217, 0.4);
            border-radius: 16px;
            text-align: center;
            max-width: 90vw;
            backdrop-filter: blur(20px);
        }

        .mobile-input-dialog h3 {
            color: #7c9ad9;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: 500;
        }

        .mobile-input-field {
            width: 120px;
            padding: 16px;
            font-size: 24px;
            text-align: center;
            background: rgba(68, 88, 126, 0.8);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.4);
            border-radius: 8px;
            font-family: inherit;
            margin: 20px 0;
            font-weight: 600;
        }

        .mobile-input-buttons {
            display: flex;
            gap: 16px;
            justify-content: center;
        }

        .mobile-input-btn {
            padding: 12px 20px;
            background: rgba(124, 154, 217, 0.2);
            color: #e8e8f0;
            border: 1px solid rgba(124, 154, 217, 0.4);
            border-radius: 8px;
            font-family: inherit;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .mobile-input-btn:hover {
            background: rgba(124, 154, 217, 0.3);
            color: #7c9ad9;
        }

        .mobile-input-btn.cancel {
            background: rgba(139, 69, 19, 0.3);
            border-color: rgba(139, 69, 19, 0.6);
            color: #deb887;
        }

        .mobile-input-btn.cancel:hover {
            background: rgba(139, 69, 19, 0.4);
            color: #f4a460;
        }

        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
            }

            .control-panel {
                width: 100%;
                border-left: none;
                border-top: 1px solid rgba(124, 154, 217, 0.2);
                max-height: 45vh;
            }

            .table-area {
                flex: 1;
                min-height: 55vh;
                padding: 20px;
            }

            .cell {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }

            .level-row {
                flex-direction: column;
                text-align: center;
                padding: 20px;
            }

            .level-label {
                min-width: auto;
                width: 100%;
            }

            .level-content {
                align-items: center;
                width: 100%;
            }

            .level-buttons {
                justify-content: center;
                flex-wrap: wrap;
            }

            .level-button {
                flex: 1;
                min-width: 140px;
            }

            .menu-button {
                width: 90vw;
                font-size: 16px;
            }

            .game-title {
                margin-bottom: 30px;
                letter-spacing: 4px;
            }

            .gallery-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        @media (max-width: 480px) {
            .cell {
                width: 30px;
                height: 30px;
                font-size: 12px;
            }

            .control-panel {
                padding: 16px;
            }

            .table-area {
                padding: 16px;
            }

            .multiplication-table {
                gap: 1px;
                padding: 6px;
            }

            .back-button, .hint-icon {
                top: 12px;
                padding: 8px;
                font-size: 12px;
            }

            .hint-icon {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .game-header {
                padding: 16px 20px;
            }

            .game-title-text {
                font-size: 24px;
            }

            .tutorial, .settings, .gallery {
                padding: 16px;
            }

            .game-menu {
                padding: 16px;
            }
        }

        /* Âä®ÁîªÊïàÊûú */
        @keyframes glow {
            0%, 100% { 
                text-shadow: 0 2px 20px rgba(124, 154, 217, 0.3); 
            }
            50% { 
                text-shadow: 0 2px 30px rgba(124, 154, 217, 0.6), 0 4px 40px rgba(124, 154, 217, 0.3); 
            }
        }

        .game-title {
            animation: glow 3s infinite ease-in-out;
        }

        .celebrate {
            animation: celebration 0.6s ease-in-out;
        }

        @keyframes celebration {
            0%, 100% { 
                background: rgba(124, 154, 217, 0.1); 
            }
            50% { 
                background: rgba(124, 154, 217, 0.3); 
                transform: scale(1.02);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ‰∏ªËèúÂçï -->
        <div id="mainMenu" class="screen active">
            <div class="main-menu">
                <div class="game-title">SYMMETRY</div>
                <button class="menu-button" onclick="showTutorial()">Tutorial</button>
                <button class="menu-button" onclick="showGameMenu()">Start Game</button>
                <button class="menu-button" onclick="showGallery()">Gallery</button>
                <button class="menu-button" onclick="showSettings()">Settings</button>
                <button class="menu-button" onclick="exitGame()">Exit</button>
            </div>
        </div>

        <!-- Ê∏∏ÊàèËèúÂçï -->
        <div id="gameMenu" class="screen">
            <button class="back-button" onclick="showMainMenu()">‚Üê Back</button>
            <div class="game-menu">
                <h2>Select Level</h2>
                <div class="level-list" id="levelList"></div>
            </div>
        </div>

        <!-- Ê∏∏ÊàèÂå∫Âüü -->
        <div id="gameArea" class="screen">
            <button class="back-button" onclick="backToGameMenu()">‚Üê Back</button>
            <div class="hint-icon" id="hintIcon" style="display: none;">
                ?
                <div class="hint-tooltip" id="hintTooltip"></div>
            </div>
            <div class="game-area">
                <div class="game-header">
                    <div class="game-title-text" id="gameTitle">Order 4 Group</div>
                </div>
                <div class="game-content">
                    <div class="table-area">
                        <div id="multiplicationTable" class="multiplication-table"></div>
                    </div>
                    <div class="control-panel">
                        <div class="info-section">
                            <strong>Selected Element Info</strong>
                            <div id="elementInfo">
                                Order: -<br>
                                Conjugates: -<br>
                                Centralizer: -
                            </div>
                        </div>
                        <button class="control-button primary" onclick="submitTable()">Submit</button>
                        <button class="control-button" onclick="clearTable()">Clear</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ÁîªÂªä -->
        <div id="gallery" class="screen">
            <button class="back-button" onclick="showMainMenu()">‚Üê Back</button>
            <div class="gallery">
                <h2>Discovered Groups</h2>
                <div class="gallery-grid" id="galleryGrid"></div>
            </div>
        </div>

        <!-- ÊïôÁ®ã -->
        <div id="tutorial" class="screen">
            <button class="back-button" onclick="showMainMenu()">‚Üê Back</button>
            <div class="tutorial">
                <h1>Group Theory Explorer</h1>
                
                <h2>üéØ Objective</h2>
                <p>Fill in multiplication tables to discover and understand finite groups. Master the art of abstract algebra through interactive exploration!</p>
                
                <h2>üîÑ Game Flow</h2>
                <p><strong>1. Exploration Mode:</strong> Freely create and explore group structures to discover new groups. This is where you learn and experiment!</p>
                <p><strong>2. Gallery:</strong> View all groups you've discovered in exploration mode. Your personal collection of mathematical achievements.</p>
                <p><strong>3. Puzzle Mode:</strong> Solve challenging puzzles based on groups you've already discovered. Test your understanding!</p>
                
                <h2>üéÆ Controls</h2>
                <p>‚Ä¢ <strong>Click a cell</strong> to select it</p>
                <p>‚Ä¢ <strong>Type numbers (0-9)</strong> to fill values</p>
                <p>‚Ä¢ <strong>Backspace/Delete</strong> to clear a cell</p>
                <p>‚Ä¢ <strong>Right-click</strong> to quickly clear</p>
                <p>‚Ä¢ <strong>Click headers</strong> to swap elements (powerful tool!)</p>
                <p>‚Ä¢ <strong>ESC</strong> to return to menu</p>
                
                <h2>üìê Group Properties</h2>
                <p><strong>Closure:</strong> All products must be in the group (no values outside 0 to n-1)</p>
                <p><strong>Associativity:</strong> (a¬∑b)¬∑c = a¬∑(b¬∑c) for all elements</p>
                <p><strong>Identity:</strong> There exists e such that e¬∑a = a¬∑e = a for all a</p>
                <p><strong>Inverses:</strong> For each a, there exists b such that a¬∑b = b¬∑a = e</p>
                
                <h2>üí° Pro Tips</h2>
                <p>‚Ä¢ <strong>Start with the identity:</strong> Find which element acts as the identity first</p>
                <p>‚Ä¢ <strong>Latin square property:</strong> Each row and column must contain all elements exactly once</p>
                <p>‚Ä¢ <strong>Use element swapping:</strong> Click headers to standardize your table - this is crucial for puzzle solving!</p>
                <p>‚Ä¢ <strong>Study patterns:</strong> Pay attention to element orders and conjugacy classes</p>
                <p>‚Ä¢ <strong>Exploration first:</strong> Discover groups in exploration mode before attempting puzzles</p>
                <p>‚Ä¢ <strong>Small groups are easier:</strong> Start with order 4 to understand the basics</p>
            </div>
        </div>

        <!-- ËÆæÁΩÆ -->
        <div id="settings" class="screen">
            <button class="back-button" onclick="showMainMenu()">‚Üê Back</button>
            <div class="settings">
                <h2>Settings</h2>
                <div class="setting-item">
                    <span>Enable Screenshots</span>
                    <div class="toggle" id="screenshotToggle" onclick="toggleScreenshot()">
                        <div class="toggle-slider"></div>
                    </div>
                </div>
                <div class="setting-item">
                    <span>Language / ËØ≠Ë®Ä</span>
                    <select id="languageSelect" onchange="changeLanguage()">
                        <option value="en">English</option>
                        <option value="cn">‰∏≠Êñá</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- Ê®°ÊÄÅÊ°Ü -->
    <div id="modal" class="modal">
        <div class="modal-content">
            <h3 id="modalTitle">Message</h3>
            <p id="modalText"></p>
            <button class="modal-button" onclick="closeModal()">Confirm</button>
        </div>
    </div>

    <!-- ÁßªÂä®Á´ØËæìÂÖ•Ê°Ü -->
    <div id="mobileInputOverlay" class="mobile-input-overlay">
        <div class="mobile-input-dialog">
            <h3>Enter Value</h3>
            <input type="number" id="mobileInputField" class="mobile-input-field" min="0" max="19">
            <div class="mobile-input-buttons">
                <button class="mobile-input-btn cancel" onclick="closeMobileInput()">Cancel</button>
                <button class="mobile-input-btn" onclick="confirmMobileInput()">OK</button>
            </div>
        </div>
    </div>

    <script>
        // Ê∏∏ÊàèÁä∂ÊÄÅ
        const state = {
            currentPage: 'mainMenu',
            currentMode: 'exploration',
            currentOrder: 4,
            multiTable: [],
            selectedCell: null,
            selectedHeader: null,
            immutableCells: [],
            hint: '',
            language: 'en',
            isMobile: false,
            mobileInputTarget: null
        };

        // Ê†ºÂ≠êÂ±ïÁ§∫ÈÖçÁΩÆ - ÈªòËÆ§‰∏∫ order - 2 (ÂèØÂú®‰ª£Á†Å‰∏≠Ë∞ÉÊï¥)
        function getCellDisplayCount(order) {
            // ‰Ω†ÂèØ‰ª•Âú®ËøôÈáå‰øÆÊîπÂÖ¨ÂºèÊù•Ë∞ÉÊï¥ÊòæÁ§∫ÁöÑÊ†ºÂ≠êÊï∞Èáè
            // ÈªòËÆ§: order - 2ÔºåÁ°Æ‰øùËá≥Â∞ëÊòæÁ§∫2‰∏™Ê†ºÂ≠ê
            return Math.max(2, order - 2);
        }

        // Ê£ÄÊµãÊòØÂê¶‰∏∫ÁßªÂä®ËÆæÂ§á
        function detectMobile() {
            return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
        }

        // Robust localStorage parsing function
        function safeJsonParse(key, defaultValue) {
            const item = localStorage.getItem(key);
            if (item === null || item === "null" || item === "undefined") {
                return defaultValue;
            }
            try {
                const parsed = JSON.parse(item);
                if (Array.isArray(defaultValue) && !Array.isArray(parsed)) {
                    console.warn(`Data for key '${key}' in localStorage was not an array, using default.`);
                    return defaultValue;
                }
                if (typeof defaultValue === 'object' && defaultValue !== null && !Array.isArray(defaultValue)) {
                    if (typeof parsed !== 'object' || parsed === null || Array.isArray(parsed)) {
                        console.warn(`Data for key '${key}' in localStorage was not a suitable object, using default.`);
                        return defaultValue;
                    }
                }
                if (key === 'settings' && typeof parsed === 'object' && parsed !== null && typeof defaultValue === 'object' && defaultValue !== null) {
                    return { ...defaultValue, ...parsed };
                }
                return parsed;
            } catch (e) {
                console.warn(`Error parsing JSON for key '${key}' from localStorage, using default value. Error:`, e);
                return defaultValue;
            }
        }

        // Êï∞ÊçÆÂ≠òÂÇ®
        const storage = {
            discoveredGroups: safeJsonParse('discoveredGroups', []),
            solvedPuzzles: safeJsonParse('solvedPuzzles', {}),
            settings: safeJsonParse('settings', {"screenshot": false, "language": "en"})
        };

        // ‰øùÂ≠òÊï∞ÊçÆ
        function saveData() {
            try {
                localStorage.setItem('discoveredGroups', JSON.stringify(storage.discoveredGroups));
                localStorage.setItem('solvedPuzzles', JSON.stringify(storage.solvedPuzzles));
                localStorage.setItem('settings', JSON.stringify(storage.settings));
            } catch (e) {
                console.error("Error saving data to localStorage:", e);
            }
        }

        // Á∫ßÂà´ÈÖçÁΩÆ
        const levelOrders = [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20];

        // Áæ§Êï∞ÊçÆÂ∫ì
        const groupsData = {
            1: [{name: '1', description: 'Trivial group'}],
            2: [{name: 'C2', description: 'Cyclic group of order 2'}],
            3: [{name: 'C3', description: 'Cyclic group of order 3'}],
            4: [
                {name: 'C4', description: 'Cyclic group of order 4'},
                {name: 'C2 x C2', description: 'Klein four-group'}
            ],
            5: [{name: 'C5', description: 'Cyclic group of order 5'}],
            6: [
                {name: 'C6', description: 'Cyclic group of order 6'},
                {name: 'S3', description: 'Symmetric group on 3 letters'}
            ],
            8: [
                {name: 'C8', description: 'Cyclic group of order 8'},
                {name: 'C4 x C2', description: 'Direct product'},
                {name: 'C2 x C2 x C2', description: 'Elementary abelian'},
                {name: 'D8', description: 'Dihedral group of order 8'},
                {name: 'Q8', description: 'Quaternion group'}
            ],
            9: [
                {name: 'C9', description: 'Cyclic group of order 9'},
                {name: 'C3 x C3', description: 'Elementary abelian'}
            ],
            10: [
                {name: 'C10', description: 'Cyclic group of order 10'},
                {name: 'D10', description: 'Dihedral group of order 10'}
            ],
            12: [
                {name: 'C12', description: 'Cyclic group of order 12'},
                {name: 'C6 x C2', description: 'Direct product'},
                {name: 'A4', description: 'Alternating group on 4 letters'},
                {name: 'D12', description: 'Dihedral group of order 12'},
                {name: 'C3 : C4', description: 'Semidirect product'}
            ],
            14: [
                {name: 'C14', description: 'Cyclic group of order 14'},
                {name: 'D14', description: 'Dihedral group of order 14'}
            ],
            15: [{name: 'C15', description: 'Cyclic group of order 15'}],
            16: [
                {name: 'C16', description: 'Cyclic group of order 16'},
                {name: 'C8 x C2', description: 'Direct product'},
                {name: 'C4 x C4', description: 'Direct product'},
                {name: 'C4 x C2 x C2', description: 'Direct product'},
                {name: 'C2 x C2 x C2 x C2', description: 'Elementary abelian'},
                {name: 'D16', description: 'Dihedral group of order 16'},
                {name: 'Q16', description: 'Generalized quaternion'},
                {name: 'QD16', description: 'Quasi-dihedral'},
                {name: 'C8 : C2', description: 'Semidirect product'},
                {name: 'C2 x D8', description: 'Direct product'},
                {name: 'C2 x Q8', description: 'Direct product'},
                {name: 'C4 : C4', description: 'Semidirect product'},
                {name: 'G4,4', description: 'Group of order 16'},
                {name: '(C4 x C2) : C2', description: 'Semidirect product'}
            ],
            18: [
                {name: 'C18', description: 'Cyclic group of order 18'},
                {name: 'C6 x C3', description: 'Direct product'},
                {name: 'D18', description: 'Dihedral group of order 18'},
                {name: 'C3 x S3', description: 'Direct product'},
                {name: '(C3 x C3) : C2', description: 'Semidirect product'}
            ],
            20: [
                {name: 'C20', description: 'Cyclic group of order 20'},
                {name: 'C10 x C2', description: 'Direct product'},
                {name: 'D20', description: 'Dihedral group of order 20'},
                {name: 'C5 ‚ãä C4', description: 'Semidirect product'},
                {name: 'Fr20', description: 'Frobenius group'}
            ]
        };

        // ÁßªÂä®Á´ØËæìÂÖ•Â§ÑÁêÜ
        function showMobileInput(row, col) {
            if (!state.isMobile) return false;
            
            state.mobileInputTarget = [row, col];
            const overlay = document.getElementById('mobileInputOverlay');
            const inputField = document.getElementById('mobileInputField');
            
            if (overlay && inputField) {
                inputField.max = state.currentOrder - 1;
                inputField.value = state.multiTable[row][col] === -1 ? '' : state.multiTable[row][col];
                overlay.classList.add('active');
                setTimeout(() => inputField.focus(), 100);
                return true;
            }
            return false;
        }

        function closeMobileInput() {
            const overlay = document.getElementById('mobileInputOverlay');
            if (overlay) {
                overlay.classList.remove('active');
                state.mobileInputTarget = null;
            }
        }

        function confirmMobileInput() {
            if (!state.mobileInputTarget) return;
            
            const [row, col] = state.mobileInputTarget;
            const inputField = document.getElementById('mobileInputField');
            const value = parseInt(inputField.value);
            
            if (isNaN(value) || value < 0 || value >= state.currentOrder) {
                state.multiTable[row][col] = -1;
            } else {
                state.multiTable[row][col] = value;
            }
            
            renderTable();
            updateElementInfo();
            closeMobileInput();
        }

        // ‰øÆÂ§çÂêéÁöÑÈáçÊñ∞Ê†áËÆ∞Áæ§ÂÖÉÁ¥†ÂáΩÊï∞
        function relabelGroup(table) {
            const order = table.length;
            const permutation = generateRandomPermutation(order);
            const newTable = Array(order).fill(null).map(() => Array(order).fill(0));
            
            // Ê≠£Á°ÆÁöÑÈáçÊñ∞Ê†áËÆ∞ÔºönewTable[œÄ(i)][œÄ(j)] = œÄ(table[i][j])
            for (let i = 0; i < order; i++) {
                for (let j = 0; j < order; j++) {
                    const newI = permutation[i];
                    const newJ = permutation[j];
                    const newValue = permutation[table[i][j]];
                    newTable[newI][newJ] = newValue;
                }
            }
            
            return newTable;
        }

        // ÊîπËøõÁöÑpuzzleÁîüÊàêÂáΩÊï∞Ôºå‰ΩøÁî®ÁÆÄÂåñÁöÑÊ†ºÂ≠êÊï∞ÈáèËÆ°ÁÆó
        function generatePuzzleFromDiscovered(order, puzzleIndex) {
            const discoveredGroupsOfOrder = storage.discoveredGroups.filter(g => g.order === order && g.table);
            
            if (discoveredGroupsOfOrder.length === 0) {
                return null;
            }
            
            // Ê†πÊçÆpuzzleIndexÈÄâÊã©Áæ§ÔºàÂæ™ÁéØ‰ΩøÁî®Ôºâ
            const selectedGroup = discoveredGroupsOfOrder[puzzleIndex % discoveredGroupsOfOrder.length];
            let groupTable = JSON.parse(JSON.stringify(selectedGroup.table));
            
            // ÈöèÊú∫ÂÜ≥ÂÆöÊòØÂê¶ÈáçÊñ∞Ê†áËÆ∞ÂÖÉÁ¥†Ôºà50%Ê¶ÇÁéáÔºâ
            if (Math.random() > 0.5) {
                groupTable = relabelGroup(groupTable);
            }
            
            // ‰ΩøÁî®ÁÆÄÂåñÁöÑÊ†ºÂ≠êÊï∞ÈáèËÆ°ÁÆó
            const targetCells = getCellDisplayCount(order);
            const cellsToShow = selectStrategicCells(groupTable, order, targetCells);
            
            // ÁîüÊàêimmutable cellsÂíåhint
            const immutableCells = cellsToShow.map(([i, j]) => [i, j, groupTable[i][j]]);
            const hint = generateHint(selectedGroup.name, order);
            
            return {
                cells: immutableCells,
                hint: hint,
                sourceName: selectedGroup.name
            };
        }

        // ÊàòÁï•ÊÄßÂú∞ÈÄâÊã©Ë¶ÅÊòæÁ§∫ÁöÑÂçïÂÖÉÊ†ºÔºå‰ΩøÁî®ÈÖçÁΩÆÁöÑÊï∞Èáè
        function selectStrategicCells(table, order, targetCells) {
            const positions = [];
            
            // ÊÄªÊòØÂåÖÂê´‰∏Ä‰∫õÂÖ≥ÈîÆ‰ΩçÁΩÆÔºö
            // 1. ÂØπËßíÁ∫ø‰∏äÁöÑ‰∏Ä‰∫õÂÖÉÁ¥†ÔºàÂ∏ÆÂä©ËØÜÂà´Âçï‰ΩçÂÖÉÔºâ
            for (let i = 0; i < order; i++) {
                if (Math.random() < 0.4 && positions.length < targetCells) { // 40%Ê¶ÇÁéáÂåÖÂê´ÂØπËßíÁ∫øÂÖÉÁ¥†
                    positions.push([i, i]);
                }
            }
            
            // 2. Á¨¨‰∏ÄË°åÂíåÁ¨¨‰∏ÄÂàóÁöÑ‰∏Ä‰∫õÂÖÉÁ¥†ÔºàÂ¶ÇÊûúÂåÖÂê´Âçï‰ΩçÂÖÉÔºâ
            const identity = findIdentityInTable(table);
            if (identity !== -1) {
                // ÂåÖÂê´Âçï‰ΩçÂÖÉË°åÁöÑ‰∏Ä‰∫õÂÖÉÁ¥†
                for (let j = 0; j < order && positions.length < targetCells; j++) {
                    if (Math.random() < 0.3 && !positions.some(([r, c]) => r === identity && c === j)) {
                        positions.push([identity, j]);
                    }
                }
                // ÂåÖÂê´Âçï‰ΩçÂÖÉÂàóÁöÑ‰∏Ä‰∫õÂÖÉÁ¥†
                for (let i = 0; i < order && positions.length < targetCells; i++) {
                    if (Math.random() < 0.3 && !positions.some(([r, c]) => r === i && c === identity)) {
                        positions.push([i, identity]);
                    }
                }
            }
            
            // 3. ÈöèÊú∫Ê∑ªÂä†Êõ¥Â§öÂçïÂÖÉÊ†ºÁõ¥Âà∞ËææÂà∞ÁõÆÊ†áÊï∞Èáè
            const allPositions = [];
            for (let i = 0; i < order; i++) {
                for (let j = 0; j < order; j++) {
                    allPositions.push([i, j]);
                }
            }
            
            // ÈöèÊú∫Êâì‰π±Ââ©‰Ωô‰ΩçÁΩÆ
            const remainingPositions = allPositions.filter(([i, j]) => 
                !positions.some(([r, c]) => r === i && c === j)
            );
            shuffleArray(remainingPositions);
            
            // Ê∑ªÂä†ÈöèÊú∫‰ΩçÁΩÆÁõ¥Âà∞ËææÂà∞ÁõÆÊ†á
            while (positions.length < targetCells && remainingPositions.length > 0) {
                positions.push(remainingPositions.pop());
            }
            
            return positions;
        }

        // Âú®ÁªôÂÆöË°®Ê†º‰∏≠Êü•ÊâæÂçï‰ΩçÂÖÉ
        function findIdentityInTable(table) {
            const order = table.length;
            for (let e = 0; e < order; e++) {
                let isIdentity = true;
                for (let i = 0; i < order; i++) {
                    if (table[e][i] !== i || table[i][e] !== i) {
                        isIdentity = false;
                        break;
                    }
                }
                if (isIdentity) return e;
            }
            return -1;
        }

        // Êï∞ÁªÑÊâì‰π±ÂáΩÊï∞
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // ÁîüÊàêÈöèÊú∫ÁΩÆÊç¢
        function generateRandomPermutation(n) {
            const arr = Array.from({length: n}, (_, i) => i);
            shuffleArray(arr);
            return arr;
        }

        // ÊîπËøõÁöÑÊèêÁ§∫ÁîüÊàê
        function generateHint(groupName, order) {
            const hints = {
                'C4': 'This is a cyclic group. Find the generator element - one element whose powers give all others.',
                'C2 x C2': 'Klein four-group: every non-identity element has order 2. All elements commute.',
                'C6': 'Cyclic group of order 6. Look for the generator element.',
                'S3': 'Symmetric group S3: not all elements commute. Contains 3-cycles and 2-cycles.',
                'C8': 'Cyclic group of order 8. Find the generator element.',
                'D8': 'Dihedral group: contains rotations and reflections. Half the elements have order 2.',
                'D4': 'Dihedral group: contains rotations and reflections.',
                'A4': 'Alternating group: all even permutations on 4 elements. Contains 3-cycles.',
                'Q8': 'Quaternion group: non-abelian, all non-identity elements have order 4.'
            };
            
            const specificHint = hints[groupName];
            if (specificHint) {
                return specificHint;
            }
            
            // ÈÄöÁî®ÊèêÁ§∫
            if (groupName.startsWith('C') && !groupName.includes('x')) {
                return `Cyclic group of order ${order}. All elements can be generated by powers of one element.`;
            } else if (groupName.includes('x')) {
                return `Direct product group. Elements behave independently in each component.`;
            } else if (groupName.startsWith('D')) {
                return `Dihedral group of order ${order}. Contains rotations and reflections.`;
            }
            
            return `Complete this group structure of order ${order}. Based on ${groupName}.`;
        }

        // Ê£ÄÊü•ËØ•Èò∂Êï∞ÊòØÂê¶ÊúâÂ∑≤ÂèëÁé∞ÁöÑÁæ§
        function hasDiscoveredGroupsOfOrder(order) {
            return storage.discoveredGroups.some(g => g.order === order && g.table);
        }

        // Ëé∑ÂèñËØ•Èò∂Êï∞Â∑≤ÂèëÁé∞ÁöÑÁæ§Êï∞Èáè
        function getDiscoveredGroupsCountOfOrder(order) {
            return storage.discoveredGroups.filter(g => g.order === order && g.table).length;
        }

        // ËØ≠Ë®ÄÁ≥ªÁªü
        const translations = {
            en: {
                tutorial: 'Tutorial',
                startGame: 'Start Game',
                gallery: 'Gallery',
                settings: 'Settings',
                exit: 'Exit',
                discovered: 'Discovered',
                puzzle: 'Puzzle',
                order: 'Order',
                conjugates: 'Conjugates',
                centralizer: 'Centralizer',
                submit: 'Submit',
                clear: 'Clear',
                back: 'Back',
                selectLevel: 'Select Level',
                discoveredGroups: 'Discovered Groups',
                enableScreenshots: 'Enable Screenshots',
                language: 'Language',
                congratulations: 'Congratulations!',
                thisGroupIs: 'This group is',
                validGroup: 'You have successfully created a valid group!',
                youveDiscoveredBefore: "You've discovered it before.",
                notAGroup: 'This is not a valid group. Check the group axioms.',
                fillTable: 'Please fill in the entire table first.',
                hintTooltip: 'Click to see hint',
                message: 'Message',
                noPuzzlesAvailable: 'No puzzles available - discover groups first in exploration mode!',
                noPuzzlesHint: 'Discover groups first to unlock puzzles',
                puzzleCompleted: 'Puzzle completed successfully!'
            },
            cn: {
                tutorial: 'Ê∏∏ÊàèËØ¥Êòé',
                startGame: 'ÂºÄÂßãÊ∏∏Êàè',
                gallery: 'ÁîªÂªä',
                settings: 'ËÆæÁΩÆ',
                exit: 'ÈÄÄÂá∫',
                discovered: 'Â∑≤ÂèëÁé∞',
                puzzle: 'Ë∞úÈ¢ò',
                order: 'Èò∂',
                conjugates: 'ÂÖ±ËΩ≠ÂÖÉ',
                centralizer: '‰∏≠ÂøÉÂåñÂ≠ê',
                submit: 'Êèê‰∫§',
                clear: 'Ê∏ÖÁ©∫',
                back: 'ËøîÂõû',
                selectLevel: 'ÈÄâÊã©ÂÖ≥Âç°',
                discoveredGroups: 'Â∑≤ÂèëÁé∞ÁöÑÁæ§',
                enableScreenshots: 'ÂêØÁî®Êà™Âõæ',
                language: 'ËØ≠Ë®Ä / Language',
                congratulations: 'ÊÅ≠ÂñúÔºÅ',
                thisGroupIs: 'Ëøô‰∏™Áæ§ÊòØ',
                validGroup: '‰Ω†ÊàêÂäüÂàõÂª∫‰∫Ü‰∏Ä‰∏™ÊúâÊïàÁöÑÁæ§ÔºÅ',
                youveDiscoveredBefore: '‰Ω†‰πãÂâçÂ∑≤ÁªèÂèëÁé∞ËøáÂÆÉ‰∫Ü„ÄÇ',
                notAGroup: 'Ëøô‰∏çÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑÁæ§„ÄÇËØ∑Ê£ÄÊü•Áæ§ÂÖ¨ÁêÜ„ÄÇ',
                fillTable: 'ËØ∑ÂÖàÂ°´Êª°Êï¥‰∏™Ë°®Ê†º„ÄÇ',
                hintTooltip: 'ÁÇπÂáªÊü•ÁúãÊèêÁ§∫',
                message: 'Ê∂àÊÅØ',
                noPuzzlesAvailable: 'Êó†ÂèØÁî®Ë∞úÈ¢ò - ËØ∑ÂÖàÂú®Êé¢Á¥¢Ê®°Âºè‰∏≠ÂèëÁé∞Áæ§ÔºÅ',
                noPuzzlesHint: 'ÂÖàÂèëÁé∞Áæ§‰ª•Ëß£ÈîÅË∞úÈ¢ò',
                puzzleCompleted: 'Ë∞úÈ¢òÂÆåÊàêÊàêÂäüÔºÅ'
            }
        };

        function t(key) {
            return translations[state.language][key] || key;
        }

        // ÂàùÂßãÂåñ
        function init() {
            // Ê£ÄÊµãÁßªÂä®ËÆæÂ§á
            state.isMobile = detectMobile();
            
            // Âä†ËΩΩËÆæÁΩÆ
            state.language = storage.settings.language || 'en';
            
            const screenshotToggle = document.getElementById('screenshotToggle');
            if (screenshotToggle) screenshotToggle.classList.toggle('on', storage.settings.screenshot);

            const languageSelect = document.getElementById('languageSelect');
            if (languageSelect) languageSelect.value = state.language;
            
            // ÁßªÂä®Á´ØËæìÂÖ•Ê°Ü‰∫ã‰ª∂ÁõëÂê¨
            if (state.isMobile) {
                const inputField = document.getElementById('mobileInputField');
                if (inputField) {
                    inputField.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            confirmMobileInput();
                        } else if (e.key === 'Escape') {
                            closeMobileInput();
                        }
                    });
                }
            }
            
            // Êõ¥Êñ∞ÊñáÊú¨
            updateLanguage();
        }

        // È°µÈù¢ÂàáÊç¢
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) {
                 screenToShow.classList.add('active');
            } else {
                console.error("Screen not found: " + screenId);
                document.getElementById('mainMenu').classList.add('active');
            }
            state.currentPage = screenId;
        }

        function showMainMenu() {
            showScreen('mainMenu');
        }

        function showGameMenu() {
            generateLevelList();
            showScreen('gameMenu');
        }

        function showGallery() {
            updateGallery();
            showScreen('gallery');
        }

        function showTutorial() {
            showScreen('tutorial');
        }

        function showSettings() {
            showScreen('settings');
        }

        function exitGame() {
            if (confirm('Are you sure you want to exit?')) {
                window.close();
            }
        }

        function backToGameMenu() {
            showGameMenu();
        }

        // ÁîüÊàêÂÖ≥Âç°ÂàóË°®
        function generateLevelList() {
            const levelList = document.getElementById('levelList');
            if (!levelList) return;
            levelList.innerHTML = '';
            
            levelOrders.forEach(order => {
                const discovered = Array.isArray(storage.discoveredGroups) ? storage.discoveredGroups.filter(g => g.order === order).length : 0;
                const total = groupsData[order]?.length || 0;
                const solvedPuzzles = (typeof storage.solvedPuzzles === 'object' && storage.solvedPuzzles !== null && storage.solvedPuzzles[order]) ? storage.solvedPuzzles[order] : 0;
                
                // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ∑≤ÂèëÁé∞ÁöÑÁæ§ÂèØ‰ª•Áî®‰∫épuzzle
                const hasDiscoveredGroups = hasDiscoveredGroupsOfOrder(order);
                const discoveredGroupsCount = getDiscoveredGroupsCountOfOrder(order);
                
                const row = document.createElement('div');
                row.className = 'level-row';
                
                if (hasDiscoveredGroups) {
                    // ÊúâÂ∑≤ÂèëÁé∞ÁöÑÁæ§ÔºöÊòæÁ§∫‰∏§‰∏™ÊåâÈíÆ
                    row.innerHTML = `
                        <div class="level-label">${t('order')} ${order}</div>
                        <div class="level-content">
                            <div class="level-buttons">
                                <button class="level-button" onclick="startExploration(${order})">
                                    ${t('discovered')} ${discovered}/${total}
                                </button>
                                <button class="level-button" onclick="startPuzzle(${order})">
                                    ${t('puzzle')} ${solvedPuzzles}/${discoveredGroupsCount}
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // Ê≤°ÊúâÂ∑≤ÂèëÁé∞ÁöÑÁæ§ÔºöÂè™ÊòæÁ§∫ÂèëÁé∞ÊåâÈíÆÂíåÊèêÁ§∫
                    row.innerHTML = `
                        <div class="level-label">${t('order')} ${order}</div>
                        <div class="level-content">
                            <div class="level-buttons">
                                <button class="level-button" onclick="startExploration(${order})">
                                    ${t('discovered')} ${discovered}/${total}
                                </button>
                            </div>
                            <div class="puzzle-hint">${t('noPuzzlesHint')}</div>
                        </div>
                    `;
                }
                
                levelList.appendChild(row);
            });
        }

        // ÂºÄÂßãÊé¢Á¥¢Ê®°Âºè
        function startExploration(order) {
            state.currentMode = 'exploration';
            state.currentOrder = order;
            state.immutableCells = [];
            initTable();
            const gameTitleEl = document.getElementById('gameTitle');
            if(gameTitleEl) gameTitleEl.textContent = `${t('order')} ${order} Group`;
            const hintIconEl = document.getElementById('hintIcon');
            if(hintIconEl) hintIconEl.style.display = 'none';
            showScreen('gameArea');
        }

        // ÂºÄÂßãË∞úÈ¢òÊ®°Âºè
        function startPuzzle(order) {
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂ∑≤ÂèëÁé∞ÁöÑÁæ§
            if (!hasDiscoveredGroupsOfOrder(order)) {
                showModal(t('noPuzzlesAvailable'));
                return;
            }
            
            state.currentMode = 'puzzle';
            state.currentOrder = order;
            initTable();
            
            const solvedCount = (typeof storage.solvedPuzzles === 'object' && storage.solvedPuzzles !== null && storage.solvedPuzzles[order]) ? storage.solvedPuzzles[order] : 0;
            
            // ‰ΩøÁî®ÊîπËøõÁöÑpuzzleÁîüÊàêÁ≥ªÁªü
            const puzzle = generatePuzzleFromDiscovered(order, solvedCount);
            
            if (!puzzle) {
                showModal(t('noPuzzlesAvailable'));
                return;
            }
            
            state.immutableCells = [];
            if (puzzle.cells && Array.isArray(puzzle.cells)) {
                puzzle.cells.forEach(([i, j, value]) => {
                    if (i < state.currentOrder && j < state.currentOrder) {
                       state.multiTable[i][j] = value;
                       state.immutableCells.push([i, j]);
                    }
                });
            }
            
            state.hint = puzzle.hint || '';
            const hintTooltipEl = document.getElementById('hintTooltip');
            if (hintTooltipEl) hintTooltipEl.textContent = state.hint;
            
            const gameTitleEl = document.getElementById('gameTitle');
            if(gameTitleEl) gameTitleEl.textContent = `${t('order')} ${order} ${t('puzzle')}`;
            const hintIconEl = document.getElementById('hintIcon');
            if(hintIconEl) hintIconEl.style.display = 'block';
            
            renderTable();
            showScreen('gameArea');
        }

        // ÂàùÂßãÂåñË°®Ê†º
        function initTable() {
            state.multiTable = Array(state.currentOrder).fill(null).map(() => Array(state.currentOrder).fill(-1));
            state.selectedCell = null;
            state.selectedHeader = null;
            renderTable();
        }

        // Ê∏≤ÊüìË°®Ê†º
        function renderTable() {
            const container = document.getElementById('multiplicationTable');
            if (!container) return;
            container.innerHTML = '';
            
            const cellSize = state.isMobile && window.innerWidth <= 480 ? 30 : (window.innerWidth <= 768 ? 35 : 40);
            container.style.gridTemplateColumns = `repeat(${state.currentOrder + 1}, ${cellSize}px)`;
            
            // Á©∫ËßíËêΩ
            const corner = document.createElement('div');
            corner.className = 'cell header';
            container.appendChild(corner);
            
            // ÂàóÂ§¥
            for (let i = 0; i < state.currentOrder; i++) {
                const header = document.createElement('div');
                header.className = 'cell header';
                if (state.selectedHeader === i) header.classList.add('selected');
                header.textContent = i;
                header.onclick = () => selectHeader(i);
                container.appendChild(header);
            }
            
            // Ë°å
            for (let i = 0; i < state.currentOrder; i++) {
                // Ë°åÂ§¥
                const rowHeader = document.createElement('div');
                rowHeader.className = 'cell header';
                if (state.selectedHeader === i) rowHeader.classList.add('selected');
                rowHeader.textContent = i;
                rowHeader.onclick = () => selectHeader(i);
                container.appendChild(rowHeader);
                
                // ÂçïÂÖÉÊ†º
                for (let j = 0; j < state.currentOrder; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    
                    const value = state.multiTable[i][j];
                    if (value >= 0 && value < state.currentOrder) {
                        cell.textContent = value;
                        cell.style.background = getElementColor(value);
                    } else {
                         cell.textContent = '';
                         cell.style.background = '#222';
                    }
                    
                    if (state.immutableCells.some(([r, c]) => r === i && c === j)) {
                        cell.classList.add('immutable');
                    } else {
                        if (state.selectedCell && state.selectedCell[0] === i && state.selectedCell[1] === j) {
                            cell.classList.add('selected');
                        }
                        cell.onclick = () => selectCell(i, j);
                        cell.oncontextmenu = (e) => {
                            e.preventDefault();
                            clearCell(i, j);
                        };
                    }
                    
                    container.appendChild(cell);
                }
            }
        }

        // ‰ºòÈõÖÁöÑÈ¢úËâ≤ÁîüÊàêÂáΩÊï∞
        function getElementColor(element, maxOrder = null) {
            // ‰ΩøÁî®‰º†ÂÖ•ÁöÑmaxOrderÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî®ÂΩìÂâçÊ∏∏ÊàèÁöÑorder
            const orderLimit = maxOrder !== null ? maxOrder : state.currentOrder;
            
            if (element === -1 || element >= orderLimit) return 'rgba(45, 45, 68, 0.8)';
            
            const colors = [
                '#7c9ad9', '#f59e0b', '#10b981', '#ef4444', '#8b5cf6',
                '#f97316', '#06b6d4', '#84cc16', '#ec4899', '#6366f1',
                '#14b8a6', '#f59e0b', '#3b82f6', '#22c55e', '#a855f7',
                '#e11d48', '#0ea5e9', '#65a30d', '#d946ef', '#2563eb'
            ];
            
            return colors[element % colors.length];
        }

        // ÈÄâÊã©Ë°®Â§¥
        function selectHeader(index) {
            if (state.selectedHeader !== null && state.selectedHeader !== index) {
                swapElements(state.selectedHeader, index);
                state.selectedHeader = null;
            } else {
                state.selectedHeader = index;
            }
            renderTable();
        }

        // ‰∫§Êç¢ÂÖÉÁ¥†
        function swapElements(elem1, elem2) {
            if (elem1 === elem2 || elem1 < 0 || elem1 >= state.currentOrder || elem2 < 0 || elem2 >= state.currentOrder) return;
            
            const newTable = state.multiTable.map(row => [...row]);
            
            // ‰∫§Êç¢Ë°å
            [newTable[elem1], newTable[elem2]] = [newTable[elem2], newTable[elem1]];
            
            // ‰∫§Êç¢Âàó
            for (let i = 0; i < state.currentOrder; i++) {
                [newTable[i][elem1], newTable[i][elem2]] = [newTable[i][elem2], newTable[i][elem1]];
            }
            
            // Êõ¥Êñ∞ÂÄº
            for (let i = 0; i < state.currentOrder; i++) {
                for (let j = 0; j < state.currentOrder; j++) {
                    if (newTable[i][j] === elem1) newTable[i][j] = -2;
                    else if (newTable[i][j] === elem2) newTable[i][j] = elem1;
                }
            }
             for (let i = 0; i < state.currentOrder; i++) {
                for (let j = 0; j < state.currentOrder; j++) {
                    if (newTable[i][j] === -2) newTable[i][j] = elem2;
                }
            }
            
            state.multiTable = newTable;
            
            // Êõ¥Êñ∞‰∏çÂèØÂèòÂçïÂÖÉÊ†º‰ΩçÁΩÆ
            state.immutableCells = state.immutableCells.map(([r, c]) => {
                let newR = r;
                let newC = c;
                if (r === elem1) newR = elem2; else if (r === elem2) newR = elem1;
                if (c === elem1) newC = elem2; else if (c === elem2) newC = elem1;
                return [newR, newC];
            });
        }

        // ÈÄâÊã©ÂçïÂÖÉÊ†º
        function selectCell(row, col) {
            // Ê£ÄÊü•ÊòØÂê¶ÊòØ‰∏çÂèØÂèòÂçïÂÖÉÊ†º
            if (state.immutableCells.some(([r, c]) => r === row && c === col)) return;
            
            state.selectedCell = [row, col];
            state.selectedHeader = null;
            
            // ÁßªÂä®Á´ØÔºöÁõ¥Êé•ÂºπÂá∫ËæìÂÖ•Ê°Ü
            if (state.isMobile) {
                if (showMobileInput(row, col)) {
                    return; // ÊàêÂäüÊòæÁ§∫ÁßªÂä®Á´ØËæìÂÖ•Ê°ÜÔºå‰∏çÈúÄË¶ÅÊ∏≤ÊüìË°®Ê†º
                }
            }
            
            renderTable();
            updateElementInfo();
        }

        // Ê∏ÖÈô§ÂçïÂÖÉÊ†º
        function clearCell(row, col) {
            if (state.immutableCells.some(([r, c]) => r === row && c === col)) return;
            state.multiTable[row][col] = -1;
            renderTable();
        }

        // Êõ¥Êñ∞ÂÖÉÁ¥†‰ø°ÊÅØ
        function updateElementInfo() {
            const elementInfoEl = document.getElementById('elementInfo');
            if (!elementInfoEl) return;

            if (!state.selectedCell) {
                 elementInfoEl.innerHTML = `${t('order')}: -<br>${t('conjugates')}: -<br>${t('centralizer')}: -`;
                 return;
            }
            
            const [row, col] = state.selectedCell;
            const value = state.multiTable[row][col];
            
            if (value >= 0 && value < state.currentOrder) {
                const order = calculateOrder(value);
                const conjugates = calculateConjugates(value);
                const centralizer = calculateCentralizer(value);
                
                elementInfoEl.innerHTML = `
                    ${t('order')}: ${order === null ? '-' : order}<br>
                    ${t('conjugates')}: ${conjugates.length > 0 ? conjugates.join(', ') : '-'}<br>
                    ${t('centralizer')}: ${centralizer.length > 0 ? centralizer.join(', ') : '-'}
                `;
            } else {
                 elementInfoEl.innerHTML = `${t('order')}: -<br>${t('conjugates')}: -<br>${t('centralizer')}: -`;
            }
        }

        // ËÆ°ÁÆóÂÖÉÁ¥†ÁöÑÈò∂
        function calculateOrder(element) {
            if (element < 0 || element >= state.currentOrder) return null;
            const identity = findIdentity();
            if (identity === -1) return null;
            if (element === identity) return 1;
            
            let currentElement = element;
            for (let i = 2; i <= state.currentOrder; i++) {
                currentElement = multiply(currentElement, element);
                if (currentElement === -1) return null;
                if (currentElement === identity) return i;
            }
            return null;
        }

        // ËÆ°ÁÆóÂÖ±ËΩ≠ÂÖÉ
        function calculateConjugates(element) {
            if (element < 0 || element >= state.currentOrder) return [];
            const conjugates = new Set([element]);
            const identity = findIdentity();
            if (identity === -1) return [element];
            
            for (let g = 0; g < state.currentOrder; g++) {
                const gInv = findInverse(g);
                if (gInv === -1) continue;
                
                const g_x_element = multiply(g, element);
                if (g_x_element === -1) continue;
                const conjugate = multiply(g_x_element, gInv);
                
                if (conjugate !== -1 && conjugate < state.currentOrder) {
                    conjugates.add(conjugate);
                }
            }
            
            return Array.from(conjugates).sort((a, b) => a - b);
        }

        // ËÆ°ÁÆó‰∏≠ÂøÉÂåñÂ≠ê
        function calculateCentralizer(element) {
            if (element < 0 || element >= state.currentOrder) return [];
            const centralizer = [];
            
            for (let g = 0; g < state.currentOrder; g++) {
                const g_x_element = multiply(g, element);
                const element_x_g = multiply(element, g);
                
                if (g_x_element !== -1 && element_x_g !== -1 && g_x_element === element_x_g) {
                    centralizer.push(g);
                }
            }
            
            return centralizer.sort((a,b) => a - b);
        }

        // Êü•ÊâæÂçï‰ΩçÂÖÉ
        function findIdentity() {
            for (let e = 0; e < state.currentOrder; e++) {
                let isIdentity = true;
                for (let i = 0; i < state.currentOrder; i++) {
                    if (multiply(e, i) !== i || multiply(i, e) !== i) {
                        isIdentity = false;
                        break;
                    }
                }
                if (isIdentity) return e;
            }
            return -1;
        }

        // Êü•ÊâæÈÄÜÂÖÉ
        function findInverse(element) {
            if (element < 0 || element >= state.currentOrder) return -1;
            const identity = findIdentity();
            if (identity === -1) return -1;
            
            for (let i = 0; i < state.currentOrder; i++) {
                if (multiply(element, i) === identity && multiply(i, element) === identity) {
                    return i;
                }
            }
            return -1;
        }

        // ‰πòÊ≥ïËøêÁÆó
        function multiply(a, b) {
            if (a < 0 || a >= state.currentOrder || b < 0 || b >= state.currentOrder) return -1;
            if (!state.multiTable || !state.multiTable[a]) return -1;
            const result = state.multiTable[a][b];
            if (result < 0 || result >= state.currentOrder) return -1;
            return result;
        }

        // ÈîÆÁõòËæìÂÖ•
        document.addEventListener('keydown', (e) => {
            if (state.currentPage !== 'gameArea') return;
            
            if (e.key === 'Escape') {
                backToGameMenu();
                return;
            }
            
            // ÁßªÂä®Á´Ø‰ΩøÁî®ËæìÂÖ•Ê°ÜÔºåË∑≥ËøáÈîÆÁõòËæìÂÖ•
            if (state.isMobile) return;
            
            if (!state.selectedCell) return;
            
            const [row, col] = state.selectedCell;
            if (state.immutableCells.some(([r, c]) => r === row && c === col)) return;
            
            if (e.key >= '0' && e.key <= '9') {
                const digit = parseInt(e.key);
                const currentValue = state.multiTable[row][col];
                
                let newValue;
                if (currentValue === -1 || currentValue === undefined) {
                    // Â¶ÇÊûúÊ†ºÂ≠ê‰∏∫Á©∫ÔºåÁõ¥Êé•ËÆæÁΩÆ‰∏∫ËæìÂÖ•ÁöÑÊï∞Â≠ó
                    newValue = digit;
                } else {
                    // Â¶ÇÊûúÊ†ºÂ≠êÊúâÂÄºÔºåËøΩÂä†Êï∞Â≠ó
                    newValue = parseInt(currentValue.toString() + digit.toString());
                }
                
                // Ê£ÄÊü•Êñ∞ÂÄºÊòØÂê¶Âú®ÊúâÊïàËåÉÂõ¥ÂÜÖ
                if (newValue >= 0 && newValue < state.currentOrder) {
                    state.multiTable[row][col] = newValue;
                    renderTable();
                    updateElementInfo();
                }
                // Â¶ÇÊûúË∂ÖÂá∫ËåÉÂõ¥ÔºåÂøΩÁï•ËæìÂÖ•

            } else if (e.key === 'Backspace') {
                const currentValue = state.multiTable[row][col];
                if (currentValue === -1 || currentValue === undefined) {
                    return; // Â∑≤ÁªèÊòØÁ©∫ÁöÑÔºåÊó†ÈúÄÊìç‰Ωú
                }
                
                const valueStr = currentValue.toString();
                if (valueStr.length === 1) {
                    // Â¶ÇÊûúÂè™Êúâ‰∏Ä‰ΩçÊï∞ÔºåÊ∏ÖÁ©∫Ê†ºÂ≠ê
                    clearCell(row, col);
                } else {
                    // Â¶ÇÊûúÊòØÂ§ö‰ΩçÊï∞ÔºåÂà†Èô§ÊúÄÂêé‰∏Ä‰Ωç
                    const newValue = parseInt(valueStr.slice(0, -1));
                    state.multiTable[row][col] = newValue;
                    renderTable();
                    updateElementInfo();
                }
            } else if (e.key === 'Delete') {
                clearCell(row, col);
            }
        });

        // Êèê‰∫§Ë°®Ê†º
        function submitTable() {
            // Ê£ÄÊü•ÊòØÂê¶Â°´Êª°
            for (let i = 0; i < state.currentOrder; i++) {
                for (let j = 0; j < state.currentOrder; j++) {
                    if (state.multiTable[i][j] === -1 || state.multiTable[i][j] >= state.currentOrder) {
                        showModal(t('fillTable'));
                        return;
                    }
                }
            }
            
            // È™åËØÅÁæ§
            if (isValidGroup()) {
                const groupName = identifyGroup();
                
                // Ê∑ªÂä†ÊàêÂäüÂä®Áîª
                const tableElement = document.getElementById('multiplicationTable');
                if (tableElement) {
                    tableElement.classList.add('celebrate');
                    setTimeout(() => tableElement.classList.remove('celebrate'), 500);
                }
                
                // Êé¢Á¥¢Ê®°ÂºèÔºöËÆ∞ÂΩïÂèëÁé∞ÁöÑÊñ∞Áæ§
                if (state.currentMode === 'exploration') {
                    if (!storage.discoveredGroups.some(g => g.name === groupName && g.order === state.currentOrder)) {
                        storage.discoveredGroups.push({
                            name: groupName, 
                            order: state.currentOrder, 
                            table: JSON.parse(JSON.stringify(state.multiTable))
                        });
                        showModal(`${t('congratulations')}<br>${t('thisGroupIs')} <strong>${groupName}</strong>`);
                    } else {
                        showModal(`${t('congratulations')}<br>${t('validGroup')}<br><em>(${t('youveDiscoveredBefore')})</em>`);
                    }
                    saveData();
                }
                // Ë∞úÈ¢òÊ®°ÂºèÔºö‰ªª‰ΩïÊúâÊïàÁæ§ÈÉΩÁÆóÊàêÂäü
                else if (state.currentMode === 'puzzle') {
                    if (typeof storage.solvedPuzzles !== 'object' || storage.solvedPuzzles === null) storage.solvedPuzzles = {};
                    storage.solvedPuzzles[state.currentOrder] = (storage.solvedPuzzles[state.currentOrder] || 0) + 1;
                    saveData();
                    showModal(`üéâ ${t('puzzleCompleted')}<br>${t('thisGroupIs')} <strong>${groupName}</strong>`);
                }
            } else {
                showModal(`‚ùå ${t('notAGroup')}`);
            }
        }

        // È™åËØÅÊòØÂê¶‰∏∫Áæ§
        function isValidGroup() {
            if (state.currentOrder === 0) return false;

            // 1. ÊâæÂà∞Âçï‰ΩçÂÖÉ
            const identity = findIdentity();
            if (identity === -1) return false;

            // 2. Ê£ÄÊü•ÈÄÜÂÖÉ
            for (let i = 0; i < state.currentOrder; i++) {
                if (findInverse(i) === -1) return false;
            }
            
            // 3. Ê£ÄÊü•ÁªìÂêàÂæã
            for (let a = 0; a < state.currentOrder; a++) {
                for (let b = 0; b < state.currentOrder; b++) {
                    for (let c = 0; c < state.currentOrder; c++) {
                        const ab = multiply(a,b);
                        if (ab === -1) return false;
                        const ab_c = multiply(ab, c);
                        
                        const bc = multiply(b,c);
                        if (bc === -1) return false;
                        const a_bc = multiply(a, bc);

                        if (ab_c === -1 || a_bc === -1 || ab_c !== a_bc) return false;
                    }
                }
            }
            
            // 4. Êãâ‰∏ÅÊñπÊÄßË¥®
            for (let i = 0; i < state.currentOrder; i++) {
                const rowSet = new Set();
                const colSet = new Set();
                for (let j = 0; j < state.currentOrder; j++) {
                    rowSet.add(state.multiTable[i][j]);
                    colSet.add(state.multiTable[j][i]);
                }
                if (rowSet.size !== state.currentOrder || colSet.size !== state.currentOrder) {
                    return false;
                }
            }
            
            return true;
        }
        
        // ËØÜÂà´Áæ§
        function identifyGroup() {
            const order = state.currentOrder;
            
            let isAbelian = true;
            for (let i = 0; i < order; i++) {
                for (let j = 0; j < order; j++) {
                    if (multiply(i,j) !== multiply(j,i)) {
                        isAbelian = false;
                        break;
                    }
                }
                if (!isAbelian) break;
            }
            
            if (isPrime(order)) return `C${order}`;
            
            switch (order) {
                case 1: return '1';
                case 2: return 'C2';
                case 3: return 'C3';
                case 4:
                    return isAbelian && hasElementOfOrder(4) ? 'C4' : 'C2 x C2';
                case 5: return 'C5';
                case 6:
                    return isAbelian ? 'C6' : 'S3';
                case 8:
                    if (isAbelian) {
                        if (hasElementOfOrder(8)) return 'C8';
                        if (hasElementOfOrder(4)) return 'C4 x C2';
                        return 'C2 x C2 x C2';
                    } else {
                        // Âå∫ÂàÜ‰∫åÈù¢‰ΩìÁæ§ÂíåÂõõÂÖÉÊï∞Áæ§ÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑÂàÜÊûê
                        return countElementsOfOrder(2) > 1 ? 'D8' : 'Q8';
                    }
                case 9:
                    return hasElementOfOrder(9) ? 'C9' : 'C3 x C3';
                case 10:
                    return isAbelian ? 'C10' : 'D10';
                default:
                    const knownGroupsForOrder = groupsData[order];
                    if (knownGroupsForOrder) {
                        if (isAbelian) {
                            const abelianMatch = knownGroupsForOrder.find(g => g.name.startsWith('C') || g.name.includes('x'));
                            if (abelianMatch) return abelianMatch.name;
                        } else {
                             const nonAbelianMatch = knownGroupsForOrder.find(g => !g.name.startsWith('C') && !g.name.includes('x'));
                             if (nonAbelianMatch) return nonAbelianMatch.name;
                        }
                    }
                    return `${isAbelian ? "Abelian" : "Non-Abelian"} Group of order ${order}`;
            }
        }
        
        function isPrime(n) {
            if (n <= 1) return false;
            if (n <= 3) return true;
            if (n % 2 === 0 || n % 3 === 0) return false;
            for (let i = 5; i * i <= n; i = i + 6) {
                if (n % i === 0 || n % (i + 2) === 0) return false;
            }
            return true;
        }
        
        function hasElementOfOrder(ord) {
            for (let g = 0; g < state.currentOrder; g++) {
                if (calculateOrder(g) === ord) return true;
            }
            return false;
        }

        function countElementsOfOrder(ord) {
            let count = 0;
            for (let g = 0; g < state.currentOrder; g++) {
                if (calculateOrder(g) === ord) count++;
            }
            return count;
        }

        // Ê∏ÖÁ©∫Ë°®Ê†º
        function clearTable() {
            if (confirm(t('clear') + '?')) {
                for(let i=0; i<state.currentOrder; i++) {
                    for(let j=0; j<state.currentOrder; j++) {
                        if (!state.immutableCells.some(([r, c]) => r === i && c === j)) {
                            state.multiTable[i][j] = -1;
                        }
                    }
                }
                state.selectedCell = null;
                renderTable();
                updateElementInfo();
            }
        }

        // Êõ¥Êñ∞ÁîªÂªä
        function updateGallery() {
            const grid = document.getElementById('galleryGrid');
            if (!grid) return;
            grid.innerHTML = '';
            
            const knownOrders = Object.keys(groupsData).map(Number).sort((a,b) => a-b);

            knownOrders.forEach(order => {
                 const groupsForOrder = groupsData[order] || [];
                 groupsForOrder.forEach(groupInfo => {
                    const discovered = Array.isArray(storage.discoveredGroups) && storage.discoveredGroups.some(g => g.name === groupInfo.name && g.order === order);
                    
                    const card = document.createElement('div');
                    if (discovered) {
                        card.className = 'group-card';
                        const discoveredGroupData = storage.discoveredGroups.find(g => g.name === groupInfo.name && g.order === order);
                        const previewTable = discoveredGroupData && discoveredGroupData.table ? 
                                             generatePreviewTableFromData(discoveredGroupData.table) : 
                                             generatePlaceholderPreviewTable(order);

                        card.innerHTML = `
                            <div class="group-info">
                                <h3>${groupInfo.name}</h3>
                                <div class="order">${t('order')} ${order}</div>
                                <div class="description">${groupInfo.description || 'No description.'}</div>
                            </div>
                            <div class="group-table-preview" style="grid-template-columns: repeat(${Math.min(order, 6)}, 1fr); grid-template-rows: repeat(${Math.min(order, 6)}, 1fr);">
                                ${previewTable}
                            </div>
                        `;
                    } else {
                        card.className = 'group-card unknown';
                        card.innerHTML = `
                            <div>?</div>
                            <div style="font-size: 14px; margin-top: 10px; color: #888;">
                                <strong>${groupInfo.name}</strong><br>
                                ${t('order')} ${order}
                            </div>
                        `;
                    }
                    grid.appendChild(card);
                });
            });
        }
        
        function generatePreviewTableFromData(tableData) {
            if (!tableData || !Array.isArray(tableData)) return generatePlaceholderPreviewTable(1);
            const order = tableData.length;
            const maxShow = Math.min(order, 6);
            let html = '';
            for (let i = 0; i < maxShow; i++) {
                for (let j = 0; j < maxShow; j++) {
                    const val = tableData[i][j];
                    // ‰º†ÂÖ•Ê≠£Á°ÆÁöÑorderÂèÇÊï∞ÁªôgetElementColorÂáΩÊï∞
                    const color = (val >= 0 && val < order) ? getElementColor(val, order) : 'rgba(124, 154, 217, 0.3)';
                    html += `<div class="preview-cell" style="background: ${color};">${(val >= 0 && val < order && order <= 6) ? val : ''}</div>`;
                }
            }
            return html;
        }

        function generatePlaceholderPreviewTable(order) {
            const maxShow = Math.min(order, 6);
            let html = '';
            for (let i = 0; i < maxShow; i++) {
                for (let j = 0; j < maxShow; j++) {
                    const color = 'rgba(75, 85, 99, 0.3)'; 
                    html += `<div class="preview-cell" style="background: ${color};"></div>`;
                }
            }
            return html;
        }

        // ÊòæÁ§∫Ê∂àÊÅØ
        function showModal(message, title = t('message')) {
            const modalTitleEl = document.getElementById('modalTitle');
            const modalTextEl = document.getElementById('modalText');
            const modalEl = document.getElementById('modal');

            if (modalTitleEl) modalTitleEl.textContent = title;
            if (modalTextEl) modalTextEl.innerHTML = message;
            if (modalEl) modalEl.classList.add('active');
        }

        function closeModal() {
            const modalEl = document.getElementById('modal');
            if (modalEl) modalEl.classList.remove('active');
        }

        // ËÆæÁΩÆÂäüËÉΩ
        function toggleScreenshot() {
            if (typeof storage.settings !== 'object' || storage.settings === null) storage.settings = {};
            storage.settings.screenshot = !storage.settings.screenshot;
            const screenshotToggleEl = document.getElementById('screenshotToggle');
            if (screenshotToggleEl) screenshotToggleEl.classList.toggle('on', storage.settings.screenshot);
            saveData();
        }

        function changeLanguage() {
            const languageSelect = document.getElementById('languageSelect');
            if (!languageSelect) return;

            state.language = languageSelect.value;
            if (typeof storage.settings !== 'object' || storage.settings === null) storage.settings = {};
            storage.settings.language = state.language;
            saveData();
            updateLanguage();
            if (state.currentPage === 'gameMenu') generateLevelList();
            if (state.currentPage === 'gameArea') {
                const gameTitleEl = document.getElementById('gameTitle');
                if (gameTitleEl) {
                    if (state.currentMode === 'puzzle') {
                        gameTitleEl.textContent = `${t('order')} ${state.currentOrder} ${t('puzzle')}`;
                    } else {
                        gameTitleEl.textContent = `${t('order')} ${state.currentOrder} Group`;
                    }
                }
                updateElementInfo();
            }
        }

        function updateLanguage() {
            // Main Menu Buttons
            const mainMenuButtons = document.querySelectorAll('#mainMenu .menu-button');
            if (mainMenuButtons.length >= 5) {
                mainMenuButtons[0].textContent = t('tutorial');
                mainMenuButtons[1].textContent = t('startGame');
                mainMenuButtons[2].textContent = t('gallery');
                mainMenuButtons[3].textContent = t('settings');
                mainMenuButtons[4].textContent = t('exit');
            }

            // Back Buttons
            document.querySelectorAll('.back-button').forEach(btn => btn.textContent = `‚Üê ${t('back')}`);
            
            // Game Menu
            const gameMenuTitle = document.querySelector('#gameMenu h2');
            if (gameMenuTitle) gameMenuTitle.textContent = t('selectLevel');

            // Game Area
            const gameAreaSubmit = document.querySelector('#gameArea .control-button.primary');
            if (gameAreaSubmit) gameAreaSubmit.textContent = t('submit');
            const gameAreaClear = document.querySelectorAll('#gameArea .control-button')[1];
            if (gameAreaClear) gameAreaClear.textContent = t('clear');
            const selectedInfoStrong = document.querySelector('.info-section strong');
            if(selectedInfoStrong) selectedInfoStrong.textContent = t('Selected Element Info') || "Selected Element Info";

            // Gallery
            const galleryTitle = document.querySelector('#gallery h2');
            if (galleryTitle) galleryTitle.textContent = t('discoveredGroups');

            // Settings
            const settingsTitle = document.querySelector('#settings h2');
            if (settingsTitle) settingsTitle.textContent = t('settings');
            const settingItems = document.querySelectorAll('.setting-item span');
            if (settingItems.length >= 2) {
                settingItems[0].textContent = t('enableScreenshots');
                settingItems[1].textContent = t('language');
            }
            
            const modalButton = document.querySelector('.modal-button');
            if (modalButton) modalButton.textContent = t('Confirm') || 'Confirm';

            if (state.currentPage === 'gameArea') {
                updateElementInfo();
                const gameTitleEl = document.getElementById('gameTitle');
                if (gameTitleEl) {
                    if (state.currentMode === 'puzzle') {
                        gameTitleEl.textContent = `${t('order')} ${state.currentOrder} ${t('puzzle')}`;
                    } else {
                        gameTitleEl.textContent = `${t('order')} ${state.currentOrder} Group`;
                    }
                }
            }
            if(state.currentPage === 'gallery') updateGallery();
            if(state.currentPage === 'gameMenu') generateLevelList();
        }

        // ÂàùÂßãÂåñÊ∏∏Êàè
        document.addEventListener('DOMContentLoaded', init);

        // Á™óÂè£Â§ßÂ∞èÂèòÂåñÊó∂ÈáçÊñ∞Ê∏≤ÊüìË°®Ê†º
        window.addEventListener('resize', () => {
            if (state.currentPage === 'gameArea') {
                setTimeout(renderTable, 100);
            }
        });
    </script>
</body>
</html>
