<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODE Quest - The Mathematical Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P:wght@400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background: #1a1a2e;
            color: #eee;
            font-size: 12px;
            line-height: 1.6;
            overflow-x: hidden;
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: #fff;
            border-radius: 50%;
            animation: twinkle 2s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 15px;
        }

        .compact-hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #0f3460;
            border: 2px solid #4fc3f7;
            border-radius: 8px;
            padding: 12px 20px;
            margin-bottom: 20px;
            font-size: 10px;
        }

        .hud-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .hud-item {
            text-align: center;
        }

        .hud-value {
            font-size: 12px;
            color: #4fc3f7;
            margin-bottom: 2px;
        }

        .hud-label {
            font-size: 7px;
            color: #81c784;
        }

        .lives-display {
            display: flex;
            gap: 8px;
        }

        .life-heart {
            font-size: 18px;
            color: #f44336;
            text-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .life-heart.empty {
            color: #424242;
            text-shadow: none;
        }

        .progress-bar {
            width: 60px;
            height: 6px;
            background: #1a1a2e;
            border: 1px solid #4fc3f7;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 2px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4fc3f7, #81c784);
            width: 0%;
            transition: width 0.8s ease;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            height: calc(100vh - 120px);
        }

        .chart-section {
            background: #16213e;
            border: 2px solid #4fc3f7;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .chart-container {
            flex: 1;
            position: relative;
            background: #0d1929;
            border-radius: 8px;
            border: 1px solid #333;
            overflow: hidden;
        }

        .chart-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .chart-info {
            text-align: center;
            margin-top: 10px;
            font-size: 8px;
            color: #81c784;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            font-size: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 12px;
            height: 3px;
            border-radius: 2px;
        }

        .control-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mission-panel {
            background: #16213e;
            border: 2px solid #4fc3f7;
            border-radius: 10px;
            padding: 20px;
            flex: 1;
        }

        .equation-display {
            background: #0d1929;
            border: 2px solid #81c784;
            border-radius: 8px;
            padding: 18px;
            margin-bottom: 15px;
            text-align: center;
        }

        .equation-text {
            font-size: 16px;
            color: #4fc3f7;
            margin-bottom: 8px;
        }

        .equation-desc {
            font-size: 9px;
            color: #81c784;
            margin-bottom: 12px;
        }

        .mission-params {
            font-size: 9px;
            color: #eee;
        }

        .mission-params div {
            margin: 4px 0;
        }

        .equation-category {
            font-size: 7px;
            color: #ffc107;
            text-align: center;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .difficulty-indicator {
            display: flex;
            justify-content: center;
            gap: 3px;
            margin-bottom: 8px;
        }

        .difficulty-star {
            color: #ffc107;
            font-size: 10px;
        }

        .difficulty-star.empty {
            color: #444;
        }

        .computing-animation {
            display: none;
            text-align: center;
            margin: 15px 0;
            font-size: 8px;
            color: #ffc107;
        }

        .computing-dots::after {
            content: '...';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 33% { content: '.'; }
            34%, 66% { content: '..'; }
            67%, 100% { content: '...'; }
        }

        .results-panel {
            background: #1a2332;
            border: 2px solid #ffc107;
            border-radius: 8px;
            margin-top: 15px;
            overflow: hidden;
        }

        .results-header {
            background: #333;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 10px;
            color: #ffc107;
            border-bottom: 1px solid #555;
            transition: background 0.3s ease;
        }

        .results-header:hover {
            background: #404040;
        }

        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 8px;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .results-content {
            padding: 15px;
            max-height: 300px;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
        }

        .results-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #333;
            font-size: 9px;
        }

        .result-row:last-child {
            border-bottom: none;
        }

        .control-panel {
            background: #16213e;
            border: 2px solid #ff6b6b;
            border-radius: 10px;
            padding: 20px;
        }

        .input-group {
            margin: 15px 0;
        }

        .input-label {
            display: block;
            margin-bottom: 6px;
            color: #4fc3f7;
            font-size: 9px;
        }

        .game-select, .game-input {
            width: 100%;
            padding: 10px;
            background: #0d1929;
            border: 2px solid #4fc3f7;
            border-radius: 6px;
            color: #eee;
            font-family: 'Press Start 2P', cursive;
            font-size: 9px;
        }

        .game-select:focus, .game-input:focus {
            outline: none;
            border-color: #81c784;
            box-shadow: 0 0 10px rgba(129, 199, 132, 0.3);
        }

        .method-info {
            margin-top: 6px;
            font-size: 7px;
            color: #81c784;
            padding: 6px;
            background: rgba(129, 199, 132, 0.1);
            border-radius: 4px;
            line-height: 1.4;
        }

        .wiki-link {
            color: #4fc3f7;
            text-decoration: none;
            border-bottom: 1px dotted #4fc3f7;
        }

        .wiki-link:hover {
            color: #81c784;
            border-color: #81c784;
        }

        .action-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            border: none;
            border-radius: 8px;
            color: #1a1a2e;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            margin: 8px 0;
            transition: all 0.3s ease;
        }

        .action-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(76, 175, 80, 0.4);
        }

        .action-button:disabled {
            background: #424242;
            color: #666;
            cursor: not-allowed;
            transform: none;
        }

        .action-button.computing {
            background: linear-gradient(45deg, #ff9800, #ffc107);
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .success { color: #4caf50; }
        .failure { color: #f44336; }
        .warning { color: #ff9800; }

        .floating-text {
            position: fixed;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            animation: float-up 2s ease-out forwards;
            z-index: 1000;
        }

        @keyframes float-up {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px);
            }
        }

        .game-over-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-over-content {
            background: #16213e;
            border: 3px solid #f44336;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 450px;
        }

        .drawing-indicator {
            color: #ffc107;
            font-size: 8px;
            text-align: center;
            margin-top: 5px;
        }

        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
                grid-template-rows: 300px 1fr;
                height: auto;
            }
            .control-section {
                flex-direction: row;
                gap: 15px;
            }
            .mission-panel, .control-panel {
                flex: 1;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 8px;
            }
            .control-section {
                flex-direction: column;
            }
            .compact-hud {
                flex-direction: column;
                gap: 10px;
            }
            .hud-section {
                justify-content: space-around;
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    
    <div class="container">
        <div class="compact-hud">
            <div class="hud-section">
                <div class="hud-item">
                    <div class="hud-value" id="playerMoney">$2000</div>
                    <div class="hud-label">CREDITS</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="moneyBar"></div>
                    </div>
                </div>
                <div class="hud-item">
                    <div class="hud-value" id="currentLevel">1</div>
                    <div class="hud-label">LEVEL</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="levelProgress"></div>
                    </div>
                </div>
                <div class="hud-item">
                    <div class="hud-value" id="playerScore">0</div>
                    <div class="hud-label">SCORE</div>
                </div>
                <div class="hud-item">
                    <div class="hud-value" id="accuracyRate">0%</div>
                    <div class="hud-label">PRECISION</div>
                </div>
            </div>
            <div class="hud-section">
                <div class="lives-display" id="livesDisplay">
                    <span class="life-heart">♥</span>
                    <span class="life-heart">♥</span>
                    <span class="life-heart">♥</span>
                    <span class="life-heart">♥</span>
                    <span class="life-heart">♥</span>
                </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="chart-section">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Reference Solution</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4fc3f7;"></div>
                        <span>Your Solution</span>
                    </div>
                    <div class="legend-item">
                        <div style="width: 8px; height: 8px; background: #ff6b6b; border-radius: 50%; margin: 0 2px;"></div>
                        <span>Error > Target</span>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="trajectoryCanvas" class="chart-canvas"></canvas>
                </div>
                <div class="chart-info">
                    <div id="chartStatus">Execute a mission to see trajectory comparison</div>
                    <div id="drawingIndicator" class="drawing-indicator" style="display: none;">
                        🔄 Drawing trajectory...
                    </div>
                    <div style="font-size: 7px; color: #666; margin-top: 4px;">
                        Red dots mark points where error exceeds target accuracy<br>
                        Hover over chart to see exact coordinates and error values
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="mission-panel">
                    <div class="equation-display">
                        <div class="equation-category" id="equationCategory">Basic Growth Systems</div>
                        <div class="difficulty-indicator" id="difficultyDisplay">
                            <span class="difficulty-star">★</span>
                            <span class="difficulty-star empty">☆</span>
                            <span class="difficulty-star empty">☆</span>
                            <span class="difficulty-star empty">☆</span>
                            <span class="difficulty-star empty">☆</span>
                        </div>
                        <div class="equation-text" id="equationDisplay">dy/dt = y</div>
                        <div class="equation-desc" id="equationDescription">Exponential Growth Protocol</div>
                        <div class="mission-params">
                            <div>📍 Initial: <span id="initialCondition">y(0) = 1.00</span></div>
                            <div>⏱️ Time Domain: <span id="timeDomain">[0, 1.00]</span></div>
                            <div>🎯 Target Error: <span id="targetError">< 0.01000</span></div>
                            <div>💰 Reward: <span id="missionReward">$150</span></div>
                        </div>
                    </div>

                    <div class="computing-animation" id="computingAnimation">
                        <div>🔄 Computing trajectory<span class="computing-dots"></span></div>
                        <div style="margin-top: 8px; font-size: 7px;">
                            Step <span id="computingStep">0</span> of <span id="totalSteps">0</span>
                        </div>
                    </div>

                    <div id="resultsPanel" class="results-panel" style="display: none;">
                        <div class="results-header" onclick="toggleResults()">
                            <span>📊 MISSION ANALYSIS</span>
                            <span class="collapse-icon" id="collapseIcon">▼</span>
                        </div>
                        <div class="results-content" id="resultsContent">
                            <!-- Results will be populated here -->
                        </div>
                    </div>

                    <div style="text-align: center; margin-top: 15px;">
                        <button class="action-button" id="nextMissionBtn" onclick="nextMission()" style="display: none;">
                            🚀 NEXT MISSION
                        </button>
                    </div>
                </div>

                <div class="control-panel">
                    <div class="input-group">
                        <label class="input-label" for="solutionMethod">🔧 NUMERICAL METHOD:</label>
                        <select class="game-select" id="solutionMethod">
                            <option value="euler">Euler Method</option>
                            <option value="midpoint">Midpoint Method</option>
                            <option value="heun">Heun's Method</option>
                            <option value="rk4">Runge-Kutta 4</option>
                            <option value="adaptive">Adaptive RK</option>
                        </select>
                        <div class="method-info" id="methodDescription">
                            Simple forward Euler integration. Fast but low accuracy. Base cost: $15. <a href="https://en.wikipedia.org/wiki/Euler_method" target="_blank" class="wiki-link">📖 Learn more</a>
                        </div>
                    </div>

                    <div class="input-group">
                        <label class="input-label" for="stepSize">📏 STEP SIZE (h):</label>
                        <input type="number" class="game-input" id="stepSize" value="0.01" min="0.0001" max="1" step="0.0001">
                        <div class="method-info">
                            ⚠️ Smaller steps = Higher accuracy but more expensive
                        </div>
                    </div>

                    <div style="text-align: center; margin: 15px 0;">
                        <div style="font-size: 9px; color: #ffc107; margin-bottom: 8px;">
                            💰 ESTIMATED COST: $<span id="costEstimate">50</span>
                        </div>
                        <button class="action-button" id="executeBtn" onclick="executeMission()">
                            🚀 EXECUTE MISSION
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over-screen" id="gameOverScreen">
        <div class="game-over-content">
            <h2 style="color: #f44336; margin-bottom: 15px;">🌌 MISSION COMPLETE 🌌</h2>
            <div id="finalStats"></div>
            <button class="action-button" onclick="restartGame()" style="margin-top: 15px;">
                🔄 NEW EXPEDITION
            </button>
        </div>
    </div>

    <script>
        // ============ CORE COST CALCULATION MODULE ============
        class CostCalculator {
            static BASE_OVERHEADS = {
                'euler': 15,
                'midpoint': 40,
                'heun': 70,
                'rk4': 120,
                'adaptive': 200
            };

            static MULTIPLIERS = {
                'euler': 1.0,
                'midpoint': 2.5,
                'heun': 3.5,
                'rk4': 6.0,
                'adaptive': 12.0
            };

            static calculate(method, stepSize, timeSpan) {
                const duration = timeSpan[1] - timeSpan[0];
                const stepCost = (duration / stepSize) * 2;
                const overhead = this.BASE_OVERHEADS[method];
                const multiplier = this.MULTIPLIERS[method];
                
                return Math.ceil(stepCost * multiplier + overhead);
            }
        }

        // ============ GAME STATE MANAGER ============
        class GameState {
            constructor() {
                this.money = 2000;
                this.maxMoney = 2000;
                this.level = 1;
                this.score = 0;
                this.lives = 5;
                this.accuracy = 0;
                this.missionCount = 0;
                this.totalMissions = 0;
                this.currentMission = null;
                this.resultsCollapsed = false;
            }

            deductMoney(amount) {
                this.money -= amount;
            }

            addMoney(amount) {
                this.money += amount;
            }

            addScore(amount) {
                this.score += amount;
            }

            loseLife() {
                this.lives--;
            }

            isGameOver() {
                return this.lives <= 0;
            }

            shouldLevelUp() {
                return this.missionCount % 3 === 0;
            }

            levelUp() {
                this.level++;
                this.maxMoney += 500;
            }

            updateAccuracy(newAccuracy) {
                this.accuracy = Math.max(this.accuracy, newAccuracy);
            }

            completeMission() {
                this.missionCount++;
                this.totalMissions++;
            }

            failMission() {
                this.totalMissions++;
            }
        }

        // ============ ENHANCED PROBLEM GENERATOR ============
        class ProblemGenerator {
            static EQUATION_CATEGORIES = {
                'Basic Growth': {
                    color: '#4caf50',
                    difficulty: 1,
                    equations: [
                        {
                            name: 'Exponential Growth',
                            baseEquation: (t, y) => y,
                            variants: [
                                { coeff: 1, display: 'dy/dt = y', desc: 'Natural population growth' },
                                { coeff: 2, display: 'dy/dt = 2y', desc: 'Rapid population expansion' },
                                { coeff: 0.5, display: 'dy/dt = 0.5y', desc: 'Moderate growth rate' },
                                { coeff: 1.5, display: 'dy/dt = 1.5y', desc: 'Accelerated breeding cycle' }
                            ],
                            hasAnalytical: true,
                            solution: (t, y0, t0, coeff) => y0 * Math.exp(coeff * (t - t0))
                        },
                        {
                            name: 'Exponential Decay',
                            baseEquation: (t, y) => -y,
                            variants: [
                                { coeff: 1, display: 'dy/dt = -y', desc: 'Standard radioactive decay' },
                                { coeff: 2, display: 'dy/dt = -2y', desc: 'Fast disintegration' },
                                { coeff: 0.3, display: 'dy/dt = -0.3y', desc: 'Slow degradation process' },
                                { coeff: 1.8, display: 'dy/dt = -1.8y', desc: 'Rapid extinction dynamics' }
                            ],
                            hasAnalytical: true,
                            solution: (t, y0, t0, coeff) => y0 * Math.exp(-coeff * (t - t0))
                        }
                    ]
                },
                'Physics Systems': {
                    color: '#2196f3',
                    difficulty: 2,
                    equations: [
                        {
                            name: 'Harmonic Motion',
                            baseEquation: (t, y) => Math.sin(t),
                            variants: [
                                { freq: 1, amp: 1, display: 'dy/dt = sin(t)', desc: 'Simple harmonic oscillator' },
                                { freq: 2, amp: 1, display: 'dy/dt = sin(2t)', desc: 'High frequency vibration' },
                                { freq: 0.5, amp: 2, display: 'dy/dt = 2sin(0.5t)', desc: 'Low freq, high amplitude' },
                                { freq: 3, amp: 0.5, display: 'dy/dt = 0.5sin(3t)', desc: 'Rapid micro-oscillation' }
                            ],
                            hasAnalytical: true,
                            solution: (t, y0, t0, freq, amp) => y0 - amp/freq * Math.cos(freq * t) + amp/freq * Math.cos(freq * t0)
                        },
                        {
                            name: 'Damped Motion',
                            baseEquation: (t, y) => -0.5 * y + Math.cos(t),
                            variants: [
                                { damping: 0.5, force: 1, display: 'dy/dt = -0.5y + cos(t)', desc: 'Light damping with drive' },
                                { damping: 1.2, force: 1, display: 'dy/dt = -1.2y + cos(t)', desc: 'Heavy damping system' },
                                { damping: 0.2, force: 2, display: 'dy/dt = -0.2y + 2cos(t)', desc: 'Weak damping, strong force' },
                                { damping: 0.8, force: 0.5, display: 'dy/dt = -0.8y + 0.5cos(t)', desc: 'Medium damping, weak drive' }
                            ],
                            hasAnalytical: false
                        },
                        {
                            name: 'Thermal Dynamics',
                            baseEquation: (t, y) => -2 * t * y,
                            variants: [
                                { coeff: 2, display: 'dy/dt = -2ty', desc: 'Gaussian heat distribution' },
                                { coeff: 1, display: 'dy/dt = -ty', desc: 'Slow thermal diffusion' },
                                { coeff: 3, display: 'dy/dt = -3ty', desc: 'Rapid heat dissipation' },
                                { coeff: 0.5, display: 'dy/dt = -0.5ty', desc: 'Insulated cooling process' }
                            ],
                            hasAnalytical: true,
                            solution: (t, y0, t0, coeff) => y0 * Math.exp(-coeff * (t*t - t0*t0))
                        }
                    ]
                },
                'Biological Models': {
                    color: '#4caf50',
                    difficulty: 3,
                    equations: [
                        {
                            name: 'Logistic Growth',
                            baseEquation: (t, y) => y * (1 - y),
                            variants: [
                                { rate: 1, capacity: 1, display: 'dy/dt = y(1-y)', desc: 'Standard population limit' },
                                { rate: 2, capacity: 1, display: 'dy/dt = 2y(1-y)', desc: 'Fast reproduction rate' },
                                { rate: 1, capacity: 2, display: 'dy/dt = y(2-y)', desc: 'Higher carrying capacity' },
                                { rate: 0.5, capacity: 1.5, display: 'dy/dt = 0.5y(1.5-y)', desc: 'Conservative growth model' }
                            ],
                            hasAnalytical: false
                        },
                        {
                            name: 'Predator-Prey Base',
                            baseEquation: (t, y) => y * (2 - Math.sin(t) - y),
                            variants: [
                                { prey: 2, pred: 1, display: 'dy/dt = y(2-sin(t)-y)', desc: 'Predator cycles affect prey' },
                                { prey: 3, pred: 1.5, display: 'dy/dt = y(3-1.5sin(t)-y)', desc: 'Strong predator influence' },
                                { prey: 1.5, pred: 0.5, display: 'dy/dt = y(1.5-0.5sin(t)-y)', desc: 'Weak predation pressure' },
                                { prey: 2.5, pred: 2, display: 'dy/dt = y(2.5-2sin(t)-y)', desc: 'Intense competition' }
                            ],
                            hasAnalytical: false
                        },
                        {
                            name: 'Epidemic Spread',
                            baseEquation: (t, y) => 0.5 * y * Math.exp(-t) * (10 - y),
                            variants: [
                                { infection: 0.5, recovery: 1, display: 'dy/dt = 0.5y·e^(-t)·(10-y)', desc: 'Disease outbreak model' },
                                { infection: 1, recovery: 1.5, display: 'dy/dt = y·e^(-1.5t)·(10-y)', desc: 'Fast immunity buildup' },
                                { infection: 0.3, recovery: 0.5, display: 'dy/dt = 0.3y·e^(-0.5t)·(10-y)', desc: 'Chronic disease spread' },
                                { infection: 0.8, recovery: 2, display: 'dy/dt = 0.8y·e^(-2t)·(10-y)', desc: 'Rapid intervention' }
                            ],
                            hasAnalytical: false
                        }
                    ]
                },
                'Chemical Kinetics': {
                    color: '#ff9800',
                    difficulty: 3,
                    equations: [
                        {
                            name: 'First Order Reaction',
                            baseEquation: (t, y) => -1.5 * y + 0.5,
                            variants: [
                                { rate: 1.5, input: 0.5, display: 'dy/dt = -1.5y + 0.5', desc: 'Standard catalytic reaction' },
                                { rate: 2.5, input: 1, display: 'dy/dt = -2.5y + 1', desc: 'High temperature reaction' },
                                { rate: 0.8, input: 0.2, display: 'dy/dt = -0.8y + 0.2', desc: 'Low energy process' },
                                { rate: 3, input: 1.5, display: 'dy/dt = -3y + 1.5', desc: 'Enzyme-catalyzed reaction' }
                            ],
                            hasAnalytical: true,
                            solution: (t, y0, t0, rate, input) => (input/rate) + (y0 - input/rate) * Math.exp(-rate * (t - t0))
                        },
                        {
                            name: 'Autocatalytic Process',
                            baseEquation: (t, y) => y * y * (3 - y),
                            variants: [
                                { efficiency: 1, capacity: 3, display: 'dy/dt = y²(3-y)', desc: 'Self-amplifying reaction' },
                                { efficiency: 0.5, capacity: 4, display: 'dy/dt = 0.5y²(4-y)', desc: 'Slow autocatalysis' },
                                { efficiency: 2, capacity: 2, display: 'dy/dt = 2y²(2-y)', desc: 'Fast self-assembly' },
                                { efficiency: 1.5, capacity: 5, display: 'dy/dt = 1.5y²(5-y)', desc: 'Chain reaction process' }
                            ],
                            hasAnalytical: false
                        }
                    ]
                },
                'Economic Models': {
                    color: '#9c27b0',
                    difficulty: 4,
                    equations: [
                        {
                            name: 'Market Dynamics',
                            baseEquation: (t, y) => 0.1 * y * (5 - y) - 0.3 * Math.sin(2*t),
                            variants: [
                                { growth: 0.1, volatility: 0.3, display: 'dy/dt = 0.1y(5-y) - 0.3sin(2t)', desc: 'Market with seasonal cycles' },
                                { growth: 0.2, volatility: 0.5, display: 'dy/dt = 0.2y(5-y) - 0.5sin(2t)', desc: 'High volatility market' },
                                { growth: 0.05, volatility: 0.1, display: 'dy/dt = 0.05y(5-y) - 0.1sin(2t)', desc: 'Stable conservative market' },
                                { growth: 0.15, volatility: 0.8, display: 'dy/dt = 0.15y(5-y) - 0.8sin(2t)', desc: 'Speculative bubble dynamics' }
                            ],
                            hasAnalytical: false
                        },
                        {
                            name: 'Investment Growth',
                            baseEquation: (t, y) => 0.08 * y + 0.02 * t * y - 0.001 * y * y,
                            variants: [
                                { interest: 0.08, reinvest: 0.02, friction: 0.001, display: 'dy/dt = 0.08y + 0.02ty - 0.001y²', desc: 'Compound interest with fees' },
                                { interest: 0.12, reinvest: 0.05, friction: 0.002, display: 'dy/dt = 0.12y + 0.05ty - 0.002y²', desc: 'High-yield investment' },
                                { interest: 0.05, reinvest: 0.01, friction: 0.0005, display: 'dy/dt = 0.05y + 0.01ty - 0.0005y²', desc: 'Conservative portfolio' },
                                { interest: 0.15, reinvest: 0.08, friction: 0.005, display: 'dy/dt = 0.15y + 0.08ty - 0.005y²', desc: 'Aggressive growth strategy' }
                            ],
                            hasAnalytical: false
                        }
                    ]
                },
                'Engineering Control': {
                    color: '#795548',
                    difficulty: 4,
                    equations: [
                        {
                            name: 'PID Controller',
                            baseEquation: (t, y) => -2*y - 0.5*Math.sin(t) + Math.cos(2*t),
                            variants: [
                                { p: 2, i: 0.5, d: 1, display: 'dy/dt = -2y - 0.5sin(t) + cos(2t)', desc: 'Proportional-Integral control' },
                                { p: 3, i: 1, d: 1.5, display: 'dy/dt = -3y - sin(t) + 1.5cos(2t)', desc: 'Aggressive control response' },
                                { p: 1, i: 0.2, d: 0.5, display: 'dy/dt = -y - 0.2sin(t) + 0.5cos(2t)', desc: 'Gentle control action' },
                                { p: 2.5, i: 0.8, d: 2, display: 'dy/dt = -2.5y - 0.8sin(t) + 2cos(2t)', desc: 'High-gain feedback system' }
                            ],
                            hasAnalytical: false
                        },
                        {
                            name: 'Servo Tracking',
                            baseEquation: (t, y) => 5*Math.sin(t) - 1.5*y - 0.1*y*Math.abs(y),
                            variants: [
                                { target: 5, damping: 1.5, friction: 0.1, display: 'dy/dt = 5sin(t) - 1.5y - 0.1y|y|', desc: 'Servo motor with friction' },
                                { target: 3, damping: 2, friction: 0.2, display: 'dy/dt = 3sin(t) - 2y - 0.2y|y|', desc: 'High damping servo' },
                                { target: 8, damping: 1, friction: 0.05, display: 'dy/dt = 8sin(t) - y - 0.05y|y|', desc: 'Low friction, high torque' },
                                { target: 4, damping: 3, friction: 0.3, display: 'dy/dt = 4sin(t) - 3y - 0.3y|y|', desc: 'Overdamped positioning' }
                            ],
                            hasAnalytical: false
                        }
                    ]
                },
                'Chaos & Nonlinear': {
                    color: '#e91e63',
                    difficulty: 5,
                    equations: [
                        {
                            name: 'Strange Attractor',
                            baseEquation: (t, y) => Math.sin(y) + 0.5*Math.cos(3*t) - 0.1*y,
                            variants: [
                                { chaos: 1, drive: 0.5, damping: 0.1, display: 'dy/dt = sin(y) + 0.5cos(3t) - 0.1y', desc: 'Driven nonlinear oscillator' },
                                { chaos: 1.5, drive: 1, damping: 0.2, display: 'dy/dt = 1.5sin(y) + cos(3t) - 0.2y', desc: 'Enhanced chaotic behavior' },
                                { chaos: 0.8, drive: 0.3, damping: 0.05, display: 'dy/dt = 0.8sin(y) + 0.3cos(3t) - 0.05y', desc: 'Weak nonlinearity' },
                                { chaos: 2, drive: 1.5, damping: 0.3, display: 'dy/dt = 2sin(y) + 1.5cos(3t) - 0.3y', desc: 'Strongly driven chaos' }
                            ],
                            hasAnalytical: false
                        },
                        {
                            name: 'Bistable System',
                            baseEquation: (t, y) => y - y*y*y + 0.1*Math.sin(t),
                            variants: [
                                { barrier: 1, drive: 0.1, display: 'dy/dt = y - y³ + 0.1sin(t)', desc: 'Double-well potential with noise' },
                                { barrier: 2, drive: 0.2, display: 'dy/dt = 2y - y³ + 0.2sin(t)', desc: 'High barrier bistability' },
                                { barrier: 0.5, drive: 0.05, display: 'dy/dt = 0.5y - y³ + 0.05sin(t)', desc: 'Shallow wells, weak drive' },
                                { barrier: 1.5, drive: 0.3, display: 'dy/dt = 1.5y - y³ + 0.3sin(t)', desc: 'Moderate barrier, strong noise' }
                            ],
                            hasAnalytical: false
                        }
                    ]
                }
            };

            static generate(level) {
                // All categories available from the start, but complexity increases with level
                const categories = Object.keys(this.EQUATION_CATEGORIES);
                const categoryIndex = Math.floor(Math.random() * categories.length);
                const categoryName = categories[categoryIndex];
                const category = this.EQUATION_CATEGORIES[categoryName];
                
                // Select random equation from category
                const equationIndex = Math.floor(Math.random() * category.equations.length);
                const equation = category.equations[equationIndex];
                
                // Select random variant, with higher levels allowing more extreme parameters
                let variantIndex = Math.floor(Math.random() * equation.variants.length);
                
                // For higher levels, bias towards more complex variants
                if (level > 5 && Math.random() < 0.3) {
                    variantIndex = Math.floor(Math.random() * equation.variants.length);
                }
                
                const baseVariant = equation.variants[variantIndex];
                
                // Create level-modified variant with parameter scaling
                const variant = { ...baseVariant };
                
                // Scale parameters based on level for increased complexity
                if (level > 3) {
                    const scaleFactor = 1 + (level - 3) * 0.15;
                    Object.keys(variant).forEach(key => {
                        if (typeof variant[key] === 'number' && key !== 'display') {
                            // Randomly increase or decrease parameters for variety
                            const direction = Math.random() < 0.5 ? 1 : -1;
                            const variation = (Math.random() * 0.4 + 0.8) * scaleFactor;
                            variant[key] = variant[key] * variation;
                            
                            // Update display string if parameters changed significantly
                            if (Math.abs(variation - 1) > 0.3) {
                                variant.display = this.updateDisplayString(variant.display, baseVariant, variant);
                            }
                        }
                    });
                }
                
                // Generate time domain with level-based complexity
                const t0 = Math.random() * 0.5; // Allow more varied starting times
                let tEnd = t0 + 0.6 + level * 0.08 + Math.random() * 0.4;
                
                // For higher levels, sometimes use longer or more complex time domains
                if (level > 5) {
                    tEnd = t0 + (0.8 + level * 0.1) * (0.8 + Math.random() * 0.4);
                }
                
                // Adjust for oscillatory systems with level complexity
                if (variant.display.includes('sin') || variant.display.includes('cos')) {
                    const periods = Math.max(1, level * 0.3);
                    tEnd = t0 + Math.PI * periods * (1 + Math.random() * 0.5);
                }
                
                // Generate initial value with level-based variation
                let y0 = 0.3 + Math.random() * 1.4;
                
                // Higher levels can have more extreme initial conditions
                if (level > 8) {
                    const extremeFactor = 1 + (level - 8) * 0.2;
                    y0 *= (Math.random() < 0.3) ? extremeFactor : (1 / extremeFactor);
                }
                
                // For very high levels, occasionally use negative or very small initial values
                if (level > 12 && Math.random() < 0.2) {
                    y0 = (Math.random() < 0.5) ? -Math.abs(y0) : Math.abs(y0) * 0.1;
                }
                
                // Calculate complexity-based precision and rewards
                const parameterComplexity = this.calculateParameterComplexity(variant, level);
                const combinedDifficulty = category.difficulty + parameterComplexity + (level - 1) * 0.15;
                const basePrecision = 0.1;
                const targetAccuracy = basePrecision / Math.pow(2.5, combinedDifficulty - 1);
                
                // Dynamic rewards based on actual complexity, not just level
                let baseReward = 25 + category.difficulty * 15;
                baseReward *= (1 + parameterComplexity * 0.5);
                baseReward *= Math.pow(1.4, level - 1);
                baseReward += Math.floor(Math.random() * (10 + level * 5));
                baseReward = Math.floor(baseReward);

                // Create the mission object
                const mission = {
                    name: equation.name,
                    category: categoryName,
                    difficulty: category.difficulty,
                    equation: this.createEquationFunction(equation, variant),
                    display: variant.display,
                    description: variant.desc,
                    timeSpan: [t0, tEnd],
                    initialValue: y0,
                    targetAccuracy: targetAccuracy,
                    baseReward: baseReward,
                    hasAnalytical: equation.hasAnalytical,
                    variant: variant
                };

                // Set up reference solution
                if (equation.hasAnalytical && equation.solution) {
                    mission.getReference = (t) => {
                        const params = Object.values(variant).filter(v => typeof v === 'number');
                        return equation.solution(t, y0, t0, ...params);
                    };
                } else {
                    // Use high-precision reference
                    const refSolution = NumericalSolver.rk4(mission, 0.00001);
                    mission.referenceT = refSolution.t;
                    mission.referenceY = refSolution.y;
                    mission.getReference = (t) => {
                        for (let i = 0; i < mission.referenceT.length - 1; i++) {
                            if (t >= mission.referenceT[i] && t <= mission.referenceT[i + 1]) {
                                const alpha = (t - mission.referenceT[i]) / (mission.referenceT[i + 1] - mission.referenceT[i]);
                                return mission.referenceY[i] * (1 - alpha) + mission.referenceY[i + 1] * alpha;
                            }
                        }
                        return mission.referenceY[mission.referenceY.length - 1];
                    };
                }

                return mission;
            }

            static updateDisplayString(originalDisplay, baseVariant, newVariant) {
                // Simple display string update for modified parameters
                let display = originalDisplay;
                
                // Update common numerical coefficients in display strings
                Object.keys(baseVariant).forEach(key => {
                    if (typeof baseVariant[key] === 'number' && typeof newVariant[key] === 'number') {
                        const oldVal = baseVariant[key];
                        const newVal = newVariant[key];
                        
                        if (Math.abs(newVal - oldVal) > 0.01) {
                            const newValStr = newVal.toFixed(1);
                            // Replace old coefficient with new one in display
                            if (display.includes(oldVal.toString())) {
                                display = display.replace(oldVal.toString(), newValStr);
                            } else if (oldVal === 1 && !display.includes('1')) {
                                // Handle implicit coefficient of 1
                                display = display.replace(/([+-]?\s*)([a-z])/g, `$1${newValStr}$2`);
                            }
                        }
                    }
                });
                
                return display;
            }

            static calculateParameterComplexity(variant, level) {
                let complexity = 0;
                
                // Count extreme parameter values
                Object.values(variant).forEach(value => {
                    if (typeof value === 'number') {
                        if (Math.abs(value) > 3) complexity += 0.5;
                        if (Math.abs(value) < 0.1) complexity += 0.3;
                        if (Math.abs(value) > 5) complexity += 0.5;
                    }
                });
                
                // Add complexity for higher levels with multiple effects
                if (level > 10) {
                    complexity += (level - 10) * 0.1;
                }
                
                return Math.min(complexity, 2); // Cap complexity bonus
            }

            static createEquationFunction(equation, variant) {
                // Create a function that incorporates the variant parameters (with dynamic scaling)
                return (t, y) => {
                    // Use actual variant values (which may be scaled from base values)
                    const coeff = variant.coeff || 1;
                    const freq = variant.freq || 1;
                    const amp = variant.amp || 1;
                    const damping = variant.damping || 1;
                    const force = variant.force || 1;
                    const rate = variant.rate || 1;
                    const capacity = variant.capacity || 1;
                    const input = variant.input || 0;
                    const efficiency = variant.efficiency || 1;
                    const growth = variant.growth || 1;
                    const volatility = variant.volatility || 1;
                    const interest = variant.interest || 1;
                    const reinvest = variant.reinvest || 1;
                    const friction = variant.friction || 1;
                    const p = variant.p || 1;
                    const i = variant.i || 1;
                    const d = variant.d || 1;
                    const target = variant.target || 1;
                    const chaos = variant.chaos || 1;
                    const drive = variant.drive || 1;
                    const barrier = variant.barrier || 1;
                    
                    if (equation.name === 'Exponential Growth') {
                        return coeff * y;
                    } else if (equation.name === 'Exponential Decay') {
                        return -coeff * y;
                    } else if (equation.name === 'Harmonic Motion') {
                        return amp * Math.sin(freq * t);
                    } else if (equation.name === 'Damped Motion') {
                        return -damping * y + force * Math.cos(t);
                    } else if (equation.name === 'Thermal Dynamics') {
                        return -coeff * t * y;
                    } else if (equation.name === 'Logistic Growth') {
                        return rate * y * (capacity - y);
                    } else if (equation.name === 'Predator-Prey Base') {
                        const prey = variant.prey || 2;
                        const pred = variant.pred || 1;
                        return y * (prey - pred * Math.sin(t) - y);
                    } else if (equation.name === 'Epidemic Spread') {
                        const infection = variant.infection || 1;
                        const recovery = variant.recovery || 1;
                        return infection * y * Math.exp(-recovery * t) * (10 - y);
                    } else if (equation.name === 'First Order Reaction') {
                        return -rate * y + input;
                    } else if (equation.name === 'Autocatalytic Process') {
                        return efficiency * y * y * (capacity - y);
                    } else if (equation.name === 'Market Dynamics') {
                        return growth * y * (5 - y) - volatility * Math.sin(2*t);
                    } else if (equation.name === 'Investment Growth') {
                        return interest * y + reinvest * t * y - friction * y * y;
                    } else if (equation.name === 'PID Controller') {
                        return -p * y - i * Math.sin(t) + d * Math.cos(2*t);
                    } else if (equation.name === 'Servo Tracking') {
                        return target * Math.sin(t) - damping * y - friction * y * Math.abs(y);
                    } else if (equation.name === 'Strange Attractor') {
                        return chaos * Math.sin(y) + drive * Math.cos(3*t) - damping * y;
                    } else if (equation.name === 'Bistable System') {
                        return barrier * y - y*y*y + drive * Math.sin(t);
                    } else {
                        // Fallback to base equation
                        return equation.baseEquation(t, y);
                    }
                };
            }
        }

        // ============ NUMERICAL SOLVER ============
        class NumericalSolver {
            static async solveAnimated(method, mission, stepSize, progressCallback) {
                const maxSteps = 50000;
                const minStepSize = 1e-8;
                
                if (stepSize < minStepSize) {
                    throw new Error(`Step size too small (min: ${minStepSize})`);
                }
                
                const expectedSteps = Math.ceil((mission.timeSpan[1] - mission.timeSpan[0]) / stepSize);
                if (expectedSteps > maxSteps) {
                    throw new Error(`Too many steps required: ${expectedSteps} (max: ${maxSteps})`);
                }

                const startTime = performance.now();
                let result;

                switch (method) {
                    case 'euler':
                        result = await this.eulerAnimated(mission, stepSize, progressCallback);
                        break;
                    case 'midpoint':
                        result = await this.midpointAnimated(mission, stepSize, progressCallback);
                        break;
                    case 'heun':
                        result = await this.heunAnimated(mission, stepSize, progressCallback);
                        break;
                    case 'rk4':
                        result = await this.rk4Animated(mission, stepSize, progressCallback);
                        break;
                    case 'adaptive':
                        result = await this.adaptiveAnimated(mission, stepSize, progressCallback);
                        break;
                    default:
                        throw new Error('Unknown method');
                }

                result.computationTime = (performance.now() - startTime) / 1000;
                return result;
            }

            static async eulerAnimated(mission, h, progressCallback) {
                const [t0, tEnd] = mission.timeSpan;
                const f = mission.equation;
                const y0 = mission.initialValue;
                
                const t = [t0];
                const y = [y0];
                
                let currentT = t0;
                let currentY = y0;
                let step = 0;
                const totalSteps = Math.ceil((tEnd - t0) / h);
                
                while (currentT < tEnd) {
                    const actualH = Math.min(h, tEnd - currentT);
                    currentY = currentY + actualH * f(currentT, currentY);
                    currentT += actualH;
                    
                    t.push(currentT);
                    y.push(currentY);
                    
                    step++;
                    if (step % Math.max(1, Math.floor(totalSteps / 100)) === 0) {
                        progressCallback(step, totalSteps);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                return { t, y };
            }

            static async midpointAnimated(mission, h, progressCallback) {
                const [t0, tEnd] = mission.timeSpan;
                const f = mission.equation;
                const y0 = mission.initialValue;
                
                const t = [t0];
                const y = [y0];
                
                let currentT = t0;
                let currentY = y0;
                let step = 0;
                const totalSteps = Math.ceil((tEnd - t0) / h);
                
                while (currentT < tEnd) {
                    const actualH = Math.min(h, tEnd - currentT);
                    const k1 = f(currentT, currentY);
                    const k2 = f(currentT + actualH/2, currentY + actualH * k1 / 2);
                    
                    currentY = currentY + actualH * k2;
                    currentT += actualH;
                    
                    t.push(currentT);
                    y.push(currentY);
                    
                    step++;
                    if (step % Math.max(1, Math.floor(totalSteps / 100)) === 0) {
                        progressCallback(step, totalSteps);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }
                
                return { t, y };
            }

            static async heunAnimated(mission, h, progressCallback) {
                const [t0, tEnd] = mission.timeSpan;
                const f = mission.equation;
                const y0 = mission.initialValue;
                
                const t = [t0];
                const y = [y0];
                
                let currentT = t0;
                let currentY = y0;
                let step = 0;
                const totalSteps = Math.ceil((tEnd - t0) / h);
                
                while (currentT < tEnd) {
                    const actualH = Math.min(h, tEnd - currentT);
                    const k1 = f(currentT, currentY);
                    const k2 = f(currentT + actualH, currentY + actualH * k1);
                    
                    currentY = currentY + (actualH / 2) * (k1 + k2);
                    currentT += actualH;
                    
                    t.push(currentT);
                    y.push(currentY);
                    
                    step++;
                    if (step % Math.max(1, Math.floor(totalSteps / 100)) === 0) {
                        progressCallback(step, totalSteps);
                        await new Promise(resolve => setTimeout(resolve, 2));
                    }
                }
                
                return { t, y };
            }

            static async rk4Animated(mission, h, progressCallback) {
                const [t0, tEnd] = mission.timeSpan;
                const f = mission.equation;
                const y0 = mission.initialValue;
                
                const t = [t0];
                const y = [y0];
                
                let currentT = t0;
                let currentY = y0;
                let step = 0;
                const totalSteps = Math.ceil((tEnd - t0) / h);
                
                while (currentT < tEnd) {
                    const actualH = Math.min(h, tEnd - currentT);
                    const k1 = f(currentT, currentY);
                    const k2 = f(currentT + actualH/2, currentY + actualH * k1 / 2);
                    const k3 = f(currentT + actualH/2, currentY + actualH * k2 / 2);
                    const k4 = f(currentT + actualH, currentY + actualH * k3);
                    
                    currentY = currentY + (actualH / 6) * (k1 + 2*k2 + 2*k3 + k4);
                    currentT += actualH;
                    
                    t.push(currentT);
                    y.push(currentY);
                    
                    step++;
                    if (step % Math.max(1, Math.floor(totalSteps / 100)) === 0) {
                        progressCallback(step, totalSteps);
                        await new Promise(resolve => setTimeout(resolve, 3));
                    }
                }
                
                return { t, y };
            }

            static async adaptiveAnimated(mission, h, progressCallback) {
                // Adaptive uses smaller internal steps but costs as if using h
                const result = await this.rk4Animated(mission, h/2, progressCallback);
                result.computationTime *= 2.5;
                return result;
            }

            static rk4(mission, h) {
                const [t0, tEnd] = mission.timeSpan;
                const f = mission.equation;
                const y0 = mission.initialValue;
                
                const t = [t0];
                const y = [y0];
                
                let currentT = t0;
                let currentY = y0;
                
                while (currentT < tEnd) {
                    const actualH = Math.min(h, tEnd - currentT);
                    const k1 = f(currentT, currentY);
                    const k2 = f(currentT + actualH/2, currentY + actualH * k1 / 2);
                    const k3 = f(currentT + actualH/2, currentY + actualH * k2 / 2);
                    const k4 = f(currentT + actualH, currentY + actualH * k3);
                    
                    currentY = currentY + (actualH / 6) * (k1 + 2*k2 + 2*k3 + k4);
                    currentT += actualH;
                    
                    t.push(currentT);
                    y.push(currentY);
                }
                
                return { t, y };
            }
        }

        // ============ CHART RENDERER ============
        class ChartRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.referenceData = [];
                this.numericalData = [];
                this.isDrawing = false;
                this.setupCanvas();
                this.setupMouseEvents();
                this.clear();
            }

            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                this.ctx.scale(dpr, dpr);
                this.margin = { top: 20, right: 20, bottom: 40, left: 60 };
            }

            setupMouseEvents() {
                // Create tooltip element
                this.tooltip = document.createElement('div');
                this.tooltip.style.cssText = `
                    position: absolute;
                    background: rgba(0, 0, 0, 0.9);
                    color: white;
                    padding: 8px 12px;
                    border-radius: 4px;
                    font-size: 10px;
                    font-family: 'Press Start 2P';
                    pointer-events: none;
                    z-index: 1000;
                    display: none;
                    line-height: 1.4;
                `;
                document.body.appendChild(this.tooltip);

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDrawing || this.referenceData.length === 0) {
                        this.tooltip.style.display = 'none';
                        return;
                    }

                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const dataX = this.fromCanvasX(x);
                    const closestPoint = this.findClosestPoint(dataX);
                    
                    if (closestPoint) {
                        const error = Math.abs(closestPoint.ref.y - closestPoint.num.y);
                        
                        this.tooltip.innerHTML = `
                            t: ${closestPoint.ref.x.toFixed(4)}<br>
                            Reference: ${closestPoint.ref.y.toFixed(6)}<br>
                            Numerical: ${closestPoint.num.y.toFixed(6)}<br>
                            Error: ${error.toExponential(3)}
                        `;
                        
                        this.tooltip.style.left = (e.clientX + 10) + 'px';
                        this.tooltip.style.top = (e.clientY - 10) + 'px';
                        this.tooltip.style.display = 'block';
                        
                        // Highlight the point
                        this.redrawWithHighlight(closestPoint);
                    } else {
                        this.tooltip.style.display = 'none';
                    }
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.tooltip.style.display = 'none';
                    if (!this.isDrawing && this.referenceData.length > 0) {
                        this.redrawWithoutHighlight();
                    }
                });
            }

            findClosestPoint(targetX) {
                if (this.referenceData.length === 0 || this.numericalData.length === 0) return null;
                
                let minDistance = Infinity;
                let closestIndex = -1;
                
                const minLength = Math.min(this.referenceData.length, this.numericalData.length);
                
                for (let i = 0; i < minLength; i++) {
                    const distance = Math.abs(this.referenceData[i].x - targetX);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                if (closestIndex >= 0) {
                    return {
                        ref: this.referenceData[closestIndex],
                        num: this.numericalData[closestIndex],
                        index: closestIndex
                    };
                }
                
                return null;
            }

            fromCanvasX(canvasX) {
                const canvasWidth = this.width / window.devicePixelRatio;
                return this.xMin + (canvasX - this.margin.left) / (canvasWidth - this.margin.left - this.margin.right) * (this.xMax - this.xMin);
            }

            redrawWithHighlight(closestPoint) {
                this.clear();
                this.drawLine(this.referenceData, '#ff6b6b', 3);
                this.drawLine(this.numericalData, '#4fc3f7', 2);
                this.drawErrorPoints(this.referenceData, this.numericalData, gameController.gameState.currentMission.targetAccuracy);
                
                // Highlight the closest point
                const ctx = this.ctx;
                
                // Highlight reference point
                ctx.fillStyle = '#ff6b6b';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.toCanvasX(closestPoint.ref.x), this.toCanvasY(closestPoint.ref.y), 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Highlight numerical point
                ctx.fillStyle = '#4fc3f7';
                ctx.beginPath();
                ctx.arc(this.toCanvasX(closestPoint.num.x), this.toCanvasY(closestPoint.num.y), 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                
                // Draw connection line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(this.toCanvasX(closestPoint.ref.x), this.toCanvasY(closestPoint.ref.y));
                ctx.lineTo(this.toCanvasX(closestPoint.num.x), this.toCanvasY(closestPoint.num.y));
                ctx.stroke();
                ctx.setLineDash([]);
            }

            redrawWithoutHighlight() {
                this.clear();
                this.drawLine(this.referenceData, '#ff6b6b', 3);
                this.drawLine(this.numericalData, '#4fc3f7', 2);
                this.drawErrorPoints(this.referenceData, this.numericalData, gameController.gameState.currentMission.targetAccuracy);
            }

            clear() {
                const canvasWidth = this.width / window.devicePixelRatio;
                const canvasHeight = this.height / window.devicePixelRatio;
                
                this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                this.drawAxes();
                this.drawGrid();
            }

            drawAxes() {
                const ctx = this.ctx;
                const canvasWidth = this.width / window.devicePixelRatio;
                const canvasHeight = this.height / window.devicePixelRatio;
                
                ctx.strokeStyle = '#81c784';
                ctx.lineWidth = 1;
                ctx.font = '8px "Press Start 2P"';
                ctx.fillStyle = '#81c784';
                
                // X axis
                ctx.beginPath();
                ctx.moveTo(this.margin.left, canvasHeight - this.margin.bottom);
                ctx.lineTo(canvasWidth - this.margin.right, canvasHeight - this.margin.bottom);
                ctx.stroke();
                
                // Y axis
                ctx.beginPath();
                ctx.moveTo(this.margin.left, this.margin.top);
                ctx.lineTo(this.margin.left, canvasHeight - this.margin.bottom);
                ctx.stroke();
                
                // Labels
                ctx.textAlign = 'center';
                ctx.fillText('Time (t)', canvasWidth / 2, canvasHeight - 10);
                
                ctx.save();
                ctx.translate(15, canvasHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('y(t)', 0, 0);
                ctx.restore();
            }

            drawGrid() {
                const ctx = this.ctx;
                const canvasWidth = this.width / window.devicePixelRatio;
                const canvasHeight = this.height / window.devicePixelRatio;
                
                ctx.strokeStyle = 'rgba(129, 199, 132, 0.1)';
                ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    const x = this.margin.left + i * (canvasWidth - this.margin.left - this.margin.right) / 10;
                    ctx.beginPath();
                    ctx.moveTo(x, this.margin.top);
                    ctx.lineTo(x, canvasHeight - this.margin.bottom);
                    ctx.stroke();
                }
                
                for (let i = 0; i <= 10; i++) {
                    const y = this.margin.top + i * (canvasHeight - this.margin.top - this.margin.bottom) / 10;
                    ctx.beginPath();
                    ctx.moveTo(this.margin.left, y);
                    ctx.lineTo(canvasWidth - this.margin.right, y);
                    ctx.stroke();
                }
            }

            async animatedDraw(referenceData, numericalData, method, targetError) {
                this.referenceData = referenceData;
                this.numericalData = numericalData;
                this.setData(referenceData, numericalData);
                this.isDrawing = true;
                
                document.getElementById('drawingIndicator').style.display = 'block';
                document.getElementById('chartStatus').textContent = `Drawing ${method.toUpperCase()} vs Reference...`;
                
                const totalPoints = Math.max(referenceData.length, numericalData.length);
                const animationSteps = Math.min(100, totalPoints);
                
                for (let step = 1; step <= animationSteps; step++) {
                    const progress = step / animationSteps;
                    const refPoints = Math.floor(referenceData.length * progress);
                    const numPoints = Math.floor(numericalData.length * progress);
                    
                    this.clear();
                    
                    if (refPoints > 1) {
                        this.drawLine(referenceData.slice(0, refPoints), '#ff6b6b', 3);
                    }
                    
                    if (numPoints > 1) {
                        this.drawLine(numericalData.slice(0, numPoints), '#4fc3f7', 2);
                        this.drawErrorPoints(referenceData.slice(0, refPoints), numericalData.slice(0, numPoints), targetError);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 20));
                }
                
                this.clear();
                this.drawLine(referenceData, '#ff6b6b', 3);
                this.drawLine(numericalData, '#4fc3f7', 2);
                this.drawErrorPoints(referenceData, numericalData, targetError);
                
                this.isDrawing = false;
                document.getElementById('drawingIndicator').style.display = 'none';
                const errorCount = this.countErrorPoints(referenceData, numericalData, targetError);
                document.getElementById('chartStatus').textContent = 
                    `Analysis complete: ${method.toUpperCase()} vs Reference (${errorCount} error points marked)`;
            }

            setData(referenceData, numericalData) {
                const allData = [...referenceData, ...numericalData];
                
                this.xMin = Math.min(...allData.map(p => p.x));
                this.xMax = Math.max(...allData.map(p => p.x));
                this.yMin = Math.min(...allData.map(p => p.y));
                this.yMax = Math.max(...allData.map(p => p.y));
                
                const xPadding = (this.xMax - this.xMin) * 0.05;
                const yPadding = (this.yMax - this.yMin) * 0.1;
                
                this.xMin -= xPadding;
                this.xMax += xPadding;
                this.yMin -= yPadding;
                this.yMax += yPadding;
            }

            toCanvasX(x) {
                const canvasWidth = this.width / window.devicePixelRatio;
                return this.margin.left + (x - this.xMin) / (this.xMax - this.xMin) * 
                       (canvasWidth - this.margin.left - this.margin.right);
            }

            toCanvasY(y) {
                const canvasHeight = this.height / window.devicePixelRatio;
                return canvasHeight - this.margin.bottom - 
                       (y - this.yMin) / (this.yMax - this.yMin) * 
                       (canvasHeight - this.margin.top - this.margin.bottom);
            }

            drawLine(data, color, lineWidth) {
                if (data.length < 2) return;
                
                const ctx = this.ctx;
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                
                ctx.moveTo(this.toCanvasX(data[0].x), this.toCanvasY(data[0].y));
                for (let i = 1; i < data.length; i++) {
                    ctx.lineTo(this.toCanvasX(data[i].x), this.toCanvasY(data[i].y));
                }
                ctx.stroke();
            }

            drawErrorPoints(referenceData, numericalData, targetError) {
                const ctx = this.ctx;
                const minLength = Math.min(referenceData.length, numericalData.length);
                
                for (let i = 0; i < minLength; i++) {
                    const refPoint = referenceData[i];
                    const numPoint = numericalData[i];
                    const error = Math.abs(refPoint.y - numPoint.y);
                    
                    if (error > targetError) {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.beginPath();
                        ctx.arc(this.toCanvasX(numPoint.x), this.toCanvasY(numPoint.y), 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        ctx.strokeStyle = 'rgba(255, 107, 107, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(this.toCanvasX(refPoint.x), this.toCanvasY(refPoint.y));
                        ctx.lineTo(this.toCanvasX(numPoint.x), this.toCanvasY(numPoint.y));
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }

            countErrorPoints(referenceData, numericalData, targetError) {
                let count = 0;
                const minLength = Math.min(referenceData.length, numericalData.length);
                
                for (let i = 0; i < minLength; i++) {
                    const error = Math.abs(referenceData[i].y - numericalData[i].y);
                    if (error > targetError) count++;
                }
                
                return count;
            }

            clearChart() {
                this.referenceData = [];
                this.numericalData = [];
                this.clear();
                this.tooltip.style.display = 'none';
                document.getElementById('chartStatus').textContent = 'Execute a mission to see trajectory comparison';
                document.getElementById('drawingIndicator').style.display = 'none';
            }
        }

        // ============ MAIN GAME CONTROLLER ============
        class GameController {
            constructor() {
                this.gameState = new GameState();
                this.chartRenderer = null;
                this.isComputing = false;
                
                this.init();
            }

            init() {
                this.createStarField();
                this.setupEventListeners();
                this.initChart();
                this.generateNewMission();
                this.updateDisplay();
            }

            createStarField() {
                const starsContainer = document.getElementById('stars');
                for (let i = 0; i < 80; i++) {
                    const star = document.createElement('div');
                    star.className = 'star';
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 100 + '%';
                    star.style.width = star.style.height = Math.random() * 3 + 1 + 'px';
                    star.style.animationDelay = Math.random() * 2 + 's';
                    starsContainer.appendChild(star);
                }
            }

            setupEventListeners() {
                const methodSelect = document.getElementById('solutionMethod');
                const stepSizeInput = document.getElementById('stepSize');
                
                methodSelect.addEventListener('change', () => {
                    this.updateMethodInfo();
                    this.updateCostEstimate();
                });
                
                stepSizeInput.addEventListener('input', () => {
                    this.updateCostEstimate();
                });
                
                this.updateMethodInfo();
                this.updateCostEstimate();
            }

            updateMethodInfo() {
                const method = document.getElementById('solutionMethod').value;
                const descriptions = {
                    'euler': 'Simple forward Euler integration. Fast but low accuracy. Base cost: $15. <a href="https://en.wikipedia.org/wiki/Euler_method" target="_blank" class="wiki-link">📖 Learn more</a>',
                    'midpoint': 'Second-order accurate method using midpoint evaluation. Good balance. Base cost: $40. <a href="https://en.wikipedia.org/wiki/Midpoint_method" target="_blank" class="wiki-link">📖 Learn more</a>',
                    'heun': 'Improved Euler method with predictor-corrector approach. Base cost: $70. <a href="https://en.wikipedia.org/wiki/Heun%27s_method" target="_blank" class="wiki-link">📖 Learn more</a>',
                    'rk4': 'Fourth-order Runge-Kutta. Industry standard for high accuracy. Base cost: $120. <a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods" target="_blank" class="wiki-link">📖 Learn more</a>',
                    'adaptive': 'Intelligent step size control. Expensive but extremely precise. Base cost: $200. <a href="https://en.wikipedia.org/wiki/Adaptive_stepsize" target="_blank" class="wiki-link">📖 Learn more</a>'
                };
                
                document.getElementById('methodDescription').innerHTML = descriptions[method];
            }

            updateCostEstimate() {
                if (!this.gameState.currentMission) return;
                
                const method = document.getElementById('solutionMethod').value;
                const stepSize = parseFloat(document.getElementById('stepSize').value) || 0.01;
                
                const cost = CostCalculator.calculate(method, stepSize, this.gameState.currentMission.timeSpan);
                document.getElementById('costEstimate').textContent = cost;
            }

            initChart() {
                const canvas = document.getElementById('trajectoryCanvas');
                if (canvas) {
                    this.chartRenderer = new ChartRenderer(canvas);
                    
                    window.addEventListener('resize', () => {
                        if (this.chartRenderer) {
                            this.chartRenderer.setupCanvas();
                            this.chartRenderer.clear();
                        }
                    });
                }
            }

            generateNewMission() {
                if (this.gameState.level > 25) {
                    this.endGame(true);
                    return;
                }

                this.gameState.currentMission = ProblemGenerator.generate(this.gameState.level);
                this.displayMission(this.gameState.currentMission);
                this.updateDisplay();
                this.updateCostEstimate();
            }

            displayMission(mission) {
                document.getElementById('equationCategory').textContent = mission.category;
                document.getElementById('equationDisplay').textContent = mission.display;
                document.getElementById('equationDescription').textContent = mission.description;
                document.getElementById('initialCondition').textContent = 
                    `y(${mission.timeSpan[0].toFixed(2)}) = ${mission.initialValue.toFixed(2)}`;
                document.getElementById('timeDomain').textContent = 
                    `[${mission.timeSpan[0].toFixed(2)}, ${mission.timeSpan[1].toFixed(2)}]`;
                document.getElementById('targetError').textContent = 
                    `< ${mission.targetAccuracy.toFixed(5)}`;
                document.getElementById('missionReward').textContent = 
                    `$${mission.baseReward}`;

                // Update difficulty display
                const difficultyStars = document.querySelectorAll('.difficulty-star');
                const difficulty = mission.difficulty;
                difficultyStars.forEach((star, index) => {
                    if (index < difficulty) {
                        star.textContent = '★';
                        star.classList.remove('empty');
                    } else {
                        star.textContent = '☆';
                        star.classList.add('empty');
                    }
                });
            }

            async executeMission() {
                if (this.isComputing) return;
                
                const method = document.getElementById('solutionMethod').value;
                const stepSize = parseFloat(document.getElementById('stepSize').value);
                
                if (stepSize <= 0) {
                    this.showFloatingText('Invalid step size!', 'failure');
                    return;
                }

                const cost = CostCalculator.calculate(method, stepSize, this.gameState.currentMission.timeSpan);

                if (cost > this.gameState.money) {
                    this.showFloatingText('Insufficient credits!', 'failure');
                    return;
                }

                this.isComputing = true;
                this.startComputingAnimation();
                if (this.chartRenderer) {
                    this.chartRenderer.clearChart();
                }

                try {
                    const result = await NumericalSolver.solveAnimated(
                        method, 
                        this.gameState.currentMission, 
                        stepSize, 
                        (step, total) => this.updateComputingProgress(step, total)
                    );
                    
                    // Generate points for chart
                    const referencePoints = [];
                    const numericalPoints = [];
                    
                    for (let i = 0; i < result.t.length; i++) {
                        const t = result.t[i];
                        const y = result.y[i];
                        const refY = this.gameState.currentMission.getReference(t);
                        
                        referencePoints.push({ x: t, y: refY });
                        numericalPoints.push({ x: t, y: y });
                    }
                    
                    // Animate the chart drawing
                    if (this.chartRenderer) {
                        await this.chartRenderer.animatedDraw(referencePoints, numericalPoints, method, this.gameState.currentMission.targetAccuracy);
                    }
                    
                    this.processMissionResult(result, cost, method);
                } catch (error) {
                    this.showFloatingText(`Error: ${error.message}`, 'failure');
                } finally {
                    this.isComputing = false;
                    this.endComputingAnimation();
                }
            }

            processMissionResult(result, cost, method) {
                // Deduct cost first
                this.gameState.deductMoney(cost);
                
                const error = this.calculateError(result.y, result.t);
                const success = error <= this.gameState.currentMission.targetAccuracy;
                const accuracy = Math.max(0, 1 - error / this.gameState.currentMission.targetAccuracy);
                
                this.gameState.updateAccuracy(accuracy);
                
                let reward = 0;

                if (success) {
                    reward = this.gameState.currentMission.baseReward;
                    this.gameState.addMoney(reward);
                    this.gameState.addScore(reward);
                    this.gameState.completeMission();
                    
                    this.showFloatingText(`+$${reward}`, 'success');
                    
                    if (this.gameState.shouldLevelUp()) {
                        this.levelUp();
                    }
                } else {
                    this.gameState.loseLife();
                    this.gameState.failMission();
                    this.showFloatingText('Mission Failed!', 'failure');
                    
                    if (this.gameState.isGameOver()) {
                        this.endGame(false);
                        return;
                    }
                }

                this.displayResults(cost, error, success, reward, accuracy);
                this.updateDisplay();
                
                document.getElementById('nextMissionBtn').style.display = 'block';
                document.getElementById('executeBtn').disabled = true;
            }

            calculateError(numericalSolution, timePoints) {
                let maxError = 0;
                
                for (let i = 0; i < timePoints.length; i++) {
                    const reference = this.gameState.currentMission.getReference(timePoints[i]);
                    const error = Math.abs(numericalSolution[i] - reference);
                    maxError = Math.max(maxError, error);
                }
                
                return maxError;
            }

            displayResults(cost, error, success, reward, accuracy) {
                const panel = document.getElementById('resultsPanel');
                const content = document.getElementById('resultsContent');
                
                let html = `
                    <div class="result-row">
                        <span>💰 Mission Cost:</span>
                        <span class="failure">-$${cost}</span>
                    </div>
                    <div class="result-row">
                        <span>📊 Max Error:</span>
                        <span>${error < 0.0001 ? error.toExponential(2) : error.toFixed(6)}</span>
                    </div>
                    <div class="result-row">
                        <span>🎯 Accuracy:</span>
                        <span>${(accuracy * 100).toFixed(2)}%</span>
                    </div>
                `;

                if (success) {
                    html += `
                        <div class="result-row">
                            <span>🏆 Mission Reward:</span>
                            <span class="success">+$${reward}</span>
                        </div>
                    `;
                    
                    const netGain = reward - cost;
                    const isProfit = netGain >= 0;
                    const netClass = isProfit ? 'success' : 'failure';
                    const borderColor = isProfit ? '#4caf50' : '#f44336';
                    
                    html += `
                        <div class="result-row" style="border-top: 2px solid ${borderColor}; margin-top: 8px; padding-top: 8px; font-weight: bold;">
                            <span>🎉 MISSION SUCCESS!</span>
                            <span class="${netClass}">Net: $${netGain}</span>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="result-row" style="border-top: 2px solid #f44336; margin-top: 8px; padding-top: 8px; font-weight: bold;">
                            <span>💀 MISSION FAILED</span>
                            <span class="failure">Loss: -$${cost}</span>
                        </div>
                    `;
                }

                content.innerHTML = html;
                panel.style.display = 'block';
                
                // Reset collapse state
                content.classList.remove('collapsed');
                document.getElementById('collapseIcon').classList.remove('collapsed');
                document.getElementById('collapseIcon').textContent = '▼';
                this.gameState.resultsCollapsed = false;
            }

            levelUp() {
                this.gameState.levelUp();
                this.showFloatingText(`LEVEL UP! ${this.gameState.level}`, 'success');
            }

            nextMission() {
                this.generateNewMission();
                document.getElementById('resultsPanel').style.display = 'none';
                document.getElementById('nextMissionBtn').style.display = 'none';
                document.getElementById('executeBtn').disabled = false;
                if (this.chartRenderer) {
                    this.chartRenderer.clearChart();
                }
                this.gameState.resultsCollapsed = false;
            }

            updateDisplay() {
                document.getElementById('playerMoney').textContent = `$${this.gameState.money}`;
                document.getElementById('currentLevel').textContent = this.gameState.level;
                document.getElementById('playerScore').textContent = this.gameState.score;
                document.getElementById('accuracyRate').textContent = `${(this.gameState.accuracy * 100).toFixed(1)}%`;
                
                const moneyPercentage = (this.gameState.money / this.gameState.maxMoney) * 100;
                document.getElementById('moneyBar').style.width = `${Math.max(0, moneyPercentage)}%`;
                
                const levelProgress = (this.gameState.missionCount % 3) / 3 * 100;
                document.getElementById('levelProgress').style.width = `${levelProgress}%`;
                
                const hearts = document.querySelectorAll('.life-heart');
                hearts.forEach((heart, index) => {
                    heart.className = index < this.gameState.lives ? 'life-heart' : 'life-heart empty';
                });
            }

            startComputingAnimation() {
                document.getElementById('computingAnimation').style.display = 'block';
                document.getElementById('executeBtn').classList.add('computing');
                document.getElementById('executeBtn').textContent = '🔄 COMPUTING...';
                document.getElementById('executeBtn').disabled = true;
                
                document.getElementById('chartStatus').innerHTML = 
                    '<span class="drawing-indicator">🔄 Drawing trajectory...</span>';
            }

            updateComputingProgress(step, total) {
                document.getElementById('computingStep').textContent = step;
                document.getElementById('totalSteps').textContent = total;
            }

            endComputingAnimation() {
                document.getElementById('computingAnimation').style.display = 'none';
                document.getElementById('executeBtn').classList.remove('computing');
                document.getElementById('executeBtn').textContent = '🚀 EXECUTE MISSION';
                
                document.getElementById('chartStatus').textContent = 
                    'Trajectory analysis complete';
            }

            showFloatingText(text, type) {
                const floatingText = document.createElement('div');
                floatingText.className = `floating-text ${type}`;
                floatingText.textContent = text;
                floatingText.style.left = Math.random() * 200 + 200 + 'px';
                floatingText.style.top = Math.random() * 100 + 100 + 'px';
                
                document.body.appendChild(floatingText);
                
                setTimeout(() => {
                    if (floatingText.parentNode) {
                        floatingText.parentNode.removeChild(floatingText);
                    }
                }, 2000);
            }

            endGame(victory) {
                const screen = document.getElementById('gameOverScreen');
                const stats = document.getElementById('finalStats');
                
                const title = victory ? '🏆 UNIVERSE SAVED!' : '💀 EXPEDITION FAILED';
                const message = victory ? 'You have mastered all numerical arts!' : 'The mathematical universe remains in chaos...';
                
                stats.innerHTML = `
                    <h3 style="color: ${victory ? '#4caf50' : '#f44336'}; margin-bottom: 15px; font-size: 14px;">${title}</h3>
                    <p style="margin-bottom: 15px; font-size: 8px;">${message}</p>
                    <div style="text-align: left; font-size: 8px;">
                        <div>💰 Final Credits: ${this.gameState.money}</div>
                        <div>🏆 Total Score: ${this.gameState.score}</div>
                        <div>🎯 Max Level: ${this.gameState.level}</div>
                        <div>📊 Best Accuracy: ${(this.gameState.accuracy * 100).toFixed(1)}%</div>
                        <div>🚀 Missions Completed: ${this.gameState.missionCount}</div>
                        <div>📈 Success Rate: ${this.gameState.totalMissions > 0 ? ((this.gameState.missionCount / this.gameState.totalMissions) * 100).toFixed(1) : 0}%</div>
                    </div>
                `;
                
                screen.style.display = 'flex';
            }

            restartGame() {
                this.gameState = new GameState();
                document.getElementById('gameOverScreen').style.display = 'none';
                document.getElementById('resultsPanel').style.display = 'none';
                document.getElementById('nextMissionBtn').style.display = 'none';
                document.getElementById('executeBtn').disabled = false;
                
                this.generateNewMission();
                this.updateDisplay();
                if (this.chartRenderer) {
                    this.chartRenderer.clearChart();
                }
            }
        }

        // ============ GLOBAL FUNCTIONS ============
        let gameController = null;

        function executeMission() {
            if (gameController) {
                gameController.executeMission();
            }
        }

        function nextMission() {
            if (gameController) {
                gameController.nextMission();
            }
        }

        function toggleResults() {
            if (!gameController) return;
            
            const content = document.getElementById('resultsContent');
            const icon = document.getElementById('collapseIcon');
            
            gameController.gameState.resultsCollapsed = !gameController.gameState.resultsCollapsed;
            
            if (gameController.gameState.resultsCollapsed) {
                content.classList.add('collapsed');
                icon.classList.add('collapsed');
                icon.textContent = '▶';
            } else {
                content.classList.remove('collapsed');
                icon.classList.remove('collapsed');
                icon.textContent = '▼';
            }
        }

        function restartGame() {
            if (gameController) {
                gameController.restartGame();
            }
        }

        // ============ INITIALIZATION ============
        function initializeGame() {
            try {
                gameController = new GameController();
            } catch (error) {
                console.error('Game initialization failed:', error);
            }
        }

        window.addEventListener('load', initializeGame);
    </script>
</body>
</html>
