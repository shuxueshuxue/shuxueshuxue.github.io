<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Mage - æ•°å­—é­‚æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* å…¨å±€éšè—æ»šåŠ¨æ¡ */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        html, body {
            overflow: hidden !important;
            height: 100vh !important;
            width: 100vw !important;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            overflow: hidden;
            position: relative;
        }
        
        html {
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(74, 144, 226, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(226, 74, 74, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
        }
        
        #mapContainer {
            flex: 1;
            background: rgba(26, 26, 26, 0.8);
            position: relative;
            min-width: 0;
            border: 2px solid #333;
            border-radius: 12px 0 0 12px;
        }
        
        #mapSvg {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px 0 0 10px;
        }
        
        #sidePanel {
            width: 350px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #333;
            border-left: none;
            border-radius: 0 12px 12px 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            background: linear-gradient(90deg, #4a90e2 0%, #357abd 100%);
            padding: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border-bottom: 2px solid #333;
        }
        
        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel-section {
            background: rgba(32, 32, 48, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(5px);
        }
        
        .section-title {
            color: #4a90e2;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }
        
        .status-item {
            background: rgba(0,0,0,0.3);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-value {
            color: #e2a855;
            font-weight: bold;
        }
        
        .soul-simple-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
            min-height: 60px;
            align-items: flex-start;
            align-content: flex-start;
        }
        
        .soul-simple-item {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            position: relative;
        }
        
        .soul-simple-item.empty {
            opacity: 0.3;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
        }
        
        .soul-simple-item.release {
            border-color: #e2a855;
            background: linear-gradient(135deg, #3a3025 0%, #2a2015 100%);
        }
        
        .soul-simple-item.buff {
            border-color: #55e285;
            background: linear-gradient(135deg, #253a30 0%, #152a20 100%);
        }
        
        .game-button {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            width: 100%;
            margin: 3px 0;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #5aa0f2 0%, #4080cd 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .game-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stealth-button {
            background: linear-gradient(135deg, #6a4c93 0%, #553a73 100%);
        }
        
        .stealth-button:hover {
            background: linear-gradient(135deg, #7a5ca3 0%, #654a83 100%);
        }
        
        .settings-button {
            background: linear-gradient(135deg, #666 0%, #555 100%);
        }
        
        .settings-button:hover {
            background: linear-gradient(135deg, #777 0%, #666 100%);
        }
        
        /* å¼¹çª—åŸºç¡€æ ·å¼ */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #4a90e2;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            background: linear-gradient(90deg, #4a90e2 0%, #357abd 100%);
            padding: 15px 20px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s;
        }
        
        .modal-close:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .modal-body {
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        /* é­‚é…ç½®ç•Œé¢ */
        .soul-config-container {
            width: 95vw;
            max-width: 1200px;
            height: 85vh;
        }
        
        .soul-management {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 20px;
        }
        
        .soul-zones {
            display: flex;
            gap: 20px;
            height: 180px;
        }
        
        .soul-zone {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #444;
        }
        
        .soul-zone h3 {
            color: #4a90e2;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .waiting-zone {
            border-color: #666;
        }
        
        .release-zone {
            border-color: #e2a855;
            background: rgba(226, 168, 85, 0.05);
        }
        
        .release-zone h3 {
            color: #e2a855;
        }
        
        .soul-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 120px;
            align-content: flex-start;
        }
        
        .soul-card {
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }
        
        .soul-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            border-color: #4a90e2;
        }
        
        .soul-card.dragging {
            cursor: grabbing;
            transform: rotate(5deg) scale(1.1);
            z-index: 1000;
            opacity: 0.8;
        }
        
        .soul-card.in-release {
            border-color: #e2a855;
            background: linear-gradient(135deg, #3a3025 0%, #2a2015 100%);
        }
        
        .soul-card.in-timeline {
            border-color: #55e285;
            background: linear-gradient(135deg, #253a30 0%, #152a20 100%);
        }
        
        .soul-number {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .soul-mode-indicator {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .timeline-container {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
        }
        
        .timeline-container h3 {
            color: #55e285;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .timeline-scroll {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            border: 1px solid #333;
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 rgba(0,0,0,0.3);
        }
        
        .timeline-scroll::-webkit-scrollbar {
            height: 8px;
        }
        
        .timeline-scroll::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        
        .timeline-scroll::-webkit-scrollbar-thumb {
            background: #4a90e2;
            border-radius: 4px;
        }
        
        .timeline-scroll::-webkit-scrollbar-thumb:hover {
            background: #5aa0f2;
        }
        
        .timeline-track {
            display: flex;
            align-items: center;
            height: 100%;
            min-width: 100%;
            padding: 10px;
            gap: 5px;
        }
        
        .timeline-label {
            min-width: 80px;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            font-weight: bold;
        }
        
        .timeline-turns {
            display: flex;
            gap: 3px;
            flex: 1;
        }
        
        .timeline-turn {
            min-width: 80px;
            height: 90px;
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 6px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .timeline-turn.drop-zone {
            border-color: #55e285;
            background: rgba(85, 226, 133, 0.1);
        }
        
        .timeline-turn-number {
            font-size: 11px;
            font-weight: bold;
            color: #4a90e2;
        }
        
        .timeline-hero-value {
            font-size: 16px;
            color: #fff;
            font-weight: bold;
        }
        
        .timeline-soul-slot {
            width: 45px;
            height: 45px;
            border: 2px dashed #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .timeline-soul-slot.occupied {
            border-style: solid;
            border-color: #55e285;
            background: rgba(85, 226, 133, 0.1);
        }
        
        .timeline-soul-card {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #55e285 0%, #45c275 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .timeline-soul-card:hover {
            transform: scale(1.1);
        }
        
        .scroll-hint {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* è¡ŒåŠ¨é€‰æ‹©å¼¹çª— */
        .action-modal {
            width: 450px;
            height: 480px;
        }
        
        .action-content {
            text-align: center;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .target-display {
            font-size: 24px;
            color: #e2a855;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
        }
        
        .action-button {
            padding: 15px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .action-button.battle {
            background: linear-gradient(135deg, #e24a4a 0%, #c73a3a 100%);
            color: white;
        }
        
        .action-button.move {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
        }
        
        .action-button.stealth {
            background: linear-gradient(135deg, #6a4c93 0%, #553a73 100%);
            color: white;
        }
        
        .action-button.campaign {
            background: linear-gradient(135deg, #e2a855 0%, #c49545 100%);
            color: white;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .action-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }
        
        .campaign-mode-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, #e2a855 0%, #c49545 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(226, 168, 85, 0.4);
            animation: campaignPulse 2s ease-in-out infinite;
            z-index: 100;
        }
        
        @keyframes campaignPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(226, 168, 85, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(226, 168, 85, 0.6);
            }
        }
        
        /* æˆ˜å½¹æ¨¡å¼æ ·å¼ */
        .campaign-mode .node {
            transition: all 0.3s ease;
        }
        
        .campaign-mode .node:hover circle {
            r: 28 !important;
            filter: drop-shadow(0 0 10px #e2a855) !important;
        }
        
        .campaign-selectable {
            stroke: #e2a855 !important;
            stroke-width: 3 !important;
            stroke-dasharray: 8,4 !important;
            animation: selectablePulse 1.5s ease-in-out infinite !important;
        }
        
        @keyframes selectablePulse {
            0%, 100% { stroke-opacity: 0.6; }
            50% { stroke-opacity: 1; }
        }
        
        .campaign-selected {
            stroke: #e2a855 !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 15px #e2a855) !important;
        }
        
        .campaign-path {
            stroke: #e2a855 !important;
            stroke-width: 4 !important;
            stroke-dasharray: 10,5 !important;
            animation: campaignPathPulse 2s ease-in-out infinite !important;
        }
        
        @keyframes campaignPathPulse {
            0%, 100% { stroke-opacity: 0.6; }
            50% { stroke-opacity: 1; }
        }
        
        .campaign-info {
            position: absolute;
            top: 60px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e2a855;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }
        
        .campaign-counter {
            color: #e2a855;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .campaign-list {
            color: #ddd;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .campaign-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }
        
        .campaign-btn {
            padding: 5px 10px;
            font-size: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .campaign-btn.confirm {
            background: #e2a855;
            color: white;
        }
        
        .campaign-btn.cancel {
            background: #666;
            color: white;
        }
        
        .campaign-btn:hover {
            transform: translateY(-1px);
        }
        
        .campaign-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }
        
        /* æˆ˜æ–—å¼¹çª— */
        .battle-arena {
            width: 90vw;
            max-width: 1000px;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .battle-field {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px;
            position: relative;
        }
        
        .battle-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .team-label {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .team-label.player {
            color: #4a90e2;
        }
        
        .team-label.enemy {
            color: #e24a4a;
        }
        
        .battle-units {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 300px;
        }
        
        .battle-unit {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 3px solid #5a5a5a;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .battle-unit.player {
            border-color: #4a90e2;
            color: #7ac0ff;
            background: linear-gradient(135deg, #2a3a4a 0%, #1a2a3a 100%);
        }
        
        .battle-unit.enemy {
            border-color: #e24a4a;
            color: #ff7a7a;
            background: linear-gradient(135deg, #4a2a2a 0%, #3a1a1a 100%);
        }
        
        .battle-unit.eliminated {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(100%);
        }
        
        .battle-unit.winner {
            animation: victoryPulse 0.6s ease;
            box-shadow: 0 0 20px currentColor;
        }
        
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .battle-vs {
            font-size: 36px;
            font-weight: bold;
            color: #e2a855;
            text-shadow: 0 0 10px rgba(226, 168, 85, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(226, 168, 85, 0.5); }
            to { text-shadow: 0 0 20px rgba(226, 168, 85, 0.8), 0 0 30px rgba(226, 168, 85, 0.4); }
        }
        
        .turn-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 2px solid #4a90e2;
        }
        
        .damage-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #e2a855;
            animation: floatUp 1s ease-out;
            pointer-events: none;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px);
            }
        }
        
        .soul-effect {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #55e285 0%, transparent 70%);
            border-radius: 50%;
            animation: soulGlow 0.4s ease;
        }
        
        @keyframes soulGlow {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        .battle-controls {
            padding: 15px;
            text-align: center;
            border-top: 1px solid #333;
            background: rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        /* è®¾ç½®ç•Œé¢ */
        .settings-modal {
            width: 500px;
            height: 400px;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #333;
        }
        
        .setting-slider {
            width: 200px;
        }
        
        /* å¼€å§‹ç•Œé¢å’Œå¼€åœºåŠ¨ç”» */
        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(0,0,0,0.98) 0%, rgba(26,26,46,0.98) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .game-modal {
            background: linear-gradient(135deg, #202040 0%, #16213e 100%);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #4a90e2;
            text-align: center;
            max-width: 600px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            position: relative;
        }
        
        .game-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .modal-title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #4a90e2, #e24a4a, #55e285);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .story-text {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            line-height: 1.6;
            color: #ddd;
            border-left: 4px solid #4a90e2;
            position: relative;
            opacity: 0;
            animation: fadeInUp 1s ease 0.5s forwards;
            font-size: 14px;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .opening-animation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 1;
            transition: opacity 1s ease;
            overflow: hidden;
        }
        
        .opening-animation.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .opening-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(90deg, #4a90e2, #e24a4a, #55e285);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 2s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        .opening-subtitle {
            font-size: 18px;
            color: #bbb;
            margin-bottom: 40px;
            opacity: 0;
            animation: fadeIn 1s ease 1s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .opening-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #4a90e2;
            border-radius: 50%;
            animation: float 6s linear infinite;
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }
        
        .scenario-select {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            opacity: 0;
            animation: fadeInUp 1s ease 1.5s forwards;
        }
        
        .scenario-option {
            padding: 25px;
            background: linear-gradient(135deg, #3a3a5a 0%, #2a2a4a 100%);
            border: 3px solid #5a5a7a;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }
        
        .scenario-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.6s;
        }
        
        .scenario-option:hover {
            background: linear-gradient(135deg, #4a4a6a 0%, #3a3a5a 100%);
            border-color: #7a7a9a;
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        
        .scenario-option:hover::before {
            left: 100%;
        }
        
        .scenario-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #e2a855;
        }
        
        .scenario-desc {
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .custom-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }
        
        .custom-input {
            width: 90px;
            padding: 10px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.4);
            color: white;
            border-radius: 6px;
            text-align: center;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .custom-input:focus {
            border-color: #4a90e2;
            outline: none;
        }
        
        /* åœ°å›¾æ ·å¼ */
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover circle {
            r: 25;
        }
        
        .edge {
            stroke: #444;
            stroke-width: 2;
            opacity: 0.6;
        }
        
        .current-node {
            stroke: #4a90e2;
            stroke-width: 4;
            filter: drop-shadow(0 0 10px #4a90e2);
        }
        
        .boss-node {
            fill: #e24a4a;
            filter: drop-shadow(0 0 15px #e24a4a);
        }
        
        .friendly-node {
            fill: #4a90e2;
            filter: drop-shadow(0 0 8px #4a90e2);
        }
        
        .conquered-node {
            fill: #666;
            opacity: 0.7;
        }
        
        .reachable-node {
            stroke: #7ac0ff;
            stroke-width: 3;
            stroke-dasharray: 5,5;
            animation: reachablePulse 2s ease-in-out infinite;
        }
        
        @keyframes reachablePulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 1; }
        }
        
        .map-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.8);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
        }
        
        .zoom-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .zoom-controls .game-button {
            padding: 6px 10px;
            font-size: 10px;
            width: auto;
            margin: 0;
        }

        /* æˆ˜å½¹è°ƒè¯•ä¿¡æ¯ */
        .campaign-debug {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            color: #aaa;
            font-size: 11px;
            max-width: 300px;
            display: none;
        }
        
        .campaign-debug.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- å¼€åœºåŠ¨ç”» -->
    <div class="opening-animation" id="openingAnimation">
        <div class="opening-particles" id="particles"></div>
        <div class="opening-title">ğŸ”® SOUL MAGE</div>
        <div class="opening-subtitle">æ•°å­—é­‚æˆ˜ä¼ å¥‡å³å°†å¼€å§‹...</div>
    </div>

    <div id="gameContainer">
        <div id="mapContainer">
            <div class="map-controls">
                <div class="zoom-controls">
                    <button class="game-button" id="zoomInBtn">æ”¾å¤§</button>
                    <button class="game-button" id="zoomOutBtn">ç¼©å°</button>
                    <button class="game-button" id="centerBtn">å±…ä¸­</button>
                </div>
                <div style="color: #aaa; font-size: 11px;">
                    è§†é‡èŒƒå›´: <span id="viewRange">2</span> æ­¥
                </div>
            </div>
            
            <!-- æˆ˜å½¹è°ƒè¯•ä¿¡æ¯ -->
            <div class="campaign-debug" id="campaignDebug">
                <div>æˆ˜å½¹æ¨¡å¼: <span id="debugCampaignMode">å¦</span></div>
                <div>ç›®æ ‡æ•°é‡: <span id="debugTargetCount">0</span></div>
                <div>ç›®æ ‡åˆ—è¡¨: <span id="debugTargetList">æ— </span></div>
                <div>å½“å‰ä½ç½®: <span id="debugCurrentPos">-</span></div>
            </div>
            
            <svg id="mapSvg"></svg>
        </div>
        
        <div id="sidePanel">
            <div class="panel-header">
                ğŸ”® SOUL MAGE
            </div>
            
            <div class="panel-content">
                <div class="panel-section">
                    <div class="section-title">âš¡ çŠ¶æ€</div>
                    <div class="status-grid">
                        <div class="status-item">
                            <span>å½“å‰ä½ç½®</span>
                            <span class="status-value" id="currentPos">-</span>
                        </div>
                        <div class="status-item">
                            <span>ä¸»è§’å•ä½</span>
                            <span class="status-value" id="heroUnit">-</span>
                        </div>
                        <div class="status-item">
                            <span>ç›®æ ‡BOSS</span>
                            <span class="status-value" id="bossTarget">-</span>
                        </div>
                        <div class="status-item">
                            <span>æ½œè¡Œæœºä¼š</span>
                            <span class="status-value" id="stealthCount">3</span>
                        </div>
                        <div class="status-item">
                            <span>æˆ˜æ–—æ¬¡æ•°</span>
                            <span class="status-value" id="battleCount">0</span>
                        </div>
                        <div class="status-item">
                            <span>æ”¶é›†é­‚æ•°</span>
                            <span class="status-value" id="soulCount">0/9</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">ğŸ’ é­‚åº“</div>
                    <div class="soul-simple-list" id="soulSimpleList"></div>
                    <button class="game-button" id="configureSoulsBtn">âš™ï¸ é…ç½®é­‚ç­–ç•¥</button>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">ğŸ® æ“ä½œ</div>
                    <button class="settings-button game-button" id="settingsBtn">âš™ï¸ æ¸¸æˆè®¾ç½®</button>
                    <button class="game-button" id="helpBtn">â“ æ¸¸æˆè¯´æ˜</button>
                    <button class="game-button" id="campaignModeBtn">ğŸ›ï¸ æˆ˜å½¹æ¨¡å¼</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- é­‚é…ç½®å¼¹çª— -->
    <div class="modal-overlay" id="soulConfigModal">
        <div class="modal-content soul-config-container">
            <div class="modal-header">
                <span>ğŸ’ é­‚æˆ˜ç•¥é…ç½®</span>
                <button class="modal-close" id="closeSoulConfigBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="soul-management">
                    <div class="soul-zones">
                        <div class="soul-zone waiting-zone">
                            <h3>ğŸ’¤ ç­‰å¾…åŒº</h3>
                            <div class="soul-cards" id="waitingSouls"></div>
                        </div>
                        <div class="soul-zone release-zone">
                            <h3>âš”ï¸ é‡Šæ”¾åŒº</h3>
                            <div class="soul-cards" id="releaseSouls"></div>
                        </div>
                    </div>
                    <div class="timeline-container">
                        <h3>â° å¢ç›Šæ—¶é—´çº¿</h3>
                        <div class="timeline-scroll" id="timelineScroll">
                            <div class="timeline-track" id="timelineTrack">
                                <div class="timeline-label">ä¸»è§’<br><span id="heroTimeline">23</span></div>
                                <div class="timeline-turns" id="timelineTurns"></div>
                            </div>
                        </div>
                        <div class="scroll-hint">â† å‘å·¦æ»‘åŠ¨æŸ¥çœ‹æ›´å¤šå›åˆ â†’</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- è¡ŒåŠ¨é€‰æ‹©å¼¹çª— -->
    <div class="modal-overlay" id="actionModal">
        <div class="modal-content action-modal">
            <div class="modal-header">
                <span>ğŸ¯ é€‰æ‹©è¡ŒåŠ¨</span>
                <button class="modal-close" id="closeActionModalBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="action-content">
                    <div>ç›®æ ‡èŠ‚ç‚¹</div>
                    <div class="target-display" id="actionTarget">-</div>
                    <div class="action-buttons">
                        <button class="action-button battle" id="battleActionBtn">âš”ï¸ å‘èµ·æˆ˜æ–—</button>
                        <button class="action-button move" id="moveActionBtn">ğŸš¶ ç§»åŠ¨è¿‡å»</button>
                        <button class="action-button stealth" id="stealthActionBtn">ğŸ¥· æ½œè¡Œç§»åŠ¨</button>
                        <button class="action-button campaign" id="campaignActionBtn">ğŸ›ï¸ å¼€å§‹æˆ˜å½¹</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- æˆ˜æ–—å¼¹çª— -->
    <div class="modal-overlay" id="battleModal">
        <div class="modal-content battle-arena">
            <div class="modal-header">
                <span>âš”ï¸ æ•°å­—é­‚æˆ˜</span>
                <div style="font-size: 14px; opacity: 0.8;">é€Ÿåº¦: <span id="battleSpeedDisplay">æ­£å¸¸</span></div>
            </div>
            <div class="battle-field">
                <div class="turn-display" id="turnDisplay">å‡†å¤‡æˆ˜æ–—...</div>
                
                <div class="battle-team">
                    <div class="team-label player">ğŸ‘‘ æˆ‘æ–¹</div>
                    <div class="battle-units" id="playerBattleUnits"></div>
                </div>
                
                <div class="battle-vs">VS</div>
                
                <div class="battle-team">
                    <div class="team-label enemy">ğŸ’€ æ•Œæ–¹</div>
                    <div class="battle-units" id="enemyBattleUnits"></div>
                </div>
            </div>
            <div class="battle-controls">
                <button class="game-button" id="closeBattleBtn" style="display: none;">å…³é—­</button>
            </div>
        </div>
    </div>
    
    <!-- æ¸¸æˆå¸®åŠ©å¼¹çª— -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <span>â“ æ¸¸æˆè¯´æ˜</span>
                <button class="modal-close" id="closeHelpBtn">&times;</button>
            </div>
            <div class="modal-body" style="overflow-y: auto; max-height: 70vh;">
                <div style="line-height: 1.8; color: #ddd;">
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ¯ æ¸¸æˆç›®æ ‡</h3>
                    <p>å‡»è´¥BOSSæˆä¸ºçœŸæ­£çš„Soul Mageï¼é€šè¿‡å¾æœæ•°å­—èŠ‚ç‚¹ï¼Œæ”¶é›†å¹¶åˆç†è¿ç”¨é­‚çš„åŠ›é‡ã€‚</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ° èŠ‚ç‚¹ç±»å‹</h3>
                    <p>â€¢ <span style="color: #4a90e2;">è“è‰²å‘å…‰</span>ï¼šå‹æ–¹èŠ‚ç‚¹ï¼ˆå¯è‡ªç”±ç§»åŠ¨ï¼‰<br>
                    â€¢ <span style="color: #666;">ç°è‰²</span>ï¼šæ•Œæ–¹å·²å¾æœèŠ‚ç‚¹<br>
                    â€¢ <span style="color: #e24a4a;">çº¢è‰²å‘å…‰</span>ï¼šBOSSèŠ‚ç‚¹<br>
                    â€¢ <span style="color: #4a90e2;">è“è‰²è¾¹æ¡†</span>ï¼šå½“å‰ä½ç½®</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ’ é­‚çš„æœºåˆ¶</h3>
                    <p>â€¢ <span style="color: #e2a855;">é‡Šæ”¾æ¨¡å¼</span>ï¼šé­‚ä½œä¸ºæˆ˜æ–—å•ä½å‚æˆ˜ï¼Œèƒœåˆ©åæˆä¸ºå‹æ–¹èŠ‚ç‚¹<br>
                    â€¢ <span style="color: #55e285;">å¢ç›Šæ¨¡å¼</span>ï¼šåœ¨æŒ‡å®šå›åˆä¸ºä¸»è§’æä¾›é¢å¤–æ”»å‡»åŠ›<br>
                    â€¢ <span style="color: #666;">ç­‰å¾…æ¨¡å¼</span>ï¼šæš‚ä¸ä½¿ç”¨ï¼Œä¿ç•™å¤‡ç”¨</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">âš”ï¸ æˆ˜æ–—è§„åˆ™</h3>
                    <p>â€¢ æ¯å›åˆæ¯”è¾ƒ (æ•°å­— % å›åˆæ•°) çš„æœ€å¤§å€¼<br>
                    â€¢ è¿ç»­èµ¢3å›åˆéšæœºæ¶ˆç­å¯¹æ–¹ä¸€ä¸ªå•ä½<br>
                    â€¢ é­‚å¢ç›Šæ—¶å– max(ä¸»è§’æ”»å‡»åŠ›, é­‚æ”»å‡»åŠ›)<br>
                    â€¢ æ‰€æœ‰å•ä½è¢«æ¶ˆç­çš„ä¸€æ–¹å¤±è´¥</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ›ï¸ æˆ˜å½¹ç³»ç»Ÿ</h3>
                    <p>â€¢ <span style="color: #e2a855;">å¤§å‹æˆ˜å½¹</span>ï¼šå¯åŒæ—¶å®£æˆ˜å¤šä¸ªè¿ç»­èŠ‚ç‚¹ï¼ˆæœ€å¤š7ä¸ªï¼‰<br>
                    â€¢ æ‰€æœ‰æˆ˜å½¹ç›®æ ‡çš„æ•Œäººå’Œé¢å¤–å•ä½å…¨éƒ¨å‚æˆ˜<br>
                    â€¢ èƒœåˆ©ååŒæ—¶æ”¶è·æ‰€æœ‰ç›®æ ‡èŠ‚ç‚¹çš„é­‚<br>
                    â€¢ ç›´æ¥è·³åˆ°æˆ˜å½¹è·¯å¾„çš„æœ«ç«¯ä½ç½®</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ® è¡ŒåŠ¨é€‰é¡¹</h3>
                    <p>â€¢ <span style="color: #e24a4a;">å‘èµ·æˆ˜æ–—</span>ï¼šä¸ç›®æ ‡èŠ‚ç‚¹åŠå…¶ç›Ÿå‹æˆ˜æ–—<br>
                    â€¢ <span style="color: #4a90e2;">æ™®é€šç§»åŠ¨</span>ï¼šç›´æ¥ç§»åŠ¨å¹¶å¾æœæ•Œæ–¹èŠ‚ç‚¹<br>
                    â€¢ <span style="color: #6a4c93;">æ½œè¡Œç§»åŠ¨</span>ï¼šæ¶ˆè€—æ½œè¡Œæ¬¡æ•°ï¼Œé™é»˜å¾æœèŠ‚ç‚¹<br>
                    â€¢ <span style="color: #e2a855;">å¼€å§‹æˆ˜å½¹</span>ï¼šè¿›å…¥æˆ˜å½¹æ¨¡å¼é€‰æ‹©å¤šä¸ªç›®æ ‡</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ¥· æ½œè¡Œç³»ç»Ÿ</h3>
                    <p>â€¢ åˆå§‹æœ‰3æ¬¡æ½œè¡Œæœºä¼š<br>
                    â€¢ æ¯èµ¢å¾—10åœºæˆ˜æ–—å¯è·å¾—1æ¬¡é¢å¤–æ½œè¡Œæœºä¼š<br>
                    â€¢ æ½œè¡Œå¯é¿å…æˆ˜æ–—ç›´æ¥å¾æœèŠ‚ç‚¹</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ—ºï¸ åœ°å›¾è¿æ¥</h3>
                    <p>ä¸¤ä¸ªæ•°å­—èŠ‚ç‚¹ä¹‹é—´å­˜åœ¨è¿æ¥çš„æ¡ä»¶ï¼šå®ƒä»¬çš„å·®å€¼æ˜¯ä¸¤æ•°çš„å…¬å…±è´¨å› æ•°ã€‚</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">âš™ï¸ å¯é…ç½®é¡¹</h3>
                    <p>â€¢ æˆ˜æ–—é€Ÿåº¦ï¼š0.5x - 2x<br>
                    â€¢ è§†é‡èŒƒå›´ï¼š1-4æ­¥<br>
                    â€¢ é­‚çš„æˆ˜ç•¥é…ç½®ï¼šæ‹–æ‹½ç®¡ç†ï¼Œæ”¯æŒåˆ°å›åˆ100</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">ğŸ® æ“ä½œæŠ€å·§</h3>
                    <p>â€¢ ç‚¹å‡»èŠ‚ç‚¹é€‰æ‹©è¡ŒåŠ¨æ–¹å¼<br>
                    â€¢ æ‹–æ‹½é­‚å¡ç‰‡åˆ°ä¸åŒåŒºåŸŸæ¥è®¾ç½®ç­–ç•¥<br>
                    â€¢ æ—¶é—´çº¿å¯æ¨ªå‘æ»šåŠ¨æŸ¥çœ‹æ›´å¤šå›åˆ<br>
                    â€¢ æˆ˜å½¹æ¨¡å¼ï¼šé€‰æ‹©è¿ç»­èŠ‚ç‚¹æ„å»ºæˆ˜å½¹è·¯å¾„<br>
                    â€¢ åˆç†å®‰æ’é­‚çš„é‡Šæ”¾å’Œå¢ç›Šæ—¶æœº</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- è®¾ç½®å¼¹çª— -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <span>âš™ï¸ æ¸¸æˆè®¾ç½®</span>
                <button class="modal-close" id="closeSettingsBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="setting-item">
                    <span>æˆ˜æ–—é€Ÿåº¦</span>
                    <select class="setting-slider" id="battleSpeedSelect">
                        <option value="0.5">æ…¢é€Ÿ (0.5x)</option>
                        <option value="1" selected>æ­£å¸¸ (1x)</option>
                        <option value="1.5">å¿«é€Ÿ (1.5x)</option>
                        <option value="2">æå¿« (2x)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>è§†é‡èŒƒå›´</span>
                    <input type="range" class="setting-slider" id="viewRangeSlider" min="1" max="4" value="2">
                </div>
                <div class="setting-item">
                    <span>éŸ³æ•ˆå¼€å…³</span>
                    <input type="checkbox" id="soundToggle" checked>
                </div>
                <div class="setting-item">
                    <span>è°ƒè¯•æ¨¡å¼</span>
                    <input type="checkbox" id="debugToggle">
                </div>
            </div>
        </div>
    </div>
    
    <!-- æ¸¸æˆå¼€å§‹ç•Œé¢ -->
    <div id="gameOverlay">
        <div class="game-modal">
            <h1 class="modal-title">ğŸ”® SOUL MAGE</h1>
            <div class="story-text" id="storyText">
                <strong>æ•°å­—é­‚åŸŸä¼ è¯´</strong><br><br>
                åœ¨æ•°å­—å®‡å®™ä¸­ï¼Œæ¯ä¸ªæ•°å­—éƒ½è•´å«ç€å¼ºå¤§çš„åŠ›é‡ã€‚ä½œä¸ºå¹´è½»çš„é­‚æ³•å¸ˆå­¦å¾’ï¼Œä½ å°†é€šè¿‡å¾æœæ•°å­—èŠ‚ç‚¹ï¼Œæ”¶é›†å¹¶é‡Šæ”¾æ•°å­—ä¹‹é­‚æ¥æŒæ¡é­‚æ³•çš„å¥¥ç§˜ã€‚<br><br>
                <em>ç°åœ¨ï¼Œé€‰æ‹©ä½ çš„å‘½è¿...</em>
            </div>
            
            <div class="scenario-select">
                <div class="scenario-option" data-hero="23" data-boss="419">
                    <div class="scenario-title">ğŸ’« æ•°å­—ä¼ å¥‡ï¼š23ä¸419çš„å®¿å‘½å¯¹å†³</div>
                    <div class="scenario-desc">
                        ç¥ç§˜è´¨æ•°23å¯¹å†³æ•°å­—åŸŸéœ¸ä¸»419ï¼Œåªæœ‰çœŸæ­£çš„é­‚æ³•å¸ˆæ‰èƒ½é©¾é©­è¿™è‚¡åŠ›é‡ï¼
                    </div>
                </div>
                
                <div class="scenario-option custom-scenario">
                    <div class="scenario-title">ğŸ¨ è‡ªå®šä¹‰ä¼ å¥‡</div>
                    <div class="scenario-desc">é€‰æ‹©ä½ çš„è‹±é›„å’Œç»ˆææŒ‘æˆ˜</div>
                    <div class="custom-inputs">
                        <input type="number" class="custom-input" id="customHero" placeholder="è‹±é›„" min="2" max="999">
                        <span style="color: #e2a855; font-size: 20px;">âš”ï¸</span>
                        <input type="number" class="custom-input" id="customBoss" placeholder="BOSS" min="2" max="999">
                        <button class="game-button" id="startCustomBtn" style="width: auto; margin: 0; padding: 10px 20px;">å¼€å§‹ä¼ å¥‡</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        class SoulMageGame {
            constructor() {
                this.mapSize = 500;
                this.bossNode = 419;
                this.nodes = [];
                this.edges = [];
                this.adjacencyList = {};
                this.currentPos = null;
                this.heroUnit = null;
                this.souls = [];
                this.maxSouls = 9;
                this.conqueredNodes = new Set();
                this.friendlyNodes = new Set();
                this.battleInProgress = false;
                this.stealthCount = 3;
                this.battleCount = 0;
                this.viewRange = 2;
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.beforeBattleState = null;
                this.selectedTarget = null;
                
                // æˆ˜å½¹æ¨¡å¼ç›¸å…³
                this.campaignMode = false;
                this.campaignTargets = [];
                this.maxCampaignLength = 7;
                
                this.soulModes = [];
                this.soulBuffTurns = [];
                
                this.battleSpeed = 1;
                this.soundEnabled = true;
                this.debugMode = false;
                
                this.initializeGame();
            }
            
            initializeGame() {
                this.showOpeningAnimation();
                this.setupEventListeners();
                this.generateMap();
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
            }
            
            showOpeningAnimation() {
                try {
                    const particlesContainer = document.getElementById('particles');
                    if (!particlesContainer) {
                        console.warn('Particles container not found');
                        return;
                    }
                    
                    for (let i = 0; i < 50; i++) {
                        setTimeout(() => {
                            const particle = document.createElement('div');
                            particle.className = 'particle';
                            particle.style.left = Math.random() * 100 + '%';
                            particle.style.animationDelay = Math.random() * 6 + 's';
                            particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                            
                            const colors = ['#4a90e2', '#e24a4a', '#55e285', '#e2a855'];
                            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                            
                            particlesContainer.appendChild(particle);
                        }, i * 100);
                    }
                    
                    setTimeout(() => {
                        const opening = document.getElementById('openingAnimation');
                        if (opening) {
                            opening.classList.add('fade-out');
                            setTimeout(() => {
                                opening.style.display = 'none';
                            }, 1000);
                        }
                    }, 3000);
                } catch (error) {
                    console.error('Error in showOpeningAnimation:', error);
                }
            }
            
            generateMap() {
                console.log('ç”Ÿæˆåœ°å›¾ä¸­...');
                const startTime = performance.now();
                
                for (let i = 2; i <= this.mapSize; i++) {
                    this.nodes.push(i);
                    this.adjacencyList[i] = [];
                }
                
                let edgeCount = 0;
                const maxEdges = 5000;
                
                for (let i = 0; i < this.nodes.length && edgeCount < maxEdges; i++) {
                    for (let j = i + 1; j < this.nodes.length && edgeCount < maxEdges; j++) {
                        const a = this.nodes[i];
                        const b = this.nodes[j];
                        const diff = Math.abs(a - b);
                        
                        if (this.isCommonPrimeFactor(a, b, diff)) {
                            this.edges.push([a, b]);
                            this.adjacencyList[a].push(b);
                            this.adjacencyList[b].push(a);
                            edgeCount++;
                        }
                    }
                }
                
                const endTime = performance.now();
                console.log(`åœ°å›¾ç”Ÿæˆå®Œæˆï¼Œç”¨æ—¶ ${(endTime - startTime).toFixed(2)}msï¼Œå…±${edgeCount}æ¡è¾¹`);
            }
            
            primeCache = new Map();
            
            isCommonPrimeFactor(a, b, diff) {
                if (diff === 1) return false;
                if (!this.isPrime(diff)) return false;
                return a % diff === 0 && b % diff === 0;
            }
            
            isPrime(n) {
                if (this.primeCache.has(n)) {
                    return this.primeCache.get(n);
                }
                
                if (n < 2) {
                    this.primeCache.set(n, false);
                    return false;
                }
                
                for (let i = 2; i * i <= n; i++) {
                    if (n % i === 0) {
                        this.primeCache.set(n, false);
                        return false;
                    }
                }
                
                this.primeCache.set(n, true);
                return true;
            }
            
            updateFriendlyNodes() {
                this.friendlyNodes.clear();
                if (this.heroUnit) {
                    this.friendlyNodes.add(this.heroUnit);
                }
                this.souls.forEach(soul => {
                    this.friendlyNodes.add(soul);
                });
            }
            
            getVisibleNodes() {
                if (!this.currentPos) return [];
                
                const visited = new Set();
                const queue = [{node: this.currentPos, distance: 0}];
                const visibleNodes = [];
                
                if (this.campaignMode && this.campaignTargets.length > 0) {
                    this.campaignTargets.forEach(target => {
                        if (!visited.has(target)) {
                            queue.push({node: target, distance: 0});
                        }
                    });
                }
                
                while (queue.length > 0) {
                    const {node, distance} = queue.shift();
                    
                    if (visited.has(node)) continue;
                    visited.add(node);
                    visibleNodes.push(node);
                    
                    if (distance < this.viewRange) {
                        this.adjacencyList[node].forEach(neighbor => {
                            if (!visited.has(neighbor)) {
                                queue.push({node: neighbor, distance: distance + 1});
                            }
                        });
                    }
                }
                
                return visibleNodes;
            }
            
            renderMap() {
                const svg = document.getElementById('mapSvg');
                const rect = svg.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                if (width <= 0 || height <= 0) {
                    setTimeout(() => this.renderMap(), 100);
                    return;
                }
                
                this.manageCampaignModeIndicator();
                this.updateDebugInfo();
                
                if (!this.campaignMode) {
                    const infoDiv = document.getElementById('campaignInfo');
                    if (infoDiv) {
                        infoDiv.remove();
                    }
                }
                
                const visibleNodes = this.getVisibleNodes();
                if (visibleNodes.length === 0) {
                    console.warn('æ²¡æœ‰å¯è§èŠ‚ç‚¹ã€‚å½“å‰ä½ç½®:', this.currentPos);
                    return;
                }
                
                const visibleEdges = this.edges.filter(([a, b]) => 
                    visibleNodes.includes(a) && visibleNodes.includes(b)
                );
                
                const positions = this.forceDirectedLayout(visibleNodes, visibleEdges, width, height);
                
                svg.innerHTML = '';
                
                const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                mainGroup.setAttribute('transform', `translate(${width/2 + this.panX}, ${height/2 + this.panY}) scale(${this.zoom})`);
                
                if (this.campaignMode) {
                    svg.classList.add('campaign-mode');
                } else {
                    svg.classList.remove('campaign-mode');
                }
                
                visibleEdges.forEach(([a, b]) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', positions[a].x);
                    line.setAttribute('y1', positions[a].y);
                    line.setAttribute('x2', positions[b].x);
                    line.setAttribute('y2', positions[b].y);
                    line.setAttribute('class', 'edge');
                    mainGroup.appendChild(line);
                });
                
                visibleNodes.forEach(node => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'node');
                    g.setAttribute('transform', `translate(${positions[node].x},${positions[node].y})`);
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', '20');
                    circle.setAttribute('fill', '#2a2a2a');
                    
                    if (node === this.bossNode) {
                        circle.classList.add('boss-node');
                    } else if (node === this.currentPos) {
                        circle.classList.add('current-node');
                    } else if (this.friendlyNodes.has(node)) {
                        circle.classList.add('friendly-node');
                    } else if (this.conqueredNodes.has(node)) {
                        circle.classList.add('conquered-node');
                    }
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dy', '5');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '14');
                    text.textContent = node;
                    
                    g.appendChild(circle);
                    g.appendChild(text);
                    
                    g.addEventListener('click', () => this.onNodeClick(node));
                    
                    mainGroup.appendChild(g);
                });
                
                svg.appendChild(mainGroup);
                this.nodePositions = positions;
                
                if (this.campaignMode) {
                    this.highlightCampaignSelectableNodes();
                    if (this.campaignTargets.length > 0) {
                        this.highlightCampaignPath();
                    }
                } else {
                    this.highlightReachableNodes();
                }
            }
            
            updateDebugInfo() {
                if (this.debugMode) {
                    document.getElementById('campaignDebug').classList.add('show');
                    document.getElementById('debugCampaignMode').textContent = this.campaignMode ? 'æ˜¯' : 'å¦';
                    document.getElementById('debugTargetCount').textContent = this.campaignTargets.length;
                    document.getElementById('debugTargetList').textContent = this.campaignTargets.length > 0 ? this.campaignTargets.join(', ') : 'æ— ';
                    document.getElementById('debugCurrentPos').textContent = this.currentPos || '-';
                } else {
                    document.getElementById('campaignDebug').classList.remove('show');
                }
            }
            
            manageCampaignModeIndicator() {
                let indicator = document.getElementById('campaignModeIndicator');
                
                if (this.campaignMode) {
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'campaignModeIndicator';
                        indicator.className = 'campaign-mode-indicator';
                        document.getElementById('mapContainer').appendChild(indicator);
                    }
                    
                    if (this.campaignTargets.length === 0) {
                        indicator.textContent = 'ğŸ›ï¸ æˆ˜å½¹æ¨¡å¼ï¼šé€‰æ‹©ç¬¬ä¸€ä¸ªç›®æ ‡';
                    } else {
                        indicator.textContent = `ğŸ›ï¸ æˆ˜å½¹æ¨¡å¼ï¼šé€‰æ‹©ä¸‹ä¸€ä¸ªç›®æ ‡ (${this.campaignTargets.length}/${this.maxCampaignLength})`;
                    }
                } else {
                    if (indicator) {
                        indicator.remove();
                    }
                }
            }
            
            highlightCampaignSelectableNodes() {
                const selectableNodes = this.getCampaignSelectableNodes();
                console.log('æˆ˜å½¹å¯é€‰æ‹©èŠ‚ç‚¹:', selectableNodes);
                
                selectableNodes.forEach(node => {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach(nodeGroup => {
                        const text = nodeGroup.querySelector('text');
                        if (text && parseInt(text.textContent) === node) {
                            const circle = nodeGroup.querySelector('circle');
                            if (circle) {
                                circle.classList.add('campaign-selectable');
                            }
                        }
                    });
                });
            }
            
            getCampaignSelectableNodes() {
                if (this.campaignTargets.length === 0) {
                    const reachable = this.adjacencyList[this.currentPos] || [];
                    console.log('ç¬¬ä¸€ä¸ªç›®æ ‡å¯é€‰æ‹©:', reachable);
                    return reachable;
                } else {
                    const lastTarget = this.campaignTargets[this.campaignTargets.length - 1];
                    const selectable = this.adjacencyList[lastTarget].filter(node => 
                        !this.campaignTargets.includes(node) && 
                        node !== this.currentPos
                    );
                    console.log('åç»­ç›®æ ‡å¯é€‰æ‹© (ä»', lastTarget, '):', selectable);
                    return selectable;
                }
            }
            
            forceDirectedLayout(nodes, edges, width, height) {
                const positions = {};
                const centerX = 0;
                const centerY = 0;
                const minDistance = 60;
                
                if (this.currentPos && nodes.includes(this.currentPos)) {
                    positions[this.currentPos] = {x: centerX, y: centerY};
                }
                
                const otherNodes = nodes.filter(n => n !== this.currentPos);
                otherNodes.forEach((node, i) => {
                    let attempts = 0;
                    let validPosition = false;
                    
                    while (!validPosition && attempts < 100) {
                        const angle = (i / otherNodes.length) * 2 * Math.PI + attempts * 0.1;
                        const radius = 80 + attempts * 5;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        validPosition = true;
                        for (const [existingNode, pos] of Object.entries(positions)) {
                            const dx = x - pos.x;
                            const dy = y - pos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (validPosition) {
                            positions[node] = {x, y};
                        }
                        attempts++;
                    }
                    
                    if (!validPosition) {
                        const angle = (i / otherNodes.length) * 2 * Math.PI;
                        const radius = 120 + i * 10;
                        positions[node] = {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    }
                });
                
                for (let iter = 0; iter < 50; iter++) {
                    const forces = {};
                    nodes.forEach(node => {
                        forces[node] = {x: 0, y: 0};
                    });
                    
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            const a = nodes[i];
                            const b = nodes[j];
                            const dx = positions[b].x - positions[a].x;
                            const dy = positions[b].y - positions[a].y;
                            const dist = Math.sqrt(dx*dx + dy*dy) + 0.01;
                            
                            if (dist < minDistance) {
                                const force = (minDistance - dist) * 2;
                                forces[a].x -= dx/dist * force;
                                forces[a].y -= dy/dist * force;
                                forces[b].x += dx/dist * force;
                                forces[b].y += dy/dist * force;
                            } else {
                                const force = 300 / (dist * dist);
                                forces[a].x -= dx/dist * force;
                                forces[a].y -= dy/dist * force;
                                forces[b].x += dx/dist * force;
                                forces[b].y += dy/dist * force;
                            }
                        }
                    }
                    
                    edges.forEach(([a, b]) => {
                        if (positions[a] && positions[b]) {
                            const dx = positions[b].x - positions[a].x;
                            const dy = positions[b].y - positions[a].y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const idealDist = 90;
                            const force = (dist - idealDist) * 0.05;
                            
                            forces[a].x += dx/dist * force;
                            forces[a].y += dy/dist * force;
                            forces[b].x -= dx/dist * force;
                            forces[b].y -= dy/dist * force;
                        }
                    });
                    
                    nodes.forEach(node => {
                        if (node === this.currentPos) return;
                        
                        positions[node].x += forces[node].x * 0.1;
                        positions[node].y += forces[node].y * 0.1;
                        
                        const maxDist = Math.min(width, height) * 0.35;
                        const dist = Math.sqrt(positions[node].x*positions[node].x + positions[node].y*positions[node].y);
                        if (dist > maxDist) {
                            positions[node].x = positions[node].x / dist * maxDist;
                            positions[node].y = positions[node].y / dist * maxDist;
                        }
                    });
                }
                
                return positions;
            }
            
            onNodeClick(node) {
                console.log('èŠ‚ç‚¹ç‚¹å‡»:', node, 'æˆ˜å½¹æ¨¡å¼:', this.campaignMode, 'æˆ˜æ–—ä¸­:', this.battleInProgress);
                
                if (this.battleInProgress) {
                    console.log('æˆ˜æ–—è¿›è¡Œä¸­ï¼Œå¿½ç•¥èŠ‚ç‚¹ç‚¹å‡»');
                    return;
                }
                
                if (this.campaignMode) {
                    console.log('å¤„ç†æˆ˜å½¹æ¨¡å¼èŠ‚ç‚¹ç‚¹å‡»');
                    this.handleCampaignNodeClick(node);
                } else if (this.canReach(node)) {
                    console.log('æ˜¾ç¤ºè¡ŒåŠ¨é€‰æ‹©æ¨¡æ€æ¡†');
                    this.showActionModal(node);
                } else {
                    console.log('èŠ‚ç‚¹ä¸å¯è¾¾:', node);
                }
            }
            
            handleCampaignNodeClick(node) {
                console.log('æˆ˜å½¹æ¨¡å¼: ç‚¹å‡»èŠ‚ç‚¹', node);
                console.log('å½“å‰æˆ˜å½¹ç›®æ ‡:', this.campaignTargets);
                console.log('å½“å‰ä½ç½®:', this.currentPos);
                
                const selectableNodes = this.getCampaignSelectableNodes();
                if (!selectableNodes.includes(node)) {
                    console.log('èŠ‚ç‚¹', node, 'åœ¨æˆ˜å½¹æ¨¡å¼ä¸‹ä¸å¯é€‰æ‹©');
                    this.showMessage('è¯¥èŠ‚ç‚¹ä¸èƒ½ä½œä¸ºæˆ˜å½¹ç›®æ ‡ï¼');
                    return;
                }
                
                this.campaignTargets.push(node);
                console.log('æ·»åŠ æˆ˜å½¹ç›®æ ‡:', node, 'æ€»ç›®æ ‡æ•°:', this.campaignTargets.length);
                
                if (this.campaignTargets.length >= this.maxCampaignLength) {
                    console.log('æˆ˜å½¹è¾¾åˆ°æœ€å¤§é•¿åº¦');
                }
                
                this.renderCampaignMode();
            }
            
            showMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0,0,0,0.9);
                    color: #e2a855;
                    padding: 20px;
                    border-radius: 10px;
                    border: 2px solid #e2a855;
                    z-index: 5000;
                    font-weight: bold;
                    text-align: center;
                    animation: fadeInOut 2s ease;
                `;
                messageDiv.textContent = message;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(messageDiv);
                setTimeout(() => {
                    messageDiv.remove();
                    style.remove();
                }, 2000);
            }
            
            startCampaignMode() {
                console.log('å¼€å§‹æˆ˜å½¹æ¨¡å¼');
                this.campaignMode = true;
                this.campaignTargets = [];
                this.renderCampaignMode();
            }
            
            exitCampaignMode() {
                console.log('é€€å‡ºæˆ˜å½¹æ¨¡å¼');
                this.campaignMode = false;
                this.campaignTargets = [];
                
                const infoDiv = document.getElementById('campaignInfo');
                if (infoDiv) {
                    infoDiv.remove();
                }
                
                const indicator = document.getElementById('campaignModeIndicator');
                if (indicator) {
                    indicator.remove();
                }
                
                this.renderMap();
            }
            
            renderCampaignMode() {
                console.log('æ¸²æŸ“æˆ˜å½¹æ¨¡å¼ï¼Œç›®æ ‡:', this.campaignTargets);
                this.renderMap();
                this.showCampaignInfo();
            }
            
            highlightCampaignPath() {
                this.campaignTargets.forEach(target => {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach(nodeGroup => {
                        const text = nodeGroup.querySelector('text');
                        if (text && parseInt(text.textContent) === target) {
                            const circle = nodeGroup.querySelector('circle');
                            if (circle) {
                                circle.classList.add('campaign-selected');
                            }
                        }
                    });
                });
                
                for (let i = 0; i < this.campaignTargets.length - 1; i++) {
                    const from = this.campaignTargets[i];
                    const to = this.campaignTargets[i + 1];
                    
                    if (this.nodePositions[from] && this.nodePositions[to]) {
                        const lines = document.querySelectorAll('line');
                        lines.forEach(line => {
                            const x1 = parseFloat(line.getAttribute('x1'));
                            const y1 = parseFloat(line.getAttribute('y1'));
                            const x2 = parseFloat(line.getAttribute('x2'));
                            const y2 = parseFloat(line.getAttribute('y2'));
                            
                            const pos1 = this.nodePositions[from];
                            const pos2 = this.nodePositions[to];
                            
                            const tolerance = 2;
                            if (((Math.abs(x1 - pos1.x) < tolerance && Math.abs(y1 - pos1.y) < tolerance && 
                                  Math.abs(x2 - pos2.x) < tolerance && Math.abs(y2 - pos2.y) < tolerance) ||
                                 (Math.abs(x1 - pos2.x) < tolerance && Math.abs(y1 - pos2.y) < tolerance && 
                                  Math.abs(x2 - pos1.x) < tolerance && Math.abs(y2 - pos1.y) < tolerance))) {
                                line.classList.add('campaign-path');
                            }
                        });
                    }
                }
            }
            
            showCampaignInfo() {
                let infoDiv = document.getElementById('campaignInfo');
                if (!infoDiv) {
                    infoDiv = document.createElement('div');
                    infoDiv.id = 'campaignInfo';
                    infoDiv.className = 'campaign-info';
                    document.getElementById('mapContainer').appendChild(infoDiv);
                }
                
                const totalEnemies = this.calculateCampaignEnemies();
                const targetsText = this.campaignTargets.length > 0 ? this.campaignTargets.join(' â†’ ') : 'æ— ';
                
                infoDiv.innerHTML = `
                    <div class="campaign-counter">æˆ˜å½¹è·¯å¾„: ${this.campaignTargets.length}/${this.maxCampaignLength}</div>
                    <div class="campaign-list">
                        ç›®æ ‡: ${targetsText}<br>
                        é¢„è®¡æ•Œå†›: ${totalEnemies} ä¸ªå•ä½
                    </div>
                    <div class="campaign-controls">
                        ${this.campaignTargets.length > 0 ? 
                            '<button class="campaign-btn confirm" id="confirmCampaignBtn">å‘èµ·æˆ˜å½¹</button>' : 
                            '<button class="campaign-btn confirm" disabled>é€‰æ‹©ç›®æ ‡</button>'
                        }
                        <button class="campaign-btn cancel" id="cancelCampaignBtn">å–æ¶ˆ</button>
                    </div>
                `;
                
                const confirmBtn = document.getElementById('confirmCampaignBtn');
                const cancelBtn = document.getElementById('cancelCampaignBtn');
                
                if (confirmBtn) {
                    confirmBtn.onclick = () => this.confirmCampaign();
                }
                if (cancelBtn) {
                    cancelBtn.onclick = () => this.exitCampaignMode();
                }
            }
            
            calculateCampaignEnemies() {
                let total = 0;
                const usedEnemies = new Set();
                
                this.campaignTargets.forEach(target => {
                    if (!usedEnemies.has(target) && !this.friendlyNodes.has(target)) {
                        total++;
                        usedEnemies.add(target);
                    }
                    
                    const additionalCount = this.getAdditionalEnemyCount(target);
                    let availableNeighbors = this.adjacencyList[target].filter(n => 
                        n !== this.currentPos && 
                        !this.friendlyNodes.has(n) && 
                        !usedEnemies.has(n) &&
                        !this.campaignTargets.includes(n)
                    );
                    
                    if (availableNeighbors.length < additionalCount) {
                        const distance2Neighbors = new Set();
                        availableNeighbors.forEach(neighbor => {
                            this.adjacencyList[neighbor].forEach(n => {
                                if (n !== target && 
                                    n !== this.currentPos && 
                                    !this.friendlyNodes.has(n) && 
                                    !usedEnemies.has(n) &&
                                    !this.campaignTargets.includes(n)) {
                                    distance2Neighbors.add(n);
                                }
                            });
                        });
                        availableNeighbors = [...availableNeighbors, ...Array.from(distance2Neighbors)];
                    }
                    
                    const actualAdditional = Math.min(additionalCount, availableNeighbors.length);
                    for (let i = 0; i < actualAdditional; i++) {
                        if (availableNeighbors[i] && !usedEnemies.has(availableNeighbors[i])) {
                            total++;
                            usedEnemies.add(availableNeighbors[i]);
                        }
                    }
                });
                
                return total;
            }
            
            async confirmCampaign() {
                if (this.campaignTargets.length === 0) {
                    console.log('æ²¡æœ‰é€‰æ‹©æˆ˜å½¹ç›®æ ‡');
                    this.showMessage('è¯·å…ˆé€‰æ‹©æˆ˜å½¹ç›®æ ‡ï¼');
                    return;
                }
                
                console.log('ç¡®è®¤æˆ˜å½¹ï¼Œç›®æ ‡:', this.campaignTargets);
                
                // ä¿å­˜æˆ˜å½¹ç›®æ ‡ï¼Œå› ä¸ºexitCampaignMode()ä¼šæ¸…ç©ºå®ƒä»¬
                const campaignTargetsCopy = [...this.campaignTargets];
                
                // æ¸…ç†æˆ˜å½¹ç•Œé¢
                this.exitCampaignMode();
                
                // æ¢å¤æˆ˜å½¹ç›®æ ‡å¹¶å¯åŠ¨æˆ˜å½¹æˆ˜æ–—
                this.campaignTargets = campaignTargetsCopy;
                await this.startCampaignBattle();
            }
            
            async startCampaignBattle() {
                console.log('å¼€å§‹æˆ˜å½¹æˆ˜æ–—...');
                this.saveBeforeBattleState();
                this.battleInProgress = true;
                
                const playerUnits = [this.heroUnit];
                const releasedSoulIndices = [];
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'release') {
                        playerUnits.push(soul);
                        releasedSoulIndices.push(index);
                    }
                });
                
                const enemyNodes = this.getCampaignEnemies();
                console.log('æˆ˜å½¹æˆ˜æ–— - æˆ‘æ–¹å•ä½:', playerUnits);
                console.log('æˆ˜å½¹æˆ˜æ–— - æ•Œæ–¹å•ä½:', enemyNodes);
                
                if (enemyNodes.length === 0) {
                    console.error('æˆ˜å½¹æˆ˜æ–—ä¸­æ²¡æœ‰æ‰¾åˆ°æ•Œæ–¹å•ä½ï¼');
                    this.showMessage('æˆ˜å½¹ä¸­æ²¡æœ‰æ•Œäººï¼è¿™å¯èƒ½æ˜¯ä¸€ä¸ªbugã€‚');
                    this.battleInProgress = false;
                    return;
                }
                
                await this.showBattleModal(playerUnits, enemyNodes);
                
                const result = await this.numbercraftBattle(playerUnits, enemyNodes);
                
                if (result.winner === 'X') {
                    this.onCampaignWin(releasedSoulIndices);
                } else {
                    this.onBattleLose();
                }
                
                this.battleInProgress = false;
            }
            
            getCampaignEnemies() {
                console.log('è·å–æˆ˜å½¹æ•Œäººï¼Œç›®æ ‡:', this.campaignTargets);
                const enemies = [];
                const usedEnemies = new Set();
                
                this.campaignTargets.forEach(target => {
                    console.log('å¤„ç†ç›®æ ‡:', target);
                    
                    if (!usedEnemies.has(target) && !this.friendlyNodes.has(target)) {
                        enemies.push(target);
                        usedEnemies.add(target);
                        console.log('æ·»åŠ ç›®æ ‡ä½œä¸ºæ•Œäºº:', target);
                    }
                    
                    const additionalCount = this.getAdditionalEnemyCount(target);
                    console.log('ç›®æ ‡', target, 'éœ€è¦é¢å¤–æ•Œäºº:', additionalCount);
                    
                    let availableNeighbors = this.adjacencyList[target].filter(n => 
                        n !== this.currentPos && 
                        !this.friendlyNodes.has(n) && 
                        !usedEnemies.has(n) &&
                        !this.campaignTargets.includes(n)
                    );
                    
                    console.log('ç›®æ ‡', target, 'çš„å¯ç”¨é‚»å±…:', availableNeighbors);
                    
                    if (availableNeighbors.length < additionalCount) {
                        const distance2Neighbors = new Set();
                        availableNeighbors.forEach(neighbor => {
                            this.adjacencyList[neighbor].forEach(n => {
                                if (n !== target && 
                                    n !== this.currentPos && 
                                    !this.friendlyNodes.has(n) && 
                                    !usedEnemies.has(n) &&
                                    !this.campaignTargets.includes(n)) {
                                    distance2Neighbors.add(n);
                                }
                            });
                        });
                        availableNeighbors = [...availableNeighbors, ...Array.from(distance2Neighbors)];
                        console.log('æ‰©å±•å¯ç”¨é‚»å±…:', availableNeighbors);
                    }
                    
                    for (let i = 0; i < additionalCount && availableNeighbors.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * availableNeighbors.length);
                        const enemy = availableNeighbors.splice(randomIndex, 1)[0];
                        if (!usedEnemies.has(enemy)) {
                            enemies.push(enemy);
                            usedEnemies.add(enemy);
                            console.log('æ·»åŠ é¢å¤–æ•Œäºº:', enemy);
                        }
                    }
                });
                
                console.log('æœ€ç»ˆæˆ˜å½¹æ•Œäºº:', enemies);
                return enemies;
            }
            
            onCampaignWin(releasedSoulIndices) {
                console.log('æˆ˜å½¹èƒœåˆ©ï¼ç›®æ ‡:', this.campaignTargets);
                this.battleCount++;
                
                if (this.battleCount % 10 === 0 && this.stealthCount < 3) {
                    this.stealthCount++;
                }
                
                releasedSoulIndices.sort((a, b) => b - a).forEach(index => {
                    this.souls.splice(index, 1);
                    this.soulModes.splice(index, 1);
                    this.soulBuffTurns.splice(index, 1);
                });
                
                const campaignTargetsCopy = [...this.campaignTargets];
                campaignTargetsCopy.forEach(target => {
                    this.conqueredNodes.add(target);
                    this.collectSoul(target);
                    console.log('å¾æœå¹¶æ”¶é›†äº†é­‚:', target);
                });
                
                this.currentPos = campaignTargetsCopy[campaignTargetsCopy.length - 1];
                console.log('ç§»åŠ¨åˆ°æˆ˜å½¹ç»ˆç‚¹ä½ç½®:', this.currentPos);
                
                this.campaignTargets = [];
                
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
                this.updateUI();
                this.renderMap();
                
                if (this.conqueredNodes.has(this.bossNode)) {
                    this.onGameWin();
                }
            }
            
            canReach(node) {
                if (this.currentPos === null) return false;
                if (node === this.currentPos) return false;
                return this.adjacencyList[this.currentPos].includes(node);
            }
            
            highlightReachableNodes() {
                document.querySelectorAll('.reachable-node').forEach(el => {
                    el.classList.remove('reachable-node');
                });
                
                if (!this.currentPos) return;
                
                const reachableNodes = new Set();
                this.adjacencyList[this.currentPos].forEach(node => {
                    reachableNodes.add(node);
                });
                
                document.querySelectorAll('.node').forEach(g => {
                    const circle = g.querySelector('circle');
                    const text = g.querySelector('text');
                    const nodeNum = parseInt(text.textContent);
                    if (reachableNodes.has(nodeNum)) {
                        circle.classList.add('reachable-node');
                    }
                });
            }
            
            showActionModal(node) {
                this.selectedTarget = node;
                document.getElementById('actionTarget').textContent = node;
                
                const battleBtn = document.getElementById('battleActionBtn');
                const moveBtn = document.getElementById('moveActionBtn');
                const stealthBtn = document.getElementById('stealthActionBtn');
                const campaignBtn = document.getElementById('campaignActionBtn');
                
                // é‡ç½®æ‰€æœ‰æŒ‰é’®æ˜¾ç¤º
                battleBtn.style.display = 'block';
                moveBtn.style.display = 'block';
                stealthBtn.style.display = 'block';
                campaignBtn.style.display = 'block';
                
                if (this.friendlyNodes.has(node)) {
                    // å‹æ–¹èŠ‚ç‚¹åªèƒ½ç§»åŠ¨ï¼Œéšè—å…¶ä»–æ“ä½œ
                    battleBtn.style.display = 'none';
                    stealthBtn.style.display = 'none';
                    campaignBtn.style.display = 'none';
                    moveBtn.textContent = 'ğŸš¶ ç§»åŠ¨åˆ°å‹æ–¹èŠ‚ç‚¹';
                } else {
                    // æ•Œæ–¹èŠ‚ç‚¹ä¸èƒ½æ™®é€šç§»åŠ¨ï¼Œéšè—æ™®é€šç§»åŠ¨æŒ‰é’®
                    moveBtn.style.display = 'none';
                    
                    // æ£€æŸ¥æ½œè¡Œæ¬¡æ•°
                    if (this.stealthCount <= 0) {
                        stealthBtn.disabled = true;
                        stealthBtn.textContent = `ğŸ¥· æ½œè¡Œç§»åŠ¨ (${this.stealthCount})`;
                    } else {
                        stealthBtn.disabled = false;
                        stealthBtn.textContent = `ğŸ¥· æ½œè¡Œç§»åŠ¨ (${this.stealthCount})`;
                    }
                }
                
                document.getElementById('actionModal').style.display = 'flex';
            }
            
            closeActionModal() {
                document.getElementById('actionModal').style.display = 'none';
                this.selectedTarget = null;
            }
            
            stealthMove(targetNode) {
                if (this.stealthCount <= 0 || !this.canReach(targetNode)) {
                    return false;
                }
                
                this.stealthCount--;
                this.currentPos = targetNode;
                this.conqueredNodes.add(targetNode);
                
                this.updateUI();
                this.renderMap();
                
                return true;
            }
            
            moveToNode(targetNode) {
                if (this.friendlyNodes.has(targetNode)) {
                    this.currentPos = targetNode;
                } else {
                    this.currentPos = targetNode;
                    this.conqueredNodes.add(targetNode);
                }
                
                this.updateUI();
                this.renderMap();
                return true;
            }
            
            saveBeforeBattleState() {
                this.beforeBattleState = {
                    currentPos: this.currentPos,
                    souls: [...this.souls],
                    conqueredNodes: new Set(this.conqueredNodes),
                    friendlyNodes: new Set(this.friendlyNodes),
                    soulModes: [...this.soulModes],
                    soulBuffTurns: [...this.soulBuffTurns]
                };
            }
            
            restoreBeforeBattleState() {
                if (this.beforeBattleState) {
                    this.currentPos = this.beforeBattleState.currentPos;
                    this.souls = [...this.beforeBattleState.souls];
                    this.conqueredNodes = new Set(this.beforeBattleState.conqueredNodes);
                    this.friendlyNodes = new Set(this.beforeBattleState.friendlyNodes);
                    this.soulModes = [...this.beforeBattleState.soulModes];
                    this.soulBuffTurns = [...this.beforeBattleState.soulBuffTurns];
                    
                    this.updateSoulDisplay();
                    this.updateSoulCount();
                    this.updateUI();
                    this.renderMap();
                }
            }
            
            async startBattle() {
                if (!this.selectedTarget) {
                    console.error('æ²¡æœ‰é€‰æ‹©çš„æˆ˜æ–—ç›®æ ‡');
                    return;
                }
                
                console.log('å¼€å§‹ä¸ç›®æ ‡çš„æˆ˜æ–—:', this.selectedTarget);
                
                this.saveBeforeBattleState();
                this.battleInProgress = true;
                
                const playerUnits = [this.heroUnit];
                const releasedSoulIndices = [];
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'release') {
                        playerUnits.push(soul);
                        releasedSoulIndices.push(index);
                    }
                });
                
                const enemyNodes = this.getBattleEnemies(this.selectedTarget);
                
                console.log('æˆ‘æ–¹å•ä½:', playerUnits);
                console.log('æ•Œæ–¹å•ä½:', enemyNodes);
                
                await this.showBattleModal(playerUnits, enemyNodes);
                
                const result = await this.numbercraftBattle(playerUnits, enemyNodes);
                
                if (result.winner === 'X') {
                    this.onBattleWin(this.selectedTarget, enemyNodes, releasedSoulIndices);
                } else {
                    this.onBattleLose();
                }
                
                this.selectedTarget = null;
                this.battleInProgress = false;
            }
            
            getBattleEnemies(targetNode) {
                const enemies = [targetNode];
                const additionalCount = this.getAdditionalEnemyCount(targetNode);
                
                let availableNeighbors = this.adjacencyList[targetNode].filter(n => 
                    n !== this.currentPos && !this.friendlyNodes.has(n)
                );
                
                if (availableNeighbors.length < additionalCount) {
                    const distance2Neighbors = new Set();
                    availableNeighbors.forEach(neighbor => {
                        this.adjacencyList[neighbor].forEach(n => {
                            if (n !== targetNode && n !== this.currentPos && !this.friendlyNodes.has(n)) {
                                distance2Neighbors.add(n);
                            }
                        });
                    });
                    availableNeighbors = [...availableNeighbors, ...distance2Neighbors];
                }
                
                for (let i = 0; i < additionalCount && i < availableNeighbors.length; i++) {
                    const randomIndex = Math.floor(Math.random() * availableNeighbors.length);
                    const enemy = availableNeighbors.splice(randomIndex, 1)[0];
                    enemies.push(enemy);
                }
                
                return enemies;
            }
            
            getAdditionalEnemyCount(node) {
                if (node < 50) return 0;
                if (node < 100) return 1;
                if (node < 200) return 2;
                return 3;
            }
            
            async showBattleModal(playerUnits, enemyUnits) {
                console.log('æ˜¾ç¤ºæˆ˜æ–—æ¨¡æ€æ¡†');
                const modal = document.getElementById('battleModal');
                
                const speedTexts = {0.5: 'æ…¢é€Ÿ', 1: 'æ­£å¸¸', 1.5: 'å¿«é€Ÿ', 2: 'æå¿«'};
                document.getElementById('battleSpeedDisplay').textContent = speedTexts[this.battleSpeed];
                
                const playerDiv = document.getElementById('playerBattleUnits');
                const enemyDiv = document.getElementById('enemyBattleUnits');
                
                playerDiv.innerHTML = '';
                enemyDiv.innerHTML = '';
                
                playerUnits.forEach((unit, index) => {
                    const div = document.createElement('div');
                    div.className = 'battle-unit player';
                    div.textContent = unit;
                    div.id = `battle-player-${unit}-${index}`;
                    playerDiv.appendChild(div);
                });
                
                enemyUnits.forEach((unit, index) => {
                    const div = document.createElement('div');
                    div.className = 'battle-unit enemy';
                    div.textContent = unit;
                    div.id = `battle-enemy-${unit}-${index}`;
                    enemyDiv.appendChild(div);
                });
                
                modal.style.display = 'flex';
                console.log('æˆ˜æ–—æ¨¡æ€æ¡†ç°åœ¨åº”è¯¥å¯è§');
                
                await this.delay(300 / this.battleSpeed);
            }
            
            async numbercraftBattle(groupX, groupY) {
                let aliveX = [...groupX];
                let aliveY = [...groupY];
                let consecutiveWinsX = 0;
                let consecutiveWinsY = 0;
                let turn = 2;
                
                while (aliveX.length > 0 && aliveY.length > 0) {
                    document.getElementById('turnDisplay').textContent = `å›åˆ ${turn}`;
                    
                    let maxX = Math.max(...aliveX.map(x => x % turn));
                    let maxXUnit = aliveX.find(x => x % turn === maxX);
                    
                    let soulBonus = 0;
                    let bonusSoul = null;
                    this.souls.forEach((soul, index) => {
                        if (this.soulModes[index] === 'buff' && this.soulBuffTurns[index] === turn) {
                            const soulValue = soul % turn;
                            if (soulValue > maxX) {
                                maxX = soulValue;
                                maxXUnit = this.heroUnit;
                                soulBonus = soulValue;
                                bonusSoul = soul;
                            }
                        }
                    });
                    
                    const maxY = Math.max(...aliveY.map(y => y % turn));
                    const maxYUnit = aliveY.find(y => y % turn === maxY);
                    
                    await this.showTurnEffects(maxXUnit, maxYUnit, maxX, maxY, bonusSoul, turn);
                    
                    if (maxX > maxY) {
                        consecutiveWinsX++;
                        consecutiveWinsY = 0;
                    } else if (maxY > maxX) {
                        consecutiveWinsY++;
                        consecutiveWinsX = 0;
                    } else {
                        consecutiveWinsX = 0;
                        consecutiveWinsY = 0;
                    }
                    
                    if (consecutiveWinsX === 3) {
                        const randomIndex = Math.floor(Math.random() * aliveY.length);
                        const eliminated = aliveY[randomIndex];
                        aliveY.splice(randomIndex, 1);
                        await this.eliminateUnit('enemy', eliminated, randomIndex);
                        consecutiveWinsX = 0;
                    } else if (consecutiveWinsY === 3) {
                        // ç©å®¶é˜µäº¡é¡ºåºï¼šé­‚é‡Šæ”¾é¡ºåºï¼Œä¸»è§’æœ€å
                        let eliminatedIndex = -1;
                        let eliminated = null;
                        
                        // ä¼˜å…ˆæ¶ˆç­é‡Šæ”¾çš„é­‚ï¼ˆæŒ‰é‡Šæ”¾é¡ºåºï¼‰
                        for (let i = 0; i < aliveX.length; i++) {
                            if (aliveX[i] !== this.heroUnit) {
                                eliminatedIndex = i;
                                eliminated = aliveX[i];
                                break;
                            }
                        }
                        
                        // å¦‚æœæ²¡æœ‰é­‚ï¼Œåˆ™æ¶ˆç­ä¸»è§’
                        if (eliminatedIndex === -1) {
                            eliminatedIndex = aliveX.indexOf(this.heroUnit);
                            eliminated = this.heroUnit;
                        }
                        
                        if (eliminatedIndex !== -1) {
                            aliveX.splice(eliminatedIndex, 1);
                            await this.eliminateUnit('player', eliminated, eliminatedIndex);
                        }
                        consecutiveWinsY = 0;
                    }
                    
                    turn++;
                    await this.delay(800 / this.battleSpeed); // è°ƒå¿«æˆ˜æ–—é€Ÿåº¦
                }
                
                const result = aliveX.length > 0 ? 'X' : 'Y';
                await this.showBattleResult(result);
                
                return {winner: result, finalTurn: turn};
            }
            
            async showTurnEffects(playerUnit, enemyUnit, playerValue, enemyValue, bonusSoul, turn) {
                const playerUnitEl = document.querySelector(`#battle-player-${playerUnit}-0`) || 
                                   document.querySelector(`[id^="battle-player-${playerUnit}-"]`);
                const enemyUnitEl = document.querySelector(`#battle-enemy-${enemyUnit}-0`) || 
                                  document.querySelector(`[id^="battle-enemy-${enemyUnit}-"]`);
                
                if (playerValue > enemyValue && playerUnitEl) {
                    playerUnitEl.classList.add('winner');
                } else if (enemyValue > playerValue && enemyUnitEl) {
                    enemyUnitEl.classList.add('winner');
                }
                
                if (playerUnitEl) {
                    this.showFloatingNumber(playerUnitEl, playerValue);
                }
                if (enemyUnitEl) {
                    this.showFloatingNumber(enemyUnitEl, enemyValue);
                }
                
                // å¢å¼ºé­‚å¢ç›Šç‰¹æ•ˆ - æ˜¾ç¤ºåœ¨æˆ˜æ–—åœºæ™¯ä¸­ï¼Œè€Œä¸æ˜¯æ•°å­—å†…éƒ¨
                if (bonusSoul && playerUnitEl) {
                    // è·å–æˆ˜æ–—åœºæ™¯å®¹å™¨
                    const battleField = document.querySelector('.battle-field');
                    const unitRect = playerUnitEl.getBoundingClientRect();
                    const fieldRect = battleField.getBoundingClientRect();
                    
                    // åœ¨æ•°å­—å•ä½ä¸Šæ–¹æ˜¾ç¤ºé­‚å¢ç›Šå…‰ç¯
                    const soulAura = document.createElement('div');
                    soulAura.style.cssText = `
                        position: absolute;
                        left: ${unitRect.left - fieldRect.left - 10}px;
                        top: ${unitRect.top - fieldRect.top - 10}px;
                        width: ${unitRect.width + 20}px;
                        height: ${unitRect.height + 20}px;
                        border: 3px solid #55e285;
                        border-radius: 15px;
                        background: radial-gradient(circle, rgba(85, 226, 133, 0.3) 0%, transparent 70%);
                        z-index: 100;
                        pointer-events: none;
                        animation: soulAura 1.5s ease;
                    `;
                    
                    // æ˜¾ç¤ºé­‚æ•°å­—æ ‡è¯† - æµ®åœ¨æ•°å­—ä¸Šæ–¹
                    const soulIndicator = document.createElement('div');
                    soulIndicator.style.cssText = `
                        position: absolute;
                        left: ${unitRect.left - fieldRect.left + unitRect.width/2 - 40}px;
                        top: ${unitRect.top - fieldRect.top - 50}px;
                        width: 80px;
                        background: linear-gradient(135deg, #55e285 0%, #45c275 100%);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: bold;
                        z-index: 200;
                        box-shadow: 0 4px 15px rgba(85, 226, 133, 0.6);
                        animation: soulBonus 1.5s ease;
                        pointer-events: none;
                        text-align: center;
                    `;
                    soulIndicator.textContent = `é­‚ ${bonusSoul}`;
                    
                    // æ·»åŠ åŠ¨ç”»æ ·å¼ï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
                    if (!document.getElementById('soulEffectStyles')) {
                        const style = document.createElement('style');
                        style.id = 'soulEffectStyles';
                        style.textContent = `
                            @keyframes soulAura {
                                0% { 
                                    opacity: 0; 
                                    transform: scale(0.5); 
                                    border-color: #55e285;
                                }
                                30% { 
                                    opacity: 1; 
                                    transform: scale(1.1); 
                                    border-color: #7af2a5;
                                }
                                70% { 
                                    opacity: 0.8; 
                                    transform: scale(1); 
                                    border-color: #55e285;
                                }
                                100% { 
                                    opacity: 0; 
                                    transform: scale(1.2); 
                                    border-color: #3ad975;
                                }
                            }
                            @keyframes soulBonus {
                                0% { 
                                    opacity: 0; 
                                    transform: translateY(20px) scale(0.5); 
                                }
                                30% { 
                                    opacity: 1; 
                                    transform: translateY(-5px) scale(1.2); 
                                }
                                70% { 
                                    opacity: 1; 
                                    transform: translateY(0) scale(1); 
                                }
                                100% { 
                                    opacity: 0; 
                                    transform: translateY(-15px) scale(0.8); 
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // æ·»åŠ åˆ°æˆ˜æ–—åœºæ™¯ä¸­
                    battleField.appendChild(soulAura);
                    battleField.appendChild(soulIndicator);
                    
                    // æ¸…ç†ç‰¹æ•ˆ
                    setTimeout(() => {
                        if (soulAura.parentNode) {
                            soulAura.parentNode.removeChild(soulAura);
                        }
                        if (soulIndicator.parentNode) {
                            soulIndicator.parentNode.removeChild(soulIndicator);
                        }
                    }, 1500 / this.battleSpeed);
                }
                
                await this.delay(600 / this.battleSpeed);
                
                document.querySelectorAll('.winner').forEach(el => {
                    el.classList.remove('winner');
                });
            }
            
            showFloatingNumber(element, value) {
                const number = document.createElement('div');
                number.className = 'damage-number';
                number.textContent = value;
                
                const rect = element.getBoundingClientRect();
                number.style.left = rect.left + rect.width/2 - 10 + 'px';
                number.style.top = rect.top - 10 + 'px';
                number.style.position = 'fixed';
                number.style.zIndex = '3000';
                number.style.animationDuration = (1 / this.battleSpeed) + 's';
                
                document.body.appendChild(number);
                
                setTimeout(() => {
                    if (number.parentNode) {
                        number.parentNode.removeChild(number);
                    }
                }, 1000 / this.battleSpeed);
            }
            
            async eliminateUnit(team, unit, index) {
                const unitEl = document.querySelector(`#battle-${team}-${unit}-${index}`) ||
                             document.querySelector(`[id^="battle-${team}-${unit}-"]`);
                if (unitEl) {
                    unitEl.classList.add('eliminated');
                }
                await this.delay(400 / this.battleSpeed);
            }
            
            async showBattleResult(winner) {
                const display = document.getElementById('turnDisplay');
                if (winner === 'X') {
                    display.textContent = 'ğŸ‰ èƒœåˆ©ï¼';
                    display.style.borderColor = '#4a90e2';
                } else {
                    display.textContent = 'ğŸ’€ å¤±è´¥...';
                    display.style.borderColor = '#e24a4a';
                }
                
                const closeBtn = document.getElementById('closeBattleBtn');
                closeBtn.style.display = 'block';
                
                await new Promise(resolve => {
                    closeBtn.onclick = () => {
                        document.getElementById('battleModal').style.display = 'none';
                        closeBtn.style.display = 'none';
                        resolve();
                    };
                });
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            onBattleWin(targetNode, enemies, releasedSoulIndices) {
                this.battleCount++;
                
                if (this.battleCount % 10 === 0 && this.stealthCount < 3) {
                    this.stealthCount++;
                }
                
                releasedSoulIndices.sort((a, b) => b - a).forEach(index => {
                    const soul = this.souls[index];
                    this.souls.splice(index, 1);
                    this.soulModes.splice(index, 1);
                    this.soulBuffTurns.splice(index, 1);
                });
                
                this.conqueredNodes.add(targetNode);
                this.currentPos = targetNode;
                this.collectSoul(targetNode);
                
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
                this.updateUI();
                this.renderMap();
                
                if (targetNode === this.bossNode) {
                    this.onGameWin();
                }
            }
            
            onBattleLose() {
                setTimeout(() => {
                    this.restoreBeforeBattleState();
                }, 800 / this.battleSpeed);
            }
            
            collectSoul(node) {
                if (this.souls.length < this.maxSouls) {
                    this.souls.push(node);
                    this.soulModes.push('none');
                    this.soulBuffTurns.push(3);
                    this.updateSoulDisplay();
                    this.updateSoulCount();
                    this.updateFriendlyNodes();
                }
            }
            
            updateSoulDisplay() {
                const container = document.getElementById('soulSimpleList');
                container.innerHTML = '';
                
                for (let i = 0; i < this.maxSouls; i++) {
                    const item = document.createElement('div');
                    item.className = 'soul-simple-item';
                    
                    if (i < this.souls.length) {
                        const soul = this.souls[i];
                        const mode = this.soulModes[i];
                        
                        item.classList.add(mode);
                        item.textContent = soul;
                    } else {
                        item.classList.add('empty');
                        item.textContent = '-';
                    }
                    
                    container.appendChild(item);
                }
            }
            
            updateSoulCount() {
                document.getElementById('soulCount').textContent = `${this.souls.length}/${this.maxSouls}`;
            }
            
showSoulConfig() {
    document.getElementById('heroTimeline').textContent = this.heroUnit;
    this.renderSoulCards();
    this.renderTimeline();
    
    // åªåœ¨ç¬¬ä¸€æ¬¡æ‰“å¼€æ—¶æ·»åŠ åŒºåŸŸç›‘å¬å™¨
    if (!this.zoneListenersAdded) {
        this.addZoneDropListeners();
        this.zoneListenersAdded = true;
    }
    
    document.getElementById('soulConfigModal').style.display = 'flex';
}
            
            renderSoulCards() {
                const waitingZone = document.getElementById('waitingSouls');
                const releaseZone = document.getElementById('releaseSouls');
                
                waitingZone.innerHTML = '';
                releaseZone.innerHTML = '';
                
                this.souls.forEach((soul, index) => {
                    const card = this.createSoulCard(soul, index);
                    
                    if (this.soulModes[index] === 'release') {
                        releaseZone.appendChild(card);
                    } else if (this.soulModes[index] === 'none') {
                        waitingZone.appendChild(card);
                    }
                });
            }
            
            createSoulCard(soul, index) {
                const card = document.createElement('div');
                card.className = 'soul-card';
                card.draggable = true;
                card.dataset.soulIndex = index;
                card.dataset.soulValue = soul;
                
                const mode = this.soulModes[index];
                if (mode === 'release') {
                    card.classList.add('in-release');
                } else if (mode === 'buff') {
                    card.classList.add('in-timeline');
                }
                
                card.innerHTML = `
                    <div class="soul-number">${soul}</div>
                    <div class="soul-mode-indicator">${this.getModeText(mode)}</div>
                `;
                
                this.addDragListeners(card);
                return card;
            }
            
            getModeText(mode) {
                switch(mode) {
                    case 'release': return 'é‡Šæ”¾';
                    case 'buff': return 'å¢ç›Š';
                    default: return 'ç­‰å¾…';
                }
            }
            
            renderTimeline() {
                const turnsContainer = document.getElementById('timelineTurns');
                turnsContainer.innerHTML = '';
                
                for (let turn = 2; turn <= 100; turn++) {
                    const turnDiv = document.createElement('div');
                    turnDiv.className = 'timeline-turn';
                    turnDiv.dataset.turn = turn;
                    
                    const heroValue = this.heroUnit % turn;
                    
                    turnDiv.innerHTML = `
                        <div class="timeline-turn-number">T${turn}</div>
                        <div class="timeline-hero-value">${heroValue}</div>
                        <div class="timeline-soul-slot" data-turn="${turn}"></div>
                    `;
                    
                    turnsContainer.appendChild(turnDiv);
                    this.addTimelineDropListeners(turnDiv);
                }
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'buff') {
                        this.placeSoulOnTimeline(soul, index, this.soulBuffTurns[index]);
                    }
                });
            }
            
            addTimelineDropListeners(element) {
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    element.classList.add('drop-zone');
                });
                
                element.addEventListener('dragleave', () => {
                    element.classList.remove('drop-zone');
                });
                
                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    element.classList.remove('drop-zone');
                    
                    const soulIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const turn = parseInt(element.dataset.turn);
                    
                    if (turn && !isNaN(soulIndex)) {
                        this.setSoulMode(soulIndex, 'buff');
                        this.setSoulBuffTurn(soulIndex, turn);
                        this.refreshSoulConfig();
                    }
                });
            }
            
            addZoneDropListeners() {
                const zones = document.querySelectorAll('.soul-cards');
                zones.forEach(zone => {
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        zone.parentElement.style.borderColor = '#4a90e2';
                    });
                    
                    zone.addEventListener('dragleave', () => {
                        zone.parentElement.style.borderColor = '';
                    });
                    
                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.parentElement.style.borderColor = '';
                        
                        const soulIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const isReleaseZone = zone.id === 'releaseSouls';
                        
                        if (!isNaN(soulIndex)) {
                            if (isReleaseZone) {
                                this.setSoulMode(soulIndex, 'release');
                            } else {
                                this.setSoulMode(soulIndex, 'none');
                            }
                            this.refreshSoulConfig();
                        }
                    });
                });
            }
            
            placeSoulOnTimeline(soul, index, turn) {
                const slot = document.querySelector(`[data-turn="${turn}"] .timeline-soul-slot`);
                if (slot && !slot.classList.contains('occupied')) {
                    slot.classList.add('occupied');
                    slot.innerHTML = `
                        <div class="timeline-soul-card" data-soul-index="${index}" title="ç‚¹å‡»ç§»é™¤">
                            ${soul}
                        </div>
                    `;
                    
                    const soulCard = slot.querySelector('.timeline-soul-card');
                    if (soulCard) {
                        soulCard.addEventListener('click', () => {
                            this.removeSoulFromTimeline(index);
                        });
                    }
                }
            }
            
            addDragListeners(card) {
                card.addEventListener('dragstart', (e) => {
                    card.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', card.dataset.soulIndex);
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                });
            }
            
            refreshSoulConfig() {
                this.renderSoulCards();
                this.renderTimeline();
                this.updateSoulDisplay();
            }
            
            removeSoulFromTimeline(index) {
                const existingSoulCard = document.querySelector(`[data-soul-index="${index}"]`);
                if (existingSoulCard) {
                    const slot = existingSoulCard.parentElement;
                    slot.classList.remove('occupied');
                    slot.innerHTML = '';
                }
                
                this.setSoulMode(index, 'none');
                this.refreshSoulConfig();
            }
            
            closeSoulConfig() {
                document.getElementById('soulConfigModal').style.display = 'none';
            }
            
            setSoulMode(index, mode) {
                this.soulModes[index] = mode;
                if (mode === 'buff' && !this.soulBuffTurns[index]) {
                    this.soulBuffTurns[index] = 3;
                }
                this.updateSoulDisplay();
            }
            
            setSoulBuffTurn(index, turn) {
                this.soulBuffTurns[index] = parseInt(turn);
            }
            
            removeSoulBuff(index) {
                this.soulModes[index] = 'none';
                this.refreshSoulConfig();
            }
            
            showSettings() {
                document.getElementById('settingsModal').style.display = 'flex';
            }
            
            closeSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }
            
            showHelp() {
                document.getElementById('helpModal').style.display = 'flex';
            }
            
            closeHelp() {
                document.getElementById('helpModal').style.display = 'none';
            }
            
            updateUI() {
                document.getElementById('currentPos').textContent = this.currentPos;
                document.getElementById('battleCount').textContent = this.battleCount;
                document.getElementById('stealthCount').textContent = this.stealthCount;
            }
            
            onGameWin() {
                setTimeout(() => {
                    alert('ğŸ‰ æ­å–œï¼ä½ å‡»è´¥äº†BOSSï¼Œæˆä¸ºäº†çœŸæ­£çš„Soul Mageï¼\n\nä¼ å¥‡å°†æ°¸è¿œæµä¼ ï¼');
                    location.reload();
                }, 2000);
            }
            
            setupEventListeners() {
                document.querySelectorAll('.scenario-option:not(.custom-scenario)').forEach(option => {
                    option.addEventListener('click', (e) => {
                        const hero = parseInt(e.currentTarget.dataset.hero);
                        const boss = parseInt(e.currentTarget.dataset.boss);
                        this.startGame(hero, boss);
                    });
                });
                
                document.getElementById('startCustomBtn').addEventListener('click', () => {
                    const hero = parseInt(document.getElementById('customHero').value);
                    const boss = parseInt(document.getElementById('customBoss').value);
                    if (hero && boss && hero !== boss) {
                        this.startGame(hero, boss);
                    }
                });
                
                document.getElementById('configureSoulsBtn').addEventListener('click', () => {
                    this.showSoulConfig();
                });
                
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.showSettings();
                });
                
                document.getElementById('campaignModeBtn').addEventListener('click', () => {
                    this.startCampaignMode();
                });
                
                document.getElementById('closeSoulConfigBtn').addEventListener('click', () => {
                    this.closeSoulConfig();
                });
                
                document.getElementById('closeActionModalBtn').addEventListener('click', () => {
                    this.closeActionModal();
                });
                
                document.getElementById('closeSettingsBtn').addEventListener('click', () => {
                    this.closeSettings();
                });
                
                document.getElementById('closeHelpBtn').addEventListener('click', () => {
                    this.closeHelp();
                });
                
                document.getElementById('battleActionBtn').addEventListener('click', () => {
                    const target = this.selectedTarget;
                    this.closeActionModal();
                    if (target) {
                        this.selectedTarget = target;
                        this.startBattle();
                    }
                });
                
                document.getElementById('moveActionBtn').addEventListener('click', () => {
                    const target = this.selectedTarget;
                    this.closeActionModal();
                    if (target) {
                        this.moveToNode(target);
                    }
                });
                
                document.getElementById('stealthActionBtn').addEventListener('click', () => {
                    const target = this.selectedTarget;
                    this.closeActionModal();
                    if (target && this.stealthCount > 0) {
                        this.stealthMove(target);
                    }
                });
                
                document.getElementById('campaignActionBtn').addEventListener('click', () => {
                    this.closeActionModal();
                    this.campaignTargets = [this.selectedTarget];
                    this.startCampaignMode();
                });
                
                document.getElementById('battleSpeedSelect').addEventListener('change', (e) => {
                    this.battleSpeed = parseFloat(e.target.value);
                });
                
                document.getElementById('viewRangeSlider').addEventListener('input', (e) => {
                    this.viewRange = parseInt(e.target.value);
                    document.getElementById('viewRange').textContent = this.viewRange;
                    this.renderMap();
                });
                
                document.getElementById('soundToggle').addEventListener('change', (e) => {
                    this.soundEnabled = e.target.checked;
                });
                
                document.getElementById('debugToggle').addEventListener('change', (e) => {
                    this.debugMode = e.target.checked;
                    this.updateDebugInfo();
                });
                
                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.zoom = Math.min(this.zoom * 1.2, 3);
                    this.renderMap();
                });
                
                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.zoom = Math.max(this.zoom / 1.2, 0.5);
                    this.renderMap();
                });
                
                document.getElementById('centerBtn').addEventListener('click', () => {
                    this.panX = 0;
                    this.panY = 0;
                    this.zoom = 1;
                    this.renderMap();
                });
                
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.showHelp();
                });
            }
            
            startGame(hero, boss) {
                this.heroUnit = hero;
                this.bossNode = boss;
                this.currentPos = hero;
                this.conqueredNodes.add(hero);
                this.updateFriendlyNodes();
                
                document.getElementById('heroUnit').textContent = hero;
                document.getElementById('currentPos').textContent = this.currentPos;
                document.getElementById('bossTarget').textContent = boss;
                document.getElementById('gameOverlay').style.display = 'none';
                
                setTimeout(() => this.renderMap(), 100);
            }
        }
        
        // å…¨å±€å®ä¾‹
        let gameInstance;
        
        window.addEventListener('DOMContentLoaded', () => {
            gameInstance = new SoulMageGame();
            window.gameInstance = gameInstance;
        });
    </script>
</body>
</html>
