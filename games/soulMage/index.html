<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Mage - 数字魂战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 全局隐藏滚动条 */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        html, body {
            overflow: hidden !important;
            height: 100vh !important;
            width: 100vw !important;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #050510 0%, #1a1a3e 50%, #0f1b3c 100%);
            color: #e0e0e0;
            overflow: hidden;
            position: relative;
        }
        
        html {
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(74, 144, 226, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
            pointer-events: none;
            z-index: -1;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
        }
        
        #mapContainer {
            flex: 1;
            background: rgba(15, 15, 35, 0.9);
            position: relative;
            min-width: 0;
            border: 2px solid #2a2a5e;
            border-radius: 12px 0 0 12px;
            box-shadow: inset 0 0 50px rgba(138, 43, 226, 0.1);
        }
        
        #mapSvg {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px 0 0 10px;
        }
        
        #sidePanel {
            width: 350px;
            background: linear-gradient(180deg, #1a1a3e 0%, #0f1b3c 100%);
            border: 2px solid #2a2a5e;
            border-left: none;
            border-radius: 0 12px 12px 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.2);
        }
        
        .panel-header {
            background: linear-gradient(90deg, #5d3fd3 0%, #4a2db1 100%);
            padding: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 2px 8px rgba(138, 43, 226, 0.5);
            border-bottom: 2px solid #2a2a5e;
        }
        
        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel-section {
            background: rgba(32, 32, 48, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(5px);
        }
        
        .section-title {
            color: #9d78ff;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(157, 120, 255, 0.5);
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }
        
        .status-item {
            background: rgba(0,0,0,0.3);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-value {
            color: #e2a855;
            font-weight: bold;
        }
        
        .soul-simple-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
            min-height: 60px;
            align-items: flex-start;
            align-content: flex-start;
        }
        
        .soul-simple-item {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            position: relative;
        }
        
        .soul-simple-item.empty {
            opacity: 0.3;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
        }
        
        .soul-simple-item.release {
            border-color: #e2a855;
            background: linear-gradient(135deg, #3a3025 0%, #2a2015 100%);
        }
        
        .soul-simple-item.buff {
            border-color: #55e285;
            background: linear-gradient(135deg, #253a30 0%, #152a20 100%);
        }
        
        .game-button {
            background: linear-gradient(135deg, #5d3fd3 0%, #4a2db1 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.3);
            width: 100%;
            margin: 3px 0;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #7050e3 0%, #5a3dc1 100%);
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.4);
        }
        
        .game-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        
        
        /* 弹窗基础样式 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a3e 0%, #0f1b3c 100%);
            border: 3px solid #5d3fd3;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.3);
        }
        
        .modal-header {
            background: linear-gradient(90deg, #5d3fd3 0%, #4a2db1 100%);
            padding: 15px 20px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            text-shadow: 0 2px 8px rgba(138, 43, 226, 0.5);
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s;
        }
        
        .modal-close:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .modal-body {
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        /* 魂配置界面 */
        .soul-config-container {
            width: 95vw;
            max-width: 1200px;
            height: 85vh;
        }
        
        .soul-management {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 20px;
            overflow: visible;
        }
        
        .soul-zones {
            display: flex;
            gap: 20px;
            height: 305px;
        }
        
        .soul-zone {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #444;
            overflow: visible;
            padding-top: 20px;
        }
        
        .soul-zone h3 {
            color: #4a90e2;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .waiting-zone {
            border-color: #666;
        }
        
        .release-zone {
            border-color: #e2a855;
            background: rgba(226, 168, 85, 0.05);
        }
        
        .release-zone h3 {
            color: #e2a855;
        }
        
        .soul-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 230px;
            align-content: flex-start;
            overflow-y: auto;
            overflow-x: visible;
            max-height: 230px;
            position: relative;
            padding-top: 8px;
            margin-top: -8px;
        }
        
        .soul-card {
            width: 50px;
            height: 65px;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            z-index: 10;
            position: relative;
            user-select: none;
        }
        
        .soul-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            border-color: #4a90e2;
        }
        
        .soul-card.dragging {
            cursor: grabbing;
            transform: rotate(5deg) scale(1.1);
            z-index: 1000;
            opacity: 0.8;
            visibility: visible !important;
        }
        
        .soul-card.drag-source-hidden {
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.1s ease;
        }
        
        .soul-card.in-release {
            border-color: #e2a855;
            background: linear-gradient(135deg, #3a3025 0%, #2a2015 100%);
        }
        
        .soul-card.in-timeline {
            border-color: #55e285;
            background: linear-gradient(135deg, #253a30 0%, #152a20 100%);
        }
        
        .soul-number {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 3px;
        }
        
        .soul-mode-indicator {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .soul-mage-divider {
            text-align: center;
            margin: 30px 0;
            font-size: 48px;
            font-weight: bold;
            letter-spacing: 8px;
            background: linear-gradient(45deg, #4a90e2, #e2a855, #55e285, #e24a4a, #4a90e2);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
            position: relative;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .timeline-container {
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
            height: 200px;
            overflow: visible;
        }
        
        .timeline-scroll {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            border: 1px solid #333;
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 rgba(0,0,0,0.3);
        }
        
        .timeline-scroll::-webkit-scrollbar {
            height: 8px;
        }
        
        .timeline-scroll::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        
        .timeline-scroll::-webkit-scrollbar-thumb {
            background: #4a90e2;
            border-radius: 4px;
        }
        
        .timeline-scroll::-webkit-scrollbar-thumb:hover {
            background: #5aa0f2;
        }
        
        .timeline-track {
            display: flex;
            align-items: center;
            height: 100%;
            min-width: 100%;
            padding: 10px;
            gap: 5px;
        }
        
        .timeline-label {
            min-width: 80px;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            font-weight: bold;
        }
        
        .timeline-turns {
            display: flex;
            gap: 3px;
            flex: 1;
        }
        
        .timeline-turn {
            min-width: 80px;
            height: 90px;
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 6px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .timeline-turn.drop-zone {
            border-color: #55e285;
            background: rgba(85, 226, 133, 0.1);
        }
        
        .timeline-turn-number {
            font-size: 11px;
            font-weight: bold;
            color: #4a90e2;
        }
        
        .timeline-hero-value {
            font-size: 16px;
            color: #fff;
            font-weight: bold;
        }
        
        .timeline-soul-slot {
            width: 55px;
            height: 70px;
            border: 2px dashed #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            padding: 3px;
            box-sizing: border-box;
        }
        
        .timeline-soul-slot.occupied {
            border-style: solid;
            border-color: #55e285;
            background: rgba(85, 226, 133, 0.1);
        }
        
        .timeline-soul-card {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #3a5a42 0%, #2a4a32 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #cccccc;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 2px;
        }
        
        .timeline-soul-card:hover {
            transform: scale(1.1);
        }
        
        .scroll-hint {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* 行动选择弹窗 */
        .action-modal {
            width: 450px;
            height: 480px;
        }
        
        .action-content {
            text-align: center;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .target-display {
            font-size: 24px;
            color: #e2a855;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
        }
        
        .action-button {
            padding: 15px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .action-button.battle {
            background: linear-gradient(135deg, #e24a4a 0%, #c73a3a 100%);
            color: white;
        }
        
        .action-button.move {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
        }
        
        .action-button.stealth {
            background: linear-gradient(135deg, #6a4c93 0%, #553a73 100%);
            color: white;
        }
        
        .action-button.campaign {
            background: linear-gradient(135deg, #e2a855 0%, #c49545 100%);
            color: white;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .action-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }
        
        .campaign-panel {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.95) 0%, rgba(10, 10, 20, 0.95) 100%);
            border: 1px solid #5d3fd3;
            border-radius: 8px;
            color: white;
            z-index: 100;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            padding: 10px 20px;
            gap: 20px;
            font-size: 14px;
        }
        
        .campaign-stat {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .campaign-stat span:first-child {
            color: #aaa;
        }
        
        .campaign-stat span:last-child {
            color: #e2a855;
            font-weight: bold;
        }
        
        .campaign-actions {
            display: flex;
            gap: 10px;
        }
        
        .campaign-button {
            background: linear-gradient(135deg, #5d3fd3 0%, #4a2db1 100%);
            border: 1px solid #5d3fd3;
            color: white;
            padding: 6px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .campaign-button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 2px 10px rgba(93, 63, 211, 0.4);
        }
        
        .campaign-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .campaign-button.launch {
            background: linear-gradient(135deg, rgba(85, 226, 133, 0.3) 0%, rgba(75, 216, 123, 0.3) 100%);
            border-color: #55e285;
        }
        
        .campaign-button.launch:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(85, 226, 133, 0.5) 0%, rgba(75, 216, 123, 0.5) 100%);
            box-shadow: 0 2px 10px rgba(85, 226, 133, 0.4);
        }
        
        .campaign-button.cancel {
            background: linear-gradient(135deg, rgba(226, 74, 74, 0.3) 0%, rgba(206, 54, 54, 0.3) 100%);
            border-color: #e24a4a;
        }
        
        .campaign-button.cancel:hover {
            background: linear-gradient(135deg, rgba(226, 74, 74, 0.5) 0%, rgba(206, 54, 54, 0.5) 100%);
            box-shadow: 0 2px 10px rgba(226, 74, 74, 0.4);
        }
        
        /* 节点上下文菜单 */
        .node-context-menu {
            position: fixed;
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.98) 0%, rgba(10, 10, 20, 0.98) 100%);
            border: 1px solid #4a90e2;
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), 0 0 20px rgba(74, 144, 226, 0.3);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(10px);
        }
        
        .context-menu-item {
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            white-space: nowrap;
        }
        
        .context-menu-item:hover {
            background: rgba(74, 144, 226, 0.3);
            transform: translateX(3px);
        }
        
        .context-menu-item.battle {
            color: #e24a4a;
        }
        
        .context-menu-item.battle:hover {
            background: rgba(226, 74, 74, 0.3);
        }
        
        .context-menu-item.move {
            color: #55e285;
        }
        
        .context-menu-item.move:hover {
            background: rgba(85, 226, 133, 0.3);
        }
        
        .context-menu-item.campaign {
            color: #e2a855;
        }
        
        .context-menu-item.campaign:hover {
            background: rgba(226, 168, 85, 0.3);
        }
        
        @keyframes campaignPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(226, 168, 85, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(226, 168, 85, 0.6);
            }
        }
        
        /* 战役模式样式 */
        .campaign-mode .node {
            transition: all 0.3s ease;
        }
        
        .campaign-mode .node:hover circle {
            r: 28 !important;
            filter: drop-shadow(0 0 10px #e2a855) !important;
        }
        
        .campaign-selectable {
            stroke: #e2a855 !important;
            stroke-width: 3 !important;
            stroke-dasharray: 8,4 !important;
            animation: selectablePulse 1.5s ease-in-out infinite !important;
        }
        
        @keyframes selectablePulse {
            0%, 100% { stroke-opacity: 0.6; }
            50% { stroke-opacity: 1; }
        }
        
        .campaign-selected {
            stroke: #e2a855 !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 15px #e2a855) !important;
        }
        
        .campaign-path {
            stroke: #e2a855 !important;
            stroke-width: 4 !important;
            stroke-dasharray: 10,5 !important;
            animation: campaignPathPulse 2s ease-in-out infinite !important;
        }
        
        @keyframes campaignPathPulse {
            0%, 100% { stroke-opacity: 0.6; }
            50% { stroke-opacity: 1; }
        }
        
        .campaign-info {
            position: absolute;
            top: 60px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e2a855;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }
        
        .campaign-counter {
            color: #e2a855;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .campaign-list {
            color: #ddd;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .campaign-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }
        
        .campaign-btn {
            padding: 5px 10px;
            font-size: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .campaign-btn.confirm {
            background: #e2a855;
            color: white;
        }
        
        .campaign-btn.cancel {
            background: #666;
            color: white;
        }
        
        .campaign-btn:hover {
            transform: translateY(-1px);
        }
        
        .campaign-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }
        
        /* 战斗弹窗 */
        .battle-arena {
            width: 90vw;
            max-width: 1000px;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .battle-field {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px;
            position: relative;
        }
        
        .battle-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .team-label {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .team-label.player {
            color: #4a90e2;
        }
        
        .team-label.enemy {
            color: #e24a4a;
        }
        
        .battle-units {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 300px;
        }
        
        .battle-unit {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 3px solid #5a5a5a;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .battle-unit.player {
            border-color: #4a90e2;
            color: #7ac0ff;
            background: linear-gradient(135deg, #2a3a4a 0%, #1a2a3a 100%);
        }
        
        .battle-unit.enemy {
            border-color: #e24a4a;
            color: #ff7a7a;
            background: linear-gradient(135deg, #4a2a2a 0%, #3a1a1a 100%);
        }
        
        .battle-unit.eliminated {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(100%);
        }
        
        .battle-unit.winner {
            animation: victoryPulse 0.6s ease;
            box-shadow: 0 0 20px currentColor;
        }
        
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .battle-vs {
            font-size: 36px;
            font-weight: bold;
            color: #e2a855;
            text-shadow: 0 0 10px rgba(226, 168, 85, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(226, 168, 85, 0.5); }
            to { text-shadow: 0 0 20px rgba(226, 168, 85, 0.8), 0 0 30px rgba(226, 168, 85, 0.4); }
        }
        
        .turn-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 2px solid #4a90e2;
        }
        
        .damage-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #e2a855;
            animation: floatUp 1s ease-out;
            pointer-events: none;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px);
            }
        }
        
        .soul-effect {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #55e285 0%, transparent 70%);
            border-radius: 50%;
            animation: soulGlow 0.4s ease;
        }
        
        @keyframes soulGlow {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        .battle-controls {
            padding: 15px;
            text-align: center;
            border-top: 1px solid #333;
            background: rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        /* 设置界面 */
        .settings-modal {
            width: 500px;
            height: 400px;
        }
        
        /* 帮助界面 */
        .help-modal {
            width: 800px;
            max-width: 90vw;
            height: 600px;
            max-height: 80vh;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #333;
        }
        
        .setting-slider {
            width: 200px;
        }
        
        /* 开始界面和开场动画 */
        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.98) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            overflow: auto;
            padding: 20px;
        }
        
        .game-modal {
            background: 
                linear-gradient(135deg, #202040 0%, #16213e 100%);
            padding: 20px 40px;
            border-radius: 15px;
            text-align: center;
            width: 100%;
            max-width: 1100px;
            height: 80vh;
            overflow-y: visible;
            box-shadow: none;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            mask: 
                linear-gradient(to right, transparent 0%, white 8%, white 92%, transparent 100%),
                linear-gradient(to bottom, transparent 0%, white 8%, white 92%, transparent 100%);
            mask-composite: intersect;
            -webkit-mask: 
                linear-gradient(to right, transparent 0%, white 8%, white 92%, transparent 100%),
                linear-gradient(to bottom, transparent 0%, white 8%, white 92%, transparent 100%);
            -webkit-mask-composite: source-in;
        }
        
        
        .modal-title {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #4a90e2;
        }
        
        
        .story-text {
            background: rgba(0,0,0,0.4);
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            line-height: 1.5;
            color: #ddd;
            border-left: 4px solid #4a90e2;
            position: relative;
            font-size: 14px;
        }
        
        
        .opening-animation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 1;
            transition: opacity 1s ease;
            overflow: hidden;
        }
        
        .opening-animation.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .opening-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(90deg, #4a90e2, #e24a4a, #55e285);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 2s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        .opening-subtitle {
            font-size: 18px;
            color: #bbb;
            margin-bottom: 40px;
            opacity: 0;
            animation: fadeIn 1s ease 1s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .opening-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #4a90e2;
            border-radius: 50%;
            animation: float 6s linear infinite;
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }
        
        .scenario-select {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            opacity: 0;
            animation: fadeInUp 1s ease 1.5s forwards;
        }
        
        .scenario-option {
            padding: 25px;
            background: linear-gradient(135deg, #3a3a5a 0%, #2a2a4a 100%);
            border: 3px solid #5a5a7a;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }
        
        .scenario-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.6s;
        }
        
        .scenario-option:hover {
            background: linear-gradient(135deg, #4a4a6a 0%, #3a3a5a 100%);
            border-color: #7a7a9a;
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        
        .scenario-option:hover::before {
            left: 100%;
        }
        
        .scenario-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #e2a855;
        }
        
        .scenario-desc {
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .custom-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }
        
        .custom-input {
            width: 90px;
            padding: 10px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.4);
            color: white;
            border-radius: 6px;
            text-align: center;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .custom-input:focus {
            border-color: #4a90e2;
            outline: none;
        }
        
        /* 地图样式 */
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover circle {
            r: 25;
        }
        
        .edge {
            stroke: #444;
            stroke-width: 2;
            opacity: 0.6;
        }
        
        .current-node {
            stroke: #4a90e2;
            stroke-width: 4;
            filter: drop-shadow(0 0 10px #4a90e2);
        }
        
        .boss-node {
            fill: #e24a4a;
            filter: drop-shadow(0 0 15px #e24a4a);
        }
        
        .friendly-node {
            fill: #4a90e2;
            filter: drop-shadow(0 0 8px #4a90e2);
        }
        
        .conquered-node {
            fill: #666;
            opacity: 0.7;
        }
        
        .reachable-node {
            stroke: #7ac0ff;
            stroke-width: 3;
            stroke-dasharray: 5,5;
            animation: reachablePulse 2s ease-in-out infinite;
        }
        
        @keyframes reachablePulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 1; }
        }
        
        .map-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.8);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
        }
        
        .zoom-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .zoom-controls .game-button {
            padding: 6px 10px;
            font-size: 10px;
            width: auto;
            margin: 0;
        }

        /* 战役调试信息 */
        .campaign-debug {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            color: #aaa;
            font-size: 11px;
            max-width: 300px;
            display: none;
        }
        
        .campaign-debug.show {
            display: block;
        }
        
        .soul-capacity-select {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 5px;
        }
        
        .soul-capacity-select label {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .soul-capacity-select input[type="radio"] {
            width: 16px;
            height: 16px;
            accent-color: #4a90e2;
            cursor: pointer;
        }
        
        .soul-capacity-select label:hover {
            transform: scale(1.05);
        }
        
        /* 新的剧本选择UI */
        .scenario-selection-modal {
            max-width: 900px;
            width: 90vw;
        }
        
        .scenario-container {
            display: flex;
            gap: 30px;
            margin-top: 10px;
        }
        
        .scenario-list {
            width: 280px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 20px;
        }
        
        .scenario-list .section-title {
            color: #e2a855;
            margin: 0 0 20px 0;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .scenario-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            margin-bottom: 10px;
            background: rgba(255,255,255,0.05);
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            user-select: none;
        }
        
        .scenario-item:hover {
            background: rgba(74, 144, 226, 0.1);
            border-color: #4a90e2;
        }
        
        .scenario-item.active {
            background: rgba(74, 144, 226, 0.2);
            border-color: #4a90e2;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
        }
        
        .scenario-icon {
            font-size: 24px;
        }
        
        .scenario-name {
            font-size: 14px;
            font-weight: bold;
            color: #e0e0e0;
        }
        
        .scenario-details {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .scenario-panel {
            display: none;
            flex: 1;
        }
        
        .scenario-panel.active {
            display: block;
        }
        
        .panel-title {
            background: linear-gradient(135deg, #4a90e2, #6c5ce7);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0 0 20px 0;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
        }
        
        .panel-description {
            background: linear-gradient(135deg, rgba(0,0,0,0.4), rgba(74, 144, 226, 0.08));
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(74, 144, 226, 0.2);
            backdrop-filter: blur(5px);
        }
        
        .panel-description p {
            line-height: 1.8;
            margin-bottom: 20px;
            color: #ddd;
        }
        
        .scenario-stats {
            display: flex;
            gap: 30px;
            justify-content: center;
        }
        
        .stat-item {
            font-size: 16px;
            color: #aaa;
        }
        
        .stat-value {
            color: #e2a855;
            font-weight: bold;
            font-size: 20px;
            margin-left: 10px;
        }
        
        .difficulty-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #333;
        }
        
        .section-subtitle {
            color: #55e285;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
        }
        
        .difficulty-options {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .difficulty-option {
            cursor: pointer;
        }
        
        .difficulty-option input {
            display: none;
        }
        
        .difficulty-card {
            background: rgba(0,0,0,0.4);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px 25px;
            text-align: center;
        }
        
        .difficulty-option input:checked + .difficulty-card {
            border-color: #4a90e2;
            background: rgba(74, 144, 226, 0.2);
        }
        
        .difficulty-card:hover {
            background: rgba(74, 144, 226, 0.1);
        }
        
        .difficulty-card.challenge {
            border-color: #e24a4a;
        }
        
        .difficulty-option input:checked + .difficulty-card.challenge {
            border-color: #e24a4a;
            background: rgba(226, 74, 74, 0.2);
        }
        
        .difficulty-card.master {
            border-color: #e2a855;
        }
        
        .difficulty-option input:checked + .difficulty-card.master {
            border-color: #e2a855;
            background: rgba(226, 168, 85, 0.2);
        }
        
        .difficulty-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .difficulty-souls {
            font-size: 12px;
            color: #aaa;
        }
        
        .start-button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: auto;
            margin-left: auto;
            margin-right: auto;
        }
        
        .button-icon {
            font-size: 20px;
        }
    </style>
</head>
<body>
    <!-- 开场动画 -->
    <div class="opening-animation" id="openingAnimation">
        <div class="opening-particles" id="particles"></div>
        <div class="opening-title">🔮 SOUL MAGE</div>
        <div class="opening-subtitle">数字魂战传奇即将开始...</div>
    </div>

    <div id="gameContainer">
        <div id="mapContainer">
            <div class="map-controls">
                <div class="zoom-controls">
                    <button class="game-button" id="zoomInBtn">放大</button>
                    <button class="game-button" id="zoomOutBtn">缩小</button>
                    <button class="game-button" id="centerBtn">居中</button>
                </div>
                <div style="color: #aaa; font-size: 11px;">
                    视野范围: <span id="viewRange">2</span> 步
                </div>
            </div>
            
            <!-- 战役调试信息 -->
            <div class="campaign-debug" id="campaignDebug">
                <div>战役模式: <span id="debugCampaignMode">否</span></div>
                <div>目标数量: <span id="debugTargetCount">0</span></div>
                <div>目标列表: <span id="debugTargetList">无</span></div>
                <div>当前位置: <span id="debugCurrentPos">-</span></div>
            </div>
            
            <svg id="mapSvg"></svg>
        </div>
        
        <div id="sidePanel">
            <div class="panel-header">
                🔮 SOUL MAGE
            </div>
            
            <div class="panel-content">
                <div class="panel-section">
                    <div class="section-title">⚡ 状态</div>
                    <div class="status-grid">
                        <div class="status-item">
                            <span>当前位置</span>
                            <span class="status-value" id="currentPos">-</span>
                        </div>
                        <div class="status-item">
                            <span>主角单位</span>
                            <span class="status-value" id="heroUnit">-</span>
                        </div>
                        <div class="status-item">
                            <span>目标BOSS</span>
                            <span class="status-value" id="bossTarget">-</span>
                        </div>
                        <div class="status-item" id="missionStatus" style="display: none;">
                            <span>使命状态</span>
                            <span class="status-value" style="color: #55e285;">✅ 已完成</span>
                        </div>
                        <div class="status-item">
                            <span>战斗次数</span>
                            <span class="status-value" id="battleCount">0</span>
                        </div>
                        <div class="status-item">
                            <span>收集魂数</span>
                            <span class="status-value" id="soulCount">0/9</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">💎 魂库</div>
                    <div class="soul-simple-list" id="soulSimpleList"></div>
                    <button class="game-button" id="configureSoulsBtn">⚙️ 布置魂阵</button>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">🎮 操作</div>
                    <button class="game-button" id="settingsBtn">⚙️ 游戏设置</button>
                    <button class="game-button" id="helpBtn">❓ 游戏说明</button>
                    <button class="game-button" id="saveGameBtn">💾 保存进度</button>
                    <button class="game-button" id="loadGameBtn">📁 读取进度</button>
                    <input type="file" id="loadGameInput" accept=".json" style="display: none;">
                </div>
            </div>
        </div>
    </div>
    
    <!-- 魂配置弹窗 -->
    <div class="modal-overlay" id="soulConfigModal">
        <div class="modal-content soul-config-container">
            <div class="modal-header">
                <span>💎 魂阵布局</span>
                <button class="modal-close" id="closeSoulConfigBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="soul-management">
                    <div class="soul-zones">
                        <div class="soul-zone waiting-zone">
                            <h3>💤 魂库</h3>
                            <div class="soul-cards" id="waitingSouls"></div>
                        </div>
                        <div class="soul-zone release-zone">
                            <h3>⚔️ 出战位</h3>
                            <div class="soul-cards" id="releaseSouls"></div>
                        </div>
                    </div>
                    <div class="soul-mage-divider">SOUL MAGE</div>
                    <div class="timeline-container">
                        <div class="timeline-scroll" id="timelineScroll">
                            <div class="timeline-track" id="timelineTrack">
                                <div class="timeline-label">主角<br><span id="heroTimeline">23</span></div>
                                <div class="timeline-turns" id="timelineTurns"></div>
                            </div>
                        </div>
                        <div class="scroll-hint">← 向右滑动查看更多回合 →</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 节点上下文菜单 -->
    <div class="node-context-menu" id="nodeContextMenu">
        <div class="context-menu-item battle" id="contextBattle">
            <span>⚔️</span>
            <span>发起战斗</span>
        </div>
        <div class="context-menu-item campaign" id="contextCampaign">
            <span>🏛️</span>
            <span>开始战役</span>
        </div>
        <div class="context-menu-item move" id="contextMove">
            <span>🚶</span>
            <span>移动过去</span>
        </div>
    </div>
    
    <!-- 战斗弹窗 -->
    <div class="modal-overlay" id="battleModal">
        <div class="modal-content battle-arena">
            <div class="modal-header">
                <span>⚔️ 数字魂战</span>
                <div style="font-size: 14px; opacity: 0.8;">速度: <span id="battleSpeedDisplay">正常</span></div>
            </div>
            <div class="battle-field">
                <div class="turn-display" id="turnDisplay">准备战斗...</div>
                
                <div class="battle-team">
                    <div class="team-label player">👑 我方</div>
                    <div class="battle-units" id="playerBattleUnits"></div>
                </div>
                
                <div class="battle-vs">VS</div>
                
                <div class="battle-team">
                    <div class="team-label enemy">💀 敌方</div>
                    <div class="battle-units" id="enemyBattleUnits"></div>
                </div>
            </div>
            <div class="battle-controls">
                <button class="game-button" id="closeBattleBtn" style="display: none;">关闭</button>
            </div>
        </div>
    </div>
    
    <!-- 游戏帮助弹窗 -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content help-modal">
            <div class="modal-header">
                <span>❓ 游戏说明</span>
                <button class="modal-close" id="closeHelpBtn">&times;</button>
            </div>
            <div class="modal-body" style="overflow-y: auto; max-height: 70vh;">
                <div style="line-height: 1.8; color: #ddd;">
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🎯 游戏目标</h3>
                    <p>击败BOSS成为真正的Soul Mage！通过征服数字节点，收集并合理运用魂的力量。</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🏰 节点类型</h3>
                    <p>• <span style="color: #4a90e2;">蓝色发光</span>：友方节点（可自由移动）<br>
                    • <span style="color: #666;">灰色</span>：敌方已征服节点<br>
                    • <span style="color: #e24a4a;">红色发光</span>：BOSS节点<br>
                    • <span style="color: #4a90e2;">蓝色边框</span>：当前位置</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">💎 魂的机制</h3>
                    <p>• <span style="color: #e2a855;">释放模式</span>：魂作为战斗单位参战，战斗后会消耗掉<br>
                    • <span style="color: #55e285;">增益模式</span>：在指定回合为主角提供额外攻击力<br>
                    • <span style="color: #666;">等待模式</span>：暂不使用，保留备用</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">⚔️ 战斗规则</h3>
                    <p>• 每回合比较 (数字 % 回合数) 的最大值<br>
                    • 连续赢3回合随机消灭对方一个单位<br>
                    • 魂增益时取 max(主角攻击力, 魂攻击力)<br>
                    • 所有单位被消灭的一方失败</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🏛️ 战役系统</h3>
                    <p>• <span style="color: #e2a855;">大型战役</span>：可同时宣战多个连续节点（最多10个）<br>
                    • 点击节点选择"开始战役"进入战役模式<br>
                    • 点击选择战役路径上的多个目标节点<br>
                    • 所有战役目标的敌人和额外单位全部参战<br>
                    • 胜利后同时收获所有目标节点的魂<br>
                    • 直接跳到战役路径的末端位置</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🎮 行动选项</h3>
                    <p>• <span style="color: #e24a4a;">发起战斗</span>：点击节点选择"发起战斗"<br>
                    • <span style="color: #4a90e2;">普通移动</span>：点击节点选择"移动至此"<br>
                    • <span style="color: #e2a855;">开始战役</span>：点击节点选择"开始战役"<br>
                    • <span style="color: #55e285;">魂传送</span>：点击魂卡片传送到该魂所在节点</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">✨ 魂传送规则</h3>
                    <p>• <span style="color: #55e285;">触发方式</span>：点击界面中的魂卡片<br>
                    • <span style="color: #55e285;">传送条件</span>：目标魂节点必须通过友方节点网络可达<br>
                    • <span style="color: #55e285;">路径要求</span>：只能通过已征服的友方节点移动<br>
                    • <span style="color: #55e285;">友方网络</span>：包括英雄位置和所有已收集的魂节点<br>
                    • <span style="color: #55e285;">限制条件</span>：不能传送到当前所在位置</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🗺️ 地图连接</h3>
                    <p>两个数字节点之间存在连接的条件：它们的差值是两数的公共质因数。</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 设置弹窗 -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <span>⚙️ 游戏设置</span>
                <button class="modal-close" id="closeSettingsBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="setting-item">
                    <span>战斗速度</span>
                    <select class="setting-slider" id="battleSpeedSelect">
                        <option value="0.5">慢速 (0.5x)</option>
                        <option value="1">正常 (1x)</option>
                        <option value="1.5" selected>快速 (1.5x)</option>
                        <option value="2">极快 (2x)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>视野范围</span>
                    <input type="range" class="setting-slider" id="viewRangeSlider" min="1" max="4" value="2">
                </div>
                <div class="setting-item">
                    <span>音效开关</span>
                    <input type="checkbox" id="soundToggle" checked>
                </div>
                <div class="setting-item">
                    <span>调试模式</span>
                    <input type="checkbox" id="debugToggle">
                </div>
            </div>
        </div>
    </div>
    
    <!-- 游戏开始界面 -->
    <div id="gameOverlay">
        <div class="game-modal scenario-selection-modal">
            <h1 class="modal-title">🔮 SOUL MAGE</h1>
            <div class="story-text" id="storyText">
                <strong>数字魂域传说</strong><br><br>
                在数字宇宙的深处，每个数字都蕴含着远古的魂力。作为被选中的魂法师，你将踏上征服数字之魂的传奇之路。<br><br>
                <em>择一传说，启程...</em>
            </div>
            
            <div class="scenario-container">
                <div class="scenario-list">
                    <h3 class="section-title">📜 选择剧本</h3>
                    <div class="scenario-item active" data-scenario="classic">
                        <div class="scenario-icon">💫</div>
                        <div class="scenario-name">旅程</div>
                    </div>
                    <div class="scenario-item" data-scenario="siege">
                        <div class="scenario-icon">⚔️</div>
                        <div class="scenario-name">兵临城下</div>
                    </div>
                    <div class="scenario-item" data-scenario="napoleon">
                        <div class="scenario-icon">👑</div>
                        <div class="scenario-name">拿破仑</div>
                    </div>
                    <div class="scenario-item" data-scenario="custom">
                        <div class="scenario-icon">🎨</div>
                        <div class="scenario-name">自定义</div>
                    </div>
                </div>
                
                <div class="scenario-details">
                    <div class="scenario-panel active" id="classic-panel">
                        <h3 class="panel-title">💫 经典剧本：旅程</h3>
                        <div class="panel-description">
                            <p>年轻的魂法师23踏上了挑战数字域暴君419的漫漫征途。</p>
                            <div class="scenario-stats">
                                <div class="stat-item">英雄：<span class="stat-value">23</span></div>
                                <div class="stat-item">魔王：<span class="stat-value">419</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="scenario-panel" id="siege-panel">
                        <h3 class="panel-title">⚔️ 兵临城下：古老传说的回响</h3>
                        <div class="panel-description">
                            <p>古籍记载，守城者13携带着神秘的古老力量-1，面对强大的攻城军团203。传说这场战斗用了两个回合。</p>
                            <div class="scenario-stats">
                                <div class="stat-item">英雄：<span class="stat-value">13</span></div>
                                <div class="stat-item">魔王：<span class="stat-value">203</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="scenario-panel" id="napoleon-panel">
                        <h3 class="panel-title">👑 拿破仑：征服者的野心</h3>
                        <div class="panel-description">
                            <p>从科西嘉岛的小贵族3开始，踏上征服欧洲大陆的传奇之路，直至面对命运的终极考验300。</p>
                            <div class="scenario-stats">
                                <div class="stat-item">英雄：<span class="stat-value">3</span></div>
                                <div class="stat-item">魔王：<span class="stat-value">300</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="scenario-panel" id="custom-panel">
                        <h3 class="panel-title">🎨 自创传奇：书写你的数字史诗</h3>
                        <div class="panel-description">
                            <p>选择任意数字作为起点和终点，创造属于你自己的魂法传奇。</p>
                            <div class="custom-inputs">
                                <input type="number" class="custom-input" id="customHero" placeholder="英雄" min="2" max="999">
                                <span style="color: #e2a855; font-size: 20px;">⚔️</span>
                                <input type="number" class="custom-input" id="customBoss" placeholder="魔王" min="2" max="999">
                            </div>
                        </div>
                    </div>
                    
                    <div class="difficulty-section">
                        <h4 class="section-subtitle">⚖️ 选择难度</h4>
                        <div class="difficulty-options">
                            <label class="difficulty-option">
                                <input type="radio" name="soulCapacity" value="24" checked>
                                <div class="difficulty-card">
                                    <div class="difficulty-name">标准</div>
                                    <div class="difficulty-souls">24 魂</div>
                                </div>
                            </label>
                            <label class="difficulty-option">
                                <input type="radio" name="soulCapacity" value="16">
                                <div class="difficulty-card challenge">
                                    <div class="difficulty-name">挑战</div>
                                    <div class="difficulty-souls">16 魂</div>
                                </div>
                            </label>
                            <label class="difficulty-option">
                                <input type="radio" name="soulCapacity" value="9">
                                <div class="difficulty-card master">
                                    <div class="difficulty-name">大师</div>
                                    <div class="difficulty-souls">9 魂</div>
                                </div>
                            </label>
                        </div>
                    </div>
                    
                    <button class="game-button start-button" id="startGameBtn">
                        <span class="button-icon">🌟</span>
                        <span class="button-text">开始征途</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Safe HTML sanitization utility
        const sanitizeHTML = (str) => {
            const div = document.createElement('div');
            div.textContent = String(str);
            return div.innerHTML;
        };

        // Utility classes for modularization
        class DOMUtils {
            static createElement(tag, className = '', attributes = {}, styles = {}) {
                const element = document.createElement(tag);
                if (className) element.className = className;
                
                Object.entries(attributes).forEach(([key, value]) => {
                    element.setAttribute(key, value);
                });
                
                Object.entries(styles).forEach(([key, value]) => {
                    element.style[key] = value;
                });
                
                return element;
            }

            static createSVGElement(tag, attributes = {}) {
                const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
                Object.entries(attributes).forEach(([key, value]) => {
                    element.setAttribute(key, value);
                });
                return element;
            }
        }

        class ModalManager {
            static createModal(title, content, options = {}) {
                const modal = DOMUtils.createElement('div', 'modal-overlay', {}, {
                    display: 'flex',
                    zIndex: options.zIndex || '3000'
                });

                const modalContent = DOMUtils.createElement('div', 'modal-content', {}, {
                    width: options.width || 'auto',
                    height: options.height || 'auto'
                });

                const header = DOMUtils.createElement('div', 'modal-header');
                const titleSpan = DOMUtils.createElement('span');
                titleSpan.textContent = title;
                
                const closeBtn = DOMUtils.createElement('button', 'modal-close');
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => {
                    modal.remove();
                    if (options.onClose) options.onClose();
                };

                header.appendChild(titleSpan);
                header.appendChild(closeBtn);

                const body = DOMUtils.createElement('div', 'modal-body');
                if (typeof content === 'string') {
                    body.innerHTML = content;
                } else {
                    body.appendChild(content);
                }

                modalContent.appendChild(header);
                modalContent.appendChild(body);
                modal.appendChild(modalContent);

                // Click outside to close
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                        if (options.onClose) options.onClose();
                    }
                };

                return modal;
            }
        }

        class MathUtils {
            static modularValue(value, modulus) {
                return ((value % modulus) + modulus) % modulus;
            }

            static distance(point1, point2) {
                const dx = point2.x - point1.x;
                const dy = point2.y - point1.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            static randomInRange(min, max) {
                return Math.random() * (max - min) + min;
            }
        }

        class EnemySelector {
            static selectEnemiesFromNode(targetNode, adjacencyList, maxCount, excludeNodes = [], friendlyNodes = new Set()) {
                const enemies = [targetNode];
                const visited = new Set([targetNode, ...excludeNodes]);
                const layers = [];
                let currentLayer = [targetNode];

                while (currentLayer.length > 0 && enemies.length < maxCount) {
                    const nextLayer = [];
                    const validNodesInLayer = [];

                    for (const node of currentLayer) {
                        for (const neighbor of adjacencyList[node] || []) {
                            if (!visited.has(neighbor) && !friendlyNodes.has(neighbor)) {
                                visited.add(neighbor);
                                nextLayer.push(neighbor);
                                validNodesInLayer.push(neighbor);
                            }
                        }
                    }

                    if (validNodesInLayer.length > 0) {
                        layers.push(validNodesInLayer);
                        const additionalCount = Math.min(3, maxCount - enemies.length);
                        const selectedFromLayer = validNodesInLayer
                            .sort(() => Math.random() - 0.5)
                            .slice(0, additionalCount);
                        enemies.push(...selectedFromLayer);
                    }

                    currentLayer = nextLayer;
                }

                return enemies.slice(0, maxCount);
            }
        }

        class ArrayUtils {
            static removeElementsByIndices(arrays, indices) {
                const sortedIndices = [...indices].sort((a, b) => b - a);
                sortedIndices.forEach(index => {
                    arrays.forEach(array => {
                        if (index < array.length) {
                            array.splice(index, 1);
                        }
                    });
                });
            }

            static shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }
        
        class SoulMageGame {
            // Game constants
            static CONSTANTS = {
                MAX_EDGES: 20000,
                ENEMY_SCALING_FACTOR: 50,
                MAX_TIMELINE_TURNS: 200,
                MAX_CAMPAIGN_LENGTH: 10,
                MIN_DISTANCE: 60,
                MAP_SIZE: 1999,
                DEFAULT_BOSS: 419,
                DEFAULT_HERO: 23,
                MAX_LAYER_ENEMIES: 3,
                PARTICLE_COUNT: 50,
                ANIMATION_CLEANUP_DELAY: 1000
            };

            constructor() {
                // Event listener management to prevent memory leaks
                this.eventListeners = new Set();
                this.mapSize = SoulMageGame.CONSTANTS.MAP_SIZE;
                this.bossNode = SoulMageGame.CONSTANTS.DEFAULT_BOSS;
                this.nodes = [];
                this.edges = [];
                this.adjacencyList = {};
                this.currentPos = null;
                this.heroUnit = null;
                this.souls = [];
                this.maxSouls = 9;
                this.conqueredNodes = new Set();
                this.friendlyNodes = new Set();
                this.battleInProgress = false;
                this.battleCount = 0;
                this.viewRange = 2;
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.beforeBattleState = null;
                this.selectedTarget = null;
                
                // 战役模式相关
                this.campaignMode = false;
                this.campaignTargets = [];
                this.maxCampaignLength = 10;
                
                this.soulModes = [];
                this.soulBuffTurns = [];
                this.releaseOrder = []; // 记录出战区魂卡的放置顺序
                
                this.battleSpeed = 1.5;
                this.soundEnabled = true;
                this.debugMode = false;
                this.missionCompleted = false;
                
                this.initializeGame();
            }
            
            initializeGame() {
                this.showOpeningAnimation();
                this.setupEventListeners();
                this.generateMap();
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
            }

            // Centralized UI update method to replace repeated calls
            updateGameUI() {
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
                this.updateUI();
                this.renderMap();
            }
            
            showOpeningAnimation() {
                try {
                    const particlesContainer = document.getElementById('particles');
                    if (!particlesContainer) {
                        console.warn('Particles container not found');
                        return;
                    }
                    
                    const particles = [];
                    for (let i = 0; i < 50; i++) {
                        setTimeout(() => {
                            const particle = document.createElement('div');
                            particle.className = 'particle';
                            particle.style.left = Math.random() * 100 + '%';
                            particle.style.animationDelay = Math.random() * 6 + 's';
                            particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                            
                            const colors = ['#4a90e2', '#e24a4a', '#55e285', '#e2a855'];
                            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                            
                            particlesContainer.appendChild(particle);
                            particles.push(particle);
                            
                            // Auto-remove particle after animation completes
                            const duration = parseFloat(particle.style.animationDuration) * 1000;
                            setTimeout(() => {
                                if (particle.parentNode) {
                                    particle.parentNode.removeChild(particle);
                                }
                            }, duration + 1000);
                        }, i * 100);
                    }
                    
                    setTimeout(() => {
                        const opening = document.getElementById('openingAnimation');
                        if (opening) {
                            opening.classList.add('fade-out');
                            setTimeout(() => {
                                opening.style.display = 'none';
                            }, 1000);
                        }
                    }, 3000);
                } catch (error) {
                    console.error('Error in showOpeningAnimation:', error);
                }
            }
            
            generateMap() {
                console.log('生成地图中...');
                const startTime = performance.now();
                
                for (let i = 2; i <= this.mapSize; i++) {
                    this.nodes.push(i);
                    this.adjacencyList[i] = [];
                }
                
                let edgeCount = 0;
                const maxEdges = 20000;
                
                for (let i = 0; i < this.nodes.length && edgeCount < maxEdges; i++) {
                    for (let j = i + 1; j < this.nodes.length && edgeCount < maxEdges; j++) {
                        const a = this.nodes[i];
                        const b = this.nodes[j];
                        const diff = Math.abs(a - b);
                        
                        if (this.isCommonPrimeFactor(a, b, diff)) {
                            this.edges.push([a, b]);
                            this.adjacencyList[a].push(b);
                            this.adjacencyList[b].push(a);
                            edgeCount++;
                        }
                    }
                }
                
                const endTime = performance.now();
                console.log(`地图生成完成，用时 ${(endTime - startTime).toFixed(2)}ms，共${edgeCount}条边`);
            }
            
            primeCache = new Map();
            
            isCommonPrimeFactor(a, b, diff) {
                if (diff === 1) return false;
                if (!this.isPrime(diff)) return false;
                return a % diff === 0 && b % diff === 0;
            }
            
            isPrime(n) {
                if (this.primeCache.has(n)) {
                    return this.primeCache.get(n);
                }
                
                if (n < 2) {
                    this.primeCache.set(n, false);
                    return false;
                }
                
                for (let i = 2; i * i <= n; i++) {
                    if (n % i === 0) {
                        this.primeCache.set(n, false);
                        return false;
                    }
                }
                
                this.primeCache.set(n, true);
                return true;
            }
            
            updateFriendlyNodes() {
                this.friendlyNodes.clear();
                if (this.heroUnit) {
                    this.friendlyNodes.add(this.heroUnit);
                }
                this.souls.forEach(soul => {
                    this.friendlyNodes.add(soul);
                });
            }
            
            getVisibleNodes() {
                // During initialization, return empty array to prevent errors
                if (!this.currentPos && !this.heroUnit) {
                    console.log('No currentPos or heroUnit set yet');
                    return [];
                }
                
                // If currentPos is not set but heroUnit is, use heroUnit
                const startPos = this.currentPos || this.heroUnit;
                if (!startPos) return [];
                
                const visited = new Set();
                const queue = [{node: startPos, distance: 0}];
                const visibleNodes = [];
                
                if (this.campaignMode && this.campaignTargets.length > 0) {
                    this.campaignTargets.forEach(target => {
                        if (!visited.has(target)) {
                            queue.push({node: target, distance: 0});
                        }
                    });
                }
                
                while (queue.length > 0) {
                    const {node, distance} = queue.shift();
                    
                    if (visited.has(node)) continue;
                    visited.add(node);
                    visibleNodes.push(node);
                    
                    if (distance < this.viewRange) {
                        this.adjacencyList[node].forEach(neighbor => {
                            if (!visited.has(neighbor)) {
                                queue.push({node: neighbor, distance: distance + 1});
                            }
                        });
                    }
                }
                
                return visibleNodes;
            }
            
            renderMap() {
                try {
                    // Don't render map if game hasn't started yet
                    if (!this.currentPos && !this.heroUnit) {
                        console.log('Game not started yet, skipping map render');
                        return;
                    }
                    
                    const svg = document.getElementById('mapSvg');
                    if (!svg) {
                        console.error('Map SVG element not found');
                    return;
                }
                
                const rect = svg.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                if (width <= 0 || height <= 0) {
                    requestAnimationFrame(() => this.renderMap());
                    return;
                }
                
                this.updateDebugInfo();
                
                if (this.campaignMode) {
                    this.updateCampaignUI();
                }
                
                const visibleNodes = this.getVisibleNodes();
                if (visibleNodes.length === 0) {
                    console.warn('没有可见节点。当前位置:', this.currentPos);
                    // Don't render anything if no nodes are visible
                    svg.innerHTML = '';
                    return;
                }
                
                const visibleEdges = this.edges.filter(([a, b]) => 
                    visibleNodes.includes(a) && visibleNodes.includes(b)
                );
                
                const positions = this.forceDirectedLayout(visibleNodes, visibleEdges, width, height);
                
                svg.innerHTML = '';
                
                const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                mainGroup.setAttribute('transform', `translate(${width/2 + this.panX}, ${height/2 + this.panY}) scale(${this.zoom})`);
                
                if (this.campaignMode) {
                    svg.classList.add('campaign-mode');
                } else {
                    svg.classList.remove('campaign-mode');
                }
                
                visibleEdges.forEach(([a, b]) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', positions[a].x);
                    line.setAttribute('y1', positions[a].y);
                    line.setAttribute('x2', positions[b].x);
                    line.setAttribute('y2', positions[b].y);
                    line.setAttribute('class', 'edge');
                    mainGroup.appendChild(line);
                });
                
                visibleNodes.forEach(node => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'node');
                    g.setAttribute('transform', `translate(${positions[node].x},${positions[node].y})`);
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', '20');
                    circle.setAttribute('fill', '#2a2a2a');
                    
                    if (node === this.bossNode) {
                        circle.classList.add('boss-node');
                    } else if (node === this.currentPos) {
                        circle.classList.add('current-node');
                    } else if (this.friendlyNodes.has(node)) {
                        circle.classList.add('friendly-node');
                    } else if (this.conqueredNodes.has(node)) {
                        circle.classList.add('conquered-node');
                    }
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dy', '5');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '14');
                    text.textContent = node;
                    
                    g.appendChild(circle);
                    g.appendChild(text);
                    
                    g.addEventListener('click', (event) => this.onNodeClick(node, event));
                    
                    mainGroup.appendChild(g);
                });
                
                svg.appendChild(mainGroup);
                this.nodePositions = positions;
                
                if (this.campaignMode) {
                    this.highlightCampaignSelectableNodes();
                    if (this.campaignTargets.length > 0) {
                        this.highlightCampaignPath();
                    }
                } else {
                    this.highlightReachableNodes();
                }
                } catch (error) {
                    console.error('Error rendering map:', error);
                    // Show user-friendly error message
                    const gameContainer = document.getElementById('gameContainer');
                    if (gameContainer) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'color: red; text-align: center; padding: 20px; background: rgba(255,0,0,0.1); border-radius: 10px; margin: 20px;';
                        errorMsg.textContent = '地图渲染错误，请刷新页面重试';
                        gameContainer.appendChild(errorMsg);
                    }
                }
            }
            
            updateDebugInfo() {
                if (this.debugMode) {
                    document.getElementById('campaignDebug').classList.add('show');
                    document.getElementById('debugCampaignMode').textContent = this.campaignMode ? '是' : '否';
                    document.getElementById('debugTargetCount').textContent = this.campaignTargets.length;
                    document.getElementById('debugTargetList').textContent = this.campaignTargets.length > 0 ? this.campaignTargets.join(', ') : '无';
                    document.getElementById('debugCurrentPos').textContent = this.currentPos || '-';
                } else {
                    document.getElementById('campaignDebug').classList.remove('show');
                }
            }
            
            launchCampaign() {
                if (this.campaignTargets.length === 0) {
                    console.log('没有选择战役目标');
                    return;
                }
                
                console.log('发起战役，目标:', this.campaignTargets);
                // Save targets before exiting campaign mode
                const targets = [...this.campaignTargets];
                this.exitCampaignMode();
                // Restore targets for the battle
                this.campaignTargets = targets;
                this.startCampaignBattle();
            }
            
            highlightCampaignSelectableNodes() {
                const selectableNodes = this.getCampaignSelectableNodes();
                console.log('战役可选择节点:', selectableNodes);
                
                selectableNodes.forEach(node => {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach(nodeGroup => {
                        const text = nodeGroup.querySelector('text');
                        if (text && parseInt(text.textContent) === node) {
                            const circle = nodeGroup.querySelector('circle');
                            if (circle) {
                                circle.classList.add('campaign-selectable');
                            }
                        }
                    });
                });
            }
            
            getCampaignSelectableNodes() {
                if (this.campaignTargets.length === 0) {
                    // 第一个目标：只能选择当前位置的邻居中的敌方节点
                    const selectable = (this.adjacencyList[this.currentPos] || []).filter(node => 
                        !this.friendlyNodes.has(node)
                    );
                    console.log('第一个目标可选择 (从当前位置', this.currentPos, '):', selectable);
                    return selectable;
                } else {
                    // 后续目标：必须与最后一个目标相连
                    const lastTarget = this.campaignTargets[this.campaignTargets.length - 1];
                    const selectable = this.adjacencyList[lastTarget].filter(node => 
                        !this.campaignTargets.includes(node) && 
                        !this.friendlyNodes.has(node) &&
                        node !== this.currentPos
                    );
                    console.log('后续目标可选择 (从', lastTarget, '):', selectable);
                    return selectable;
                }
            }
            
            forceDirectedLayout(nodes, edges, width, height) {
                const positions = {};
                const centerX = 0;
                const centerY = 0;
                const minDistance = 60;
                
                if (this.currentPos && nodes.includes(this.currentPos)) {
                    positions[this.currentPos] = {x: centerX, y: centerY};
                }
                
                const otherNodes = nodes.filter(n => n !== this.currentPos);
                otherNodes.forEach((node, i) => {
                    let attempts = 0;
                    let validPosition = false;
                    
                    while (!validPosition && attempts < 100) {
                        const angle = (i / otherNodes.length) * 2 * Math.PI + attempts * 0.1;
                        const radius = 80 + attempts * 5;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        validPosition = true;
                        for (const [existingNode, pos] of Object.entries(positions)) {
                            const dx = x - pos.x;
                            const dy = y - pos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (validPosition) {
                            positions[node] = {x, y};
                        }
                        attempts++;
                    }
                    
                    if (!validPosition) {
                        const angle = (i / otherNodes.length) * 2 * Math.PI;
                        const radius = 120 + i * 10;
                        positions[node] = {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    }
                });
                
                for (let iter = 0; iter < 50; iter++) {
                    const forces = {};
                    nodes.forEach(node => {
                        forces[node] = {x: 0, y: 0};
                    });
                    
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            const a = nodes[i];
                            const b = nodes[j];
                            const dx = positions[b].x - positions[a].x;
                            const dy = positions[b].y - positions[a].y;
                            const dist = Math.sqrt(dx*dx + dy*dy) + 0.01;
                            
                            if (dist < minDistance) {
                                const force = (minDistance - dist) * 2;
                                forces[a].x -= dx/dist * force;
                                forces[a].y -= dy/dist * force;
                                forces[b].x += dx/dist * force;
                                forces[b].y += dy/dist * force;
                            } else {
                                const force = 300 / (dist * dist);
                                forces[a].x -= dx/dist * force;
                                forces[a].y -= dy/dist * force;
                                forces[b].x += dx/dist * force;
                                forces[b].y += dy/dist * force;
                            }
                        }
                    }
                    
                    edges.forEach(([a, b]) => {
                        if (positions[a] && positions[b]) {
                            const dx = positions[b].x - positions[a].x;
                            const dy = positions[b].y - positions[a].y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const idealDist = 90;
                            const force = (dist - idealDist) * 0.05;
                            
                            forces[a].x += dx/dist * force;
                            forces[a].y += dy/dist * force;
                            forces[b].x -= dx/dist * force;
                            forces[b].y -= dy/dist * force;
                        }
                    });
                    
                    nodes.forEach(node => {
                        if (node === this.currentPos) return;
                        
                        positions[node].x += forces[node].x * 0.1;
                        positions[node].y += forces[node].y * 0.1;
                        
                        const maxDist = Math.min(width, height) * 0.35;
                        const dist = Math.sqrt(positions[node].x*positions[node].x + positions[node].y*positions[node].y);
                        if (dist > maxDist) {
                            positions[node].x = positions[node].x / dist * maxDist;
                            positions[node].y = positions[node].y / dist * maxDist;
                        }
                    });
                }
                
                return positions;
            }
            
            onNodeClick(node, event) {
                console.log('节点点击:', node, '战役模式:', this.campaignMode, '战斗中:', this.battleInProgress);
                
                if (this.battleInProgress) {
                    console.log('战斗进行中，忽略节点点击');
                    return;
                }
                
                if (this.campaignMode) {
                    console.log('处理战役模式节点点击');
                    this.handleCampaignNodeClick(node);
                } else if (this.canReach(node)) {
                    console.log('显示节点上下文菜单');
                    event.stopPropagation();
                    this.showNodeContextMenu(node, event);
                } else {
                    console.log('节点不可达:', node);
                }
            }
            
            handleCampaignNodeClick(node) {
                console.log('战役模式: 点击节点', node);
                console.log('当前战役目标:', this.campaignTargets);
                console.log('当前位置:', this.currentPos);
                
                const selectableNodes = this.getCampaignSelectableNodes();
                if (!selectableNodes.includes(node)) {
                    console.log('节点', node, '在战役模式下不可选择');
                    this.showMessage('该节点不能作为战役目标！');
                    return;
                }
                
                this.campaignTargets.push(node);
                console.log('添加战役目标:', node, '总目标数:', this.campaignTargets.length);
                
                if (this.campaignTargets.length >= this.maxCampaignLength) {
                    console.log('战役达到最大长度');
                }
                
                this.renderMap();
                this.updateCampaignUI();
            }
            
            showMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0,0,0,0.9);
                    color: #e2a855;
                    padding: 20px;
                    border-radius: 10px;
                    border: 2px solid #e2a855;
                    z-index: 5000;
                    font-weight: bold;
                    text-align: center;
                    animation: fadeInOut 2s ease;
                `;
                messageDiv.textContent = message;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(messageDiv);
                setTimeout(() => {
                    messageDiv.remove();
                    style.remove();
                }, 2000);
            }
            
            startCampaignMode() {
                console.log('开始战役模式');
                this.campaignMode = true;
                // 不清空campaignTargets，保留已选择的目标
                this.renderMap();
                this.updateCampaignUI();
            }
            
            exitCampaignMode() {
                console.log('退出战役模式');
                this.campaignMode = false;
                this.campaignTargets = [];
                
                const campaignPanel = document.getElementById('campaignPanel');
                if (campaignPanel) {
                    campaignPanel.remove();
                }
                
                this.renderMap();
            }
            
            updateCampaignUI() {
                let panel = document.getElementById('campaignPanel');
                
                if (!panel && this.campaignMode) {
                    panel = document.createElement('div');
                    panel.id = 'campaignPanel';
                    panel.className = 'campaign-panel';
                    panel.innerHTML = `
                        <div class="campaign-stat">
                            <span>目标数量:</span>
                            <span id="targetCount">0/10</span>
                        </div>
                        <div class="campaign-stat">
                            <span>预计敌军:</span>
                            <span id="enemyCount">0</span>
                        </div>
                        <div class="campaign-actions">
                            <button class="campaign-button launch" onclick="gameInstance.launchCampaign()" disabled id="launchBtn">发起战役</button>
                            <button class="campaign-button cancel" onclick="gameInstance.exitCampaignMode()">取消</button>
                        </div>
                    `;
                    // Append to mapContainer instead of body
                    const mapContainer = document.getElementById('mapContainer');
                    mapContainer.appendChild(panel);
                }
                
                if (panel && this.campaignMode) {
                    // Update counts
                    document.getElementById('targetCount').textContent = `${this.campaignTargets.length}/10`;
                    const enemyCount = this.calculateCampaignEnemies();
                    document.getElementById('enemyCount').textContent = enemyCount;
                    
                    // Enable/disable launch button
                    const launchBtn = document.getElementById('launchBtn');
                    launchBtn.disabled = this.campaignTargets.length === 0;
                }
            }
            
            highlightCampaignPath() {
                this.campaignTargets.forEach(target => {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach(nodeGroup => {
                        const text = nodeGroup.querySelector('text');
                        if (text && parseInt(text.textContent) === target) {
                            const circle = nodeGroup.querySelector('circle');
                            if (circle) {
                                circle.classList.add('campaign-selected');
                            }
                        }
                    });
                });
                
                for (let i = 0; i < this.campaignTargets.length - 1; i++) {
                    const from = this.campaignTargets[i];
                    const to = this.campaignTargets[i + 1];
                    
                    if (this.nodePositions[from] && this.nodePositions[to]) {
                        const lines = document.querySelectorAll('line');
                        lines.forEach(line => {
                            const x1 = parseFloat(line.getAttribute('x1'));
                            const y1 = parseFloat(line.getAttribute('y1'));
                            const x2 = parseFloat(line.getAttribute('x2'));
                            const y2 = parseFloat(line.getAttribute('y2'));
                            
                            const pos1 = this.nodePositions[from];
                            const pos2 = this.nodePositions[to];
                            
                            const tolerance = 2;
                            if (((Math.abs(x1 - pos1.x) < tolerance && Math.abs(y1 - pos1.y) < tolerance && 
                                  Math.abs(x2 - pos2.x) < tolerance && Math.abs(y2 - pos2.y) < tolerance) ||
                                 (Math.abs(x1 - pos2.x) < tolerance && Math.abs(y1 - pos2.y) < tolerance && 
                                  Math.abs(x2 - pos1.x) < tolerance && Math.abs(y2 - pos1.y) < tolerance))) {
                                line.classList.add('campaign-path');
                            }
                        });
                    }
                }
            }
            
            showCampaignInfo() {
                // Deprecated - using updateCampaignUI instead
            }
            
            calculateCampaignEnemies() {
                let total = 0;
                const usedEnemies = new Set();
                
                this.campaignTargets.forEach(target => {
                    if (!usedEnemies.has(target) && !this.friendlyNodes.has(target)) {
                        total++;
                        usedEnemies.add(target);
                    }
                    
                    const additionalCount = this.getAdditionalEnemyCount(target);
                    let availableNeighbors = this.adjacencyList[target].filter(n => 
                        n !== this.currentPos && 
                        !this.friendlyNodes.has(n) && 
                        !usedEnemies.has(n) &&
                        !this.campaignTargets.includes(n)
                    );
                    
                    if (availableNeighbors.length < additionalCount) {
                        const distance2Neighbors = new Set();
                        availableNeighbors.forEach(neighbor => {
                            this.adjacencyList[neighbor].forEach(n => {
                                if (n !== target && 
                                    n !== this.currentPos && 
                                    !this.friendlyNodes.has(n) && 
                                    !usedEnemies.has(n) &&
                                    !this.campaignTargets.includes(n)) {
                                    distance2Neighbors.add(n);
                                }
                            });
                        });
                        availableNeighbors = [...availableNeighbors, ...Array.from(distance2Neighbors)];
                    }
                    
                    const actualAdditional = Math.min(additionalCount, availableNeighbors.length);
                    for (let i = 0; i < actualAdditional; i++) {
                        if (availableNeighbors[i] && !usedEnemies.has(availableNeighbors[i])) {
                            total++;
                            usedEnemies.add(availableNeighbors[i]);
                        }
                    }
                });
                
                return total;
            }
            
            async confirmCampaign() {
                if (this.campaignTargets.length === 0) {
                    console.log('没有选择战役目标');
                    this.showMessage('请先选择战役目标！');
                    return;
                }
                
                console.log('确认战役，目标:', this.campaignTargets);
                
                // 保存战役目标，因为exitCampaignMode()会清空它们
                const campaignTargetsCopy = [...this.campaignTargets];
                
                // 清理战役界面
                this.exitCampaignMode();
                
                // 恢复战役目标并启动战役战斗
                this.campaignTargets = campaignTargetsCopy;
                await this.startCampaignBattle();
            }
            
            async startCampaignBattle() {
                console.log('开始战役战斗...');
                this.saveBeforeBattleState();
                this.battleInProgress = true;
                
                const playerUnits = [this.heroUnit];
                const releasedSoulIndices = [];
                
                // 按玩家设置的顺序添加魂
                this.releaseOrder.forEach(index => {
                    if (this.soulModes[index] === 'release') {
                        playerUnits.push(this.souls[index]);
                        releasedSoulIndices.push(index);
                    }
                });
                
                const enemyNodes = this.getCampaignEnemies();
                console.log('战役战斗 - 我方单位:', playerUnits);
                console.log('战役战斗 - 敌方单位:', enemyNodes);
                
                if (enemyNodes.length === 0) {
                    console.error('战役战斗中没有找到敌方单位！');
                    this.showMessage('战役中没有敌人！这可能是一个bug。');
                    this.battleInProgress = false;
                    return;
                }
                
                await this.showBattleModal(playerUnits, enemyNodes);
                
                const result = await this.numbercraftBattle(playerUnits, enemyNodes);
                
                if (result.winner === 'X') {
                    this.onCampaignWin(releasedSoulIndices);
                } else {
                    this.onBattleLose();
                }
                
                this.battleInProgress = false;
            }
            
            getCampaignEnemies() {
                console.log('获取战役敌人，目标:', this.campaignTargets);
                const enemies = [];
                const usedEnemies = new Set();
                
                this.campaignTargets.forEach(target => {
                    console.log('处理目标:', target);
                    
                    if (!usedEnemies.has(target) && !this.friendlyNodes.has(target)) {
                        enemies.push(target);
                        usedEnemies.add(target);
                        console.log('添加目标作为敌人:', target);
                    }
                    
                    const additionalCount = this.getAdditionalEnemyCount(target);
                    console.log('目标', target, '需要额外敌人:', additionalCount);
                    
                    // 使用BFS按距离逐层搜索援军
                    const visited = new Set([target, this.currentPos, ...usedEnemies, ...this.campaignTargets]);
                    const layers = [];
                    let currentLayer = [target];
                    
                    // 收集不同距离层的敌人节点
                    while (currentLayer.length > 0 && layers.flat().length < additionalCount) {
                        const nextLayer = [];
                        const validNodesInLayer = [];
                        
                        for (const node of currentLayer) {
                            for (const neighbor of this.adjacencyList[node]) {
                                if (!visited.has(neighbor) && !this.friendlyNodes.has(neighbor)) {
                                    visited.add(neighbor);
                                    nextLayer.push(neighbor);
                                    validNodesInLayer.push(neighbor);
                                }
                            }
                        }
                        
                        if (validNodesInLayer.length > 0) {
                            layers.push(validNodesInLayer);
                        }
                        currentLayer = nextLayer;
                    }
                    
                    // 从每层随机选择敌人，优先选择近的
                    let remainingCount = additionalCount;
                    for (const layer of layers) {
                        if (remainingCount <= 0) break;
                        
                        // 从当前层随机选择
                        const availableInLayer = [...layer];
                        while (availableInLayer.length > 0 && remainingCount > 0) {
                            const randomIndex = Math.floor(Math.random() * availableInLayer.length);
                            const enemy = availableInLayer.splice(randomIndex, 1)[0];
                            if (!usedEnemies.has(enemy)) {
                                enemies.push(enemy);
                                usedEnemies.add(enemy);
                                console.log('添加额外敌人:', enemy);
                                remainingCount--;
                            }
                        }
                    }
                });
                
                console.log('最终战役敌人:', enemies);
                return enemies;
            }
            
            onCampaignWin(releasedSoulIndices) {
                console.log('战役胜利！目标:', this.campaignTargets);
                this.battleCount++;
                
                
                ArrayUtils.removeElementsByIndices(
                    [this.souls, this.soulModes, this.soulBuffTurns],
                    releasedSoulIndices
                );
                
                const campaignTargetsCopy = [...this.campaignTargets];
                campaignTargetsCopy.forEach(target => {
                    this.conqueredNodes.add(target);
                    this.collectSoul(target);
                    console.log('征服并收集了魂:', target);
                });
                
                this.currentPos = campaignTargetsCopy[campaignTargetsCopy.length - 1];
                console.log('移动到战役终点位置:', this.currentPos);
                
                this.campaignTargets = [];
                
                this.updateGameUI();
                
                if (this.conqueredNodes.has(this.bossNode)) {
                    this.onGameWin();
                }
            }
            
            canReach(node) {
                if (this.currentPos === null) return false;
                if (node === this.currentPos) return false;
                return this.adjacencyList[this.currentPos].includes(node);
            }
            
            highlightReachableNodes() {
                document.querySelectorAll('.reachable-node').forEach(el => {
                    el.classList.remove('reachable-node');
                });
                
                if (!this.currentPos) return;
                
                const reachableNodes = new Set();
                this.adjacencyList[this.currentPos].forEach(node => {
                    reachableNodes.add(node);
                });
                
                document.querySelectorAll('.node').forEach(g => {
                    const circle = g.querySelector('circle');
                    const text = g.querySelector('text');
                    const nodeNum = parseInt(text.textContent);
                    if (reachableNodes.has(nodeNum)) {
                        circle.classList.add('reachable-node');
                    }
                });
            }
            
            showNodeContextMenu(node, event) {
                this.selectedTarget = node;
                
                const menu = document.getElementById('nodeContextMenu');
                const battleItem = document.getElementById('contextBattle');
                const campaignItem = document.getElementById('contextCampaign');
                const moveItem = document.getElementById('contextMove');
                
                // Reset visibility
                battleItem.style.display = 'flex';
                campaignItem.style.display = 'flex';
                moveItem.style.display = 'flex';
                
                if (this.friendlyNodes.has(node)) {
                    // 友方节点只能移动
                    battleItem.style.display = 'none';
                    campaignItem.style.display = 'none';
                    moveItem.querySelector('span:last-child').textContent = '移动到友方节点';
                } else {
                    // 敌方节点可以战斗和战役
                    moveItem.style.display = 'none';
                    moveItem.querySelector('span:last-child').textContent = '移动过去';
                }
                
                // Position menu near click
                const rect = event.target.getBoundingClientRect();
                const menuWidth = 150; // Approximate width
                const menuHeight = 100; // Approximate height
                
                let left = rect.right + 10;
                let top = rect.top;
                
                // Adjust if menu goes off screen
                if (left + menuWidth > window.innerWidth) {
                    left = rect.left - menuWidth - 10;
                }
                if (top + menuHeight > window.innerHeight) {
                    top = window.innerHeight - menuHeight - 10;
                }
                
                menu.style.left = left + 'px';
                menu.style.top = top + 'px';
                
                menu.style.display = 'block';
                
                // Close menu when clicking elsewhere - remove setTimeout to prevent interference
                document.addEventListener('click', this.closeContextMenu, { once: true });
            }
            
            closeContextMenu = () => {
                document.getElementById('nodeContextMenu').style.display = 'none';
                this.selectedTarget = null;
            }
            
            
            moveToNode(targetNode) {
                if (this.friendlyNodes.has(targetNode)) {
                    this.currentPos = targetNode;
                } else {
                    this.currentPos = targetNode;
                    this.conqueredNodes.add(targetNode);
                }
                
                this.updateUI();
                this.renderMap();
                return true;
            }
            
            saveBeforeBattleState() {
                this.beforeBattleState = {
                    currentPos: this.currentPos,
                    souls: [...this.souls],
                    conqueredNodes: new Set(this.conqueredNodes),
                    friendlyNodes: new Set(this.friendlyNodes),
                    soulModes: [...this.soulModes],
                    soulBuffTurns: [...this.soulBuffTurns],
                    releaseOrder: [...this.releaseOrder]
                };
            }
            
            restoreBeforeBattleState() {
                if (this.beforeBattleState) {
                    this.currentPos = this.beforeBattleState.currentPos;
                    this.souls = [...this.beforeBattleState.souls];
                    this.conqueredNodes = new Set(this.beforeBattleState.conqueredNodes);
                    this.friendlyNodes = new Set(this.beforeBattleState.friendlyNodes);
                    this.soulModes = [...this.beforeBattleState.soulModes];
                    this.soulBuffTurns = [...this.beforeBattleState.soulBuffTurns];
                    this.releaseOrder = [...this.beforeBattleState.releaseOrder];
                    
                    this.updateSoulDisplay();
                    this.updateSoulCount();
                    this.updateUI();
                    this.renderMap();
                }
            }
            
            async startBattle() {
                if (!this.selectedTarget) {
                    console.error('没有选择的战斗目标');
                    return;
                }
                
                console.log('开始与目标的战斗:', this.selectedTarget);
                
                this.saveBeforeBattleState();
                this.battleInProgress = true;
                
                const playerUnits = [this.heroUnit];
                const releasedSoulIndices = [];
                
                // 按玩家设置的顺序添加魂
                this.releaseOrder.forEach(index => {
                    if (this.soulModes[index] === 'release') {
                        playerUnits.push(this.souls[index]);
                        releasedSoulIndices.push(index);
                    }
                });
                
                const enemyNodes = this.getBattleEnemies(this.selectedTarget);
                
                console.log('我方单位:', playerUnits);
                console.log('敌方单位:', enemyNodes);
                
                await this.showBattleModal(playerUnits, enemyNodes);
                
                const result = await this.numbercraftBattle(playerUnits, enemyNodes);
                
                if (result.winner === 'X') {
                    this.onBattleWin(this.selectedTarget, enemyNodes, releasedSoulIndices);
                } else {
                    this.onBattleLose();
                }
                
                this.selectedTarget = null;
                this.battleInProgress = false;
            }
            
            getBattleEnemies(targetNode) {
                const enemies = [targetNode];
                const additionalCount = this.getAdditionalEnemyCount(targetNode);
                
                // 使用BFS按距离逐层搜索敌人
                const visited = new Set([targetNode, this.currentPos]);
                const layers = [];
                let currentLayer = [targetNode];
                
                // 收集不同距离层的敌人节点
                while (currentLayer.length > 0 && layers.flat().length < additionalCount) {
                    const nextLayer = [];
                    const validNodesInLayer = [];
                    
                    for (const node of currentLayer) {
                        for (const neighbor of this.adjacencyList[node]) {
                            if (!visited.has(neighbor) && !this.friendlyNodes.has(neighbor)) {
                                visited.add(neighbor);
                                nextLayer.push(neighbor);
                                validNodesInLayer.push(neighbor);
                            }
                        }
                    }
                    
                    if (validNodesInLayer.length > 0) {
                        layers.push(validNodesInLayer);
                    }
                    currentLayer = nextLayer;
                }
                
                // 从每层随机选择敌人，优先选择近的
                let remainingCount = additionalCount;
                for (const layer of layers) {
                    if (remainingCount <= 0) break;
                    
                    // 从当前层随机选择
                    const availableInLayer = [...layer];
                    while (availableInLayer.length > 0 && remainingCount > 0) {
                        const randomIndex = Math.floor(Math.random() * availableInLayer.length);
                        const enemy = availableInLayer.splice(randomIndex, 1)[0];
                        enemies.push(enemy);
                        remainingCount--;
                    }
                }
                
                return enemies;
            }
            
            getAdditionalEnemyCount(node) {
                // 每50个数字增加1个援军，2-49无援军
                return Math.floor(node / 50);
            }
            
            async showBattleModal(playerUnits, enemyUnits) {
                console.log('显示战斗模态框');
                const modal = document.getElementById('battleModal');
                
                const speedTexts = {0.5: '慢速', 1: '正常', 1.5: '快速', 2: '极快'};
                document.getElementById('battleSpeedDisplay').textContent = speedTexts[this.battleSpeed];
                
                const playerDiv = document.getElementById('playerBattleUnits');
                const enemyDiv = document.getElementById('enemyBattleUnits');
                
                playerDiv.innerHTML = '';
                enemyDiv.innerHTML = '';
                
                // 战斗显示：主角在最左边，魂按顺序从左到右排列
                playerUnits.forEach((unit, index) => {
                    const div = document.createElement('div');
                    div.className = 'battle-unit player';
                    div.textContent = unit;
                    div.id = `battle-player-${unit}-${index}`;
                    
                    // 按照playerUnits的顺序显示：主角在左，魂从左到右
                    playerDiv.appendChild(div);
                });
                
                enemyUnits.forEach((unit, index) => {
                    const div = document.createElement('div');
                    div.className = 'battle-unit enemy';
                    div.textContent = unit;
                    div.id = `battle-enemy-${unit}-${index}`;
                    enemyDiv.appendChild(div);
                });
                
                modal.style.display = 'flex';
                console.log('战斗模态框现在应该可见');
                
                await this.delay(300 / this.battleSpeed);
            }
            
            async numbercraftBattle(groupX, groupY) {
                let aliveX = [...groupX];
                let aliveY = [...groupY];
                let consecutiveWinsX = 0;
                let consecutiveWinsY = 0;
                let turn = 2;
                
                while (aliveX.length > 0 && aliveY.length > 0) {
                    document.getElementById('turnDisplay').textContent = `回合 ${turn}`;
                    
                    let maxX = Math.max(...aliveX.map(x => MathUtils.modularValue(x, turn)));
                    let maxXUnit = aliveX.find(x => MathUtils.modularValue(x, turn) === maxX);
                    
                    let soulBonus = 0;
                    let bonusSoul = null;
                    this.souls.forEach((soul, index) => {
                        if (this.soulModes[index] === 'buff' && this.soulBuffTurns[index] === turn) {
                            const soulValue = MathUtils.modularValue(soul, turn);
                            if (soulValue > maxX) {
                                maxX = soulValue;
                                maxXUnit = this.heroUnit;
                                soulBonus = soulValue;
                                bonusSoul = soul;
                            }
                        }
                    });
                    
                    const maxY = Math.max(...aliveY.map(y => MathUtils.modularValue(y, turn)));
                    const maxYUnit = aliveY.find(y => MathUtils.modularValue(y, turn) === maxY);
                    
                    await this.showTurnEffects(maxXUnit, maxYUnit, maxX, maxY, bonusSoul, turn);
                    
                    if (maxX > maxY) {
                        consecutiveWinsX++;
                        consecutiveWinsY = 0;
                    } else if (maxY > maxX) {
                        consecutiveWinsY++;
                        consecutiveWinsX = 0;
                    } else {
                        consecutiveWinsX = 0;
                        consecutiveWinsY = 0;
                    }
                    
                    if (consecutiveWinsX === 3) {
                        const randomIndex = Math.floor(Math.random() * aliveY.length);
                        const eliminated = aliveY[randomIndex];
                        aliveY.splice(randomIndex, 1);
                        await this.eliminateUnit('enemy', eliminated, randomIndex);
                        consecutiveWinsX = 0;
                    } else if (consecutiveWinsY === 3) {
                        // 玩家阵亡顺序：从右到左（前线优先），主角最后
                        let eliminatedIndex = -1;
                        let eliminated = null;
                        
                        // 优先消灭最右边的魂（最前线）
                        for (let i = aliveX.length - 1; i >= 0; i--) {
                            if (aliveX[i] !== this.heroUnit) {
                                eliminatedIndex = i;
                                eliminated = aliveX[i];
                                break;
                            }
                        }
                        
                        // 如果没有魂，则消灭主角
                        if (eliminatedIndex === -1) {
                            eliminatedIndex = aliveX.indexOf(this.heroUnit);
                            eliminated = this.heroUnit;
                        }
                        
                        if (eliminatedIndex !== -1) {
                            aliveX.splice(eliminatedIndex, 1);
                            await this.eliminateUnit('player', eliminated, eliminatedIndex);
                        }
                        consecutiveWinsY = 0;
                    }
                    
                    turn++;
                    await this.delay(800 / this.battleSpeed); // 调快战斗速度
                }
                
                const result = aliveX.length > 0 ? 'X' : 'Y';
                await this.showBattleResult(result);
                
                return {winner: result, finalTurn: turn};
            }
            
            async showTurnEffects(playerUnit, enemyUnit, playerValue, enemyValue, bonusSoul, turn) {
                const playerUnitEl = document.querySelector(`#battle-player-${playerUnit}-0`) || 
                                   document.querySelector(`[id^="battle-player-${playerUnit}-"]`);
                const enemyUnitEl = document.querySelector(`#battle-enemy-${enemyUnit}-0`) || 
                                  document.querySelector(`[id^="battle-enemy-${enemyUnit}-"]`);
                
                if (playerValue > enemyValue && playerUnitEl) {
                    playerUnitEl.classList.add('winner');
                } else if (enemyValue > playerValue && enemyUnitEl) {
                    enemyUnitEl.classList.add('winner');
                }
                
                if (playerUnitEl) {
                    this.showFloatingNumber(playerUnitEl, playerValue);
                }
                if (enemyUnitEl) {
                    this.showFloatingNumber(enemyUnitEl, enemyValue);
                }
                
                // 增强魂增益特效 - 显示在战斗场景中，而不是数字内部
                if (bonusSoul && playerUnitEl) {
                    // 获取战斗场景容器
                    const battleField = document.querySelector('.battle-field');
                    const unitRect = playerUnitEl.getBoundingClientRect();
                    const fieldRect = battleField.getBoundingClientRect();
                    
                    // 在数字单位上方显示魂增益光环
                    const soulAura = document.createElement('div');
                    soulAura.style.cssText = `
                        position: absolute;
                        left: ${unitRect.left - fieldRect.left - 10}px;
                        top: ${unitRect.top - fieldRect.top - 10}px;
                        width: ${unitRect.width + 20}px;
                        height: ${unitRect.height + 20}px;
                        border: 3px solid #55e285;
                        border-radius: 15px;
                        background: radial-gradient(circle, rgba(85, 226, 133, 0.3) 0%, transparent 70%);
                        z-index: 100;
                        pointer-events: none;
                        animation: soulAura 1.5s ease;
                    `;
                    
                    // 显示魂数字标识 - 浮在数字上方
                    const soulIndicator = DOMUtils.createElement('div', '', {}, {
                        position: 'absolute',
                        left: `${unitRect.left - fieldRect.left + unitRect.width/2 - 40}px`,
                        top: `${unitRect.top - fieldRect.top - 50}px`,
                        width: '80px',
                        background: 'linear-gradient(135deg, #55e285 0%, #45c275 100%)',
                        color: 'white',
                        padding: '8px 12px',
                        borderRadius: '20px',
                        fontSize: '14px',
                        fontWeight: 'bold',
                        zIndex: '200',
                        boxShadow: '0 4px 15px rgba(85, 226, 133, 0.6)',
                        animation: 'soulBonus 1.5s ease',
                        pointerEvents: 'none',
                        textAlign: 'center'
                    });
                    soulIndicator.textContent = `魂 ${bonusSoul}`;
                    
                    // 添加动画样式（如果还没有）
                    if (!document.getElementById('soulEffectStyles')) {
                        const style = document.createElement('style');
                        style.id = 'soulEffectStyles';
                        style.textContent = `
                            @keyframes soulAura {
                                0% { 
                                    opacity: 0; 
                                    transform: scale(0.5); 
                                    border-color: #55e285;
                                }
                                30% { 
                                    opacity: 1; 
                                    transform: scale(1.1); 
                                    border-color: #7af2a5;
                                }
                                70% { 
                                    opacity: 0.8; 
                                    transform: scale(1); 
                                    border-color: #55e285;
                                }
                                100% { 
                                    opacity: 0; 
                                    transform: scale(1.2); 
                                    border-color: #3ad975;
                                }
                            }
                            @keyframes soulBonus {
                                0% { 
                                    opacity: 0; 
                                    transform: translateY(20px) scale(0.5); 
                                }
                                30% { 
                                    opacity: 1; 
                                    transform: translateY(-5px) scale(1.2); 
                                }
                                70% { 
                                    opacity: 1; 
                                    transform: translateY(0) scale(1); 
                                }
                                100% { 
                                    opacity: 0; 
                                    transform: translateY(-15px) scale(0.8); 
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // 添加到战斗场景中
                    battleField.appendChild(soulAura);
                    battleField.appendChild(soulIndicator);
                    
                    // 清理特效
                    setTimeout(() => {
                        if (soulAura.parentNode) {
                            soulAura.parentNode.removeChild(soulAura);
                        }
                        if (soulIndicator.parentNode) {
                            soulIndicator.parentNode.removeChild(soulIndicator);
                        }
                    }, 1500 / this.battleSpeed);
                }
                
                await this.delay(600 / this.battleSpeed);
                
                document.querySelectorAll('.winner').forEach(el => {
                    el.classList.remove('winner');
                });
            }
            
            showFloatingNumber(element, value) {
                const number = document.createElement('div');
                number.className = 'damage-number';
                number.textContent = value;
                
                const rect = element.getBoundingClientRect();
                number.style.left = rect.left + rect.width/2 - 10 + 'px';
                number.style.top = rect.top - 10 + 'px';
                number.style.position = 'fixed';
                number.style.zIndex = '3000';
                number.style.animationDuration = (1 / this.battleSpeed) + 's';
                
                document.body.appendChild(number);
                
                setTimeout(() => {
                    if (number.parentNode) {
                        number.parentNode.removeChild(number);
                    }
                }, 1000 / this.battleSpeed);
            }
            
            async eliminateUnit(team, unit, index) {
                const unitEl = document.querySelector(`#battle-${team}-${unit}-${index}`) ||
                             document.querySelector(`[id^="battle-${team}-${unit}-"]`);
                if (unitEl) {
                    unitEl.classList.add('eliminated');
                }
                await this.delay(400 / this.battleSpeed);
            }
            
            async showBattleResult(winner) {
                const display = document.getElementById('turnDisplay');
                if (winner === 'X') {
                    display.textContent = '🎉 胜利！';
                    display.style.borderColor = '#4a90e2';
                } else {
                    display.textContent = '💀 失败...';
                    display.style.borderColor = '#e24a4a';
                }
                
                const closeBtn = document.getElementById('closeBattleBtn');
                closeBtn.style.display = 'block';
                
                await new Promise(resolve => {
                    closeBtn.onclick = () => {
                        document.getElementById('battleModal').style.display = 'none';
                        closeBtn.style.display = 'none';
                        resolve();
                    };
                });
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            onBattleWin(targetNode, enemies, releasedSoulIndices) {
                this.battleCount++;
                
                
                // Store released souls before removal
                const releasedSouls = releasedSoulIndices.map(index => this.souls[index]);
                ArrayUtils.removeElementsByIndices(
                    [this.souls, this.soulModes, this.soulBuffTurns],
                    releasedSoulIndices
                );
                
                this.conqueredNodes.add(targetNode);
                this.currentPos = targetNode;
                this.collectSoul(targetNode);
                
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
                this.updateUI();
                this.renderMap();
                
                if (targetNode === this.bossNode) {
                    this.onGameWin();
                }
            }
            
            onBattleLose() {
                setTimeout(() => {
                    this.restoreBeforeBattleState();
                }, 800 / this.battleSpeed);
            }
            
            collectSoul(node) {
                if (this.souls.length < this.maxSouls) {
                    this.souls.push(node);
                    this.soulModes.push('none');
                    this.soulBuffTurns.push(3);
                    this.updateSoulDisplay();
                    this.updateSoulCount();
                    this.updateFriendlyNodes();
                }
            }
            
            updateSoulDisplay() {
                const container = document.getElementById('soulSimpleList');
                container.innerHTML = '';
                
                for (let i = 0; i < this.maxSouls; i++) {
                    const item = document.createElement('div');
                    item.className = 'soul-simple-item';
                    
                    if (i < this.souls.length) {
                        const soul = this.souls[i];
                        const mode = this.soulModes[i];
                        
                        item.classList.add(mode);
                        item.textContent = soul;
                        
                        // 添加点击事件
                        item.style.cursor = 'pointer';
                        item.addEventListener('click', () => {
                            this.handleSoulClick(soul);
                        });
                    } else {
                        item.classList.add('empty');
                        item.textContent = '-';
                    }
                    
                    container.appendChild(item);
                }
            }
            
            updateSoulCount() {
                document.getElementById('soulCount').textContent = `${this.souls.length}/${this.maxSouls}`;
            }
            
            // 处理魂点击事件
            handleSoulClick(soulNode) {
                // 检查是否可以通过友方节点到达
                if (this.canReachThroughFriendlyNodes(soulNode)) {
                    this.showSoulTeleportModal(soulNode);
                }
            }
            
            // 检查是否可以通过友方节点到达目标
            canReachThroughFriendlyNodes(targetNode) {
                if (this.currentPos === targetNode) return false;
                
                // BFS搜索，只通过友方节点
                const visited = new Set();
                const queue = [this.currentPos];
                visited.add(this.currentPos);
                
                while (queue.length > 0) {
                    const node = queue.shift();
                    
                    // 检查邻居节点
                    for (const neighbor of this.adjacencyList[node]) {
                        if (neighbor === targetNode) {
                            return true;
                        }
                        
                        if (!visited.has(neighbor) && this.friendlyNodes.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }
                
                return false;
            }
            
            // 显示魂传送确认弹窗
            showSoulTeleportModal(targetNode) {
                const content = `
                    <div style="text-align: center;">
                        <p style="font-size: 16px; margin: 20px 0;">
                            是否传送到魂节点 <span style="color: #e2a855; font-weight: bold;">${sanitizeHTML(targetNode)}</span>？
                        </p>
                        <p style="color: #aaa; font-size: 14px;">
                            通过友方节点网络可以快速传送
                        </p>
                        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                            <button class="game-button" onclick="gameInstance.teleportToSoul(${parseInt(targetNode) || 0}); this.closest('.modal-overlay').remove()">
                                ✨ 传送
                            </button>
                            <button class="game-button settings-button" onclick="this.closest('.modal-overlay').remove()">
                                取消
                            </button>
                        </div>
                    </div>
                `;
                
                const modal = ModalManager.createModal('🌟 魂传送', content, {
                    width: '400px'
                });
                document.body.appendChild(modal);
            }
            
            // 传送到魂节点
            teleportToSoul(targetNode) {
                this.currentPos = targetNode;
                this.updateUI();
                this.renderMap();
            }
            
showSoulConfig() {
    document.getElementById('heroTimeline').textContent = this.heroUnit;
    this.renderSoulCards();
    this.renderTimeline();
    
    // 只在第一次打开时添加区域监听器
    if (!this.zoneListenersAdded) {
        this.addZoneDropListeners();
        this.zoneListenersAdded = true;
    }
    
    const modal = document.getElementById('soulConfigModal');
    modal.style.display = 'flex';
    
    // 点击背景关闭
    modal.onclick = (e) => {
        if (e.target === modal) {
            this.closeSoulConfig();
        }
    };
}
            
            renderSoulCards() {
                const waitingZone = document.getElementById('waitingSouls');
                const releaseZone = document.getElementById('releaseSouls');
                
                waitingZone.innerHTML = '';
                releaseZone.innerHTML = '';
                
                // 先收集等待模式和出战模式的魂
                const waitingSouls = [];
                const releaseSouls = [];
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'release') {
                        releaseSouls.push({soul, index});
                    } else if (this.soulModes[index] === 'none') {
                        waitingSouls.push({soul, index});
                    }
                });
                
                // 按数值排序等待区的魂
                waitingSouls.sort((a, b) => a.soul - b.soul);
                waitingSouls.forEach(({soul, index}) => {
                    const card = this.createSoulCard(soul, index);
                    waitingZone.appendChild(card);
                });
                
                // 出战区按玩家拖拽的顺序显示
                this.releaseOrder.forEach(index => {
                    if (this.soulModes[index] === 'release') {
                        const soul = this.souls[index];
                        const card = this.createSoulCard(soul, index);
                        releaseZone.appendChild(card);
                    }
                });
            }
            
            createSoulCard(soul, index) {
                const card = document.createElement('div');
                card.className = 'soul-card';
                card.draggable = true;
                card.dataset.soulIndex = index;
                card.dataset.soulValue = soul;
                
                const mode = this.soulModes[index];
                if (mode === 'release') {
                    card.classList.add('in-release');
                } else if (mode === 'buff') {
                    card.classList.add('in-timeline');
                }
                
                card.innerHTML = `
                    <div class="soul-number">${soul}</div>
                    <div class="soul-mode-indicator">${this.getModeText(mode)}</div>
                `;
                
                this.addDragListeners(card);
                return card;
            }
            
            getModeText(mode) {
                switch(mode) {
                    case 'release': return '释放';
                    case 'buff': return '增益';
                    default: return '等待';
                }
            }
            
            renderTimeline() {
                const turnsContainer = document.getElementById('timelineTurns');
                turnsContainer.innerHTML = '';
                
                for (let turn = 2; turn <= 200; turn++) {
                    const turnDiv = document.createElement('div');
                    turnDiv.className = 'timeline-turn';
                    turnDiv.dataset.turn = turn;
                    
                    const heroValue = this.heroUnit % turn;
                    
                    turnDiv.innerHTML = `
                        <div class="timeline-turn-number">T${turn}</div>
                        <div class="timeline-hero-value">${heroValue}</div>
                        <div class="timeline-soul-slot" data-turn="${turn}"></div>
                    `;
                    
                    turnsContainer.appendChild(turnDiv);
                    this.addTimelineDropListeners(turnDiv);
                }
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'buff') {
                        this.placeSoulOnTimeline(soul, index, this.soulBuffTurns[index]);
                    }
                });
            }
            
            addTimelineDropListeners(element) {
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    element.classList.add('drop-zone');
                });
                
                element.addEventListener('dragleave', () => {
                    element.classList.remove('drop-zone');
                });
                
                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    element.classList.remove('drop-zone');
                    
                    const soulIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const turn = parseInt(element.dataset.turn);
                    
                    if (turn && !isNaN(soulIndex)) {
                        this.setSoulMode(soulIndex, 'buff');
                        this.setSoulBuffTurn(soulIndex, turn);
                        this.refreshSoulConfig();
                    }
                });
            }
            
            addZoneDropListeners() {
                const zones = document.querySelectorAll('.soul-cards');
                zones.forEach(zone => {
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        zone.parentElement.style.borderColor = '#4a90e2';
                    });
                    
                    zone.addEventListener('dragleave', () => {
                        zone.parentElement.style.borderColor = '';
                    });
                    
                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.parentElement.style.borderColor = '';
                        
                        const soulIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const isReleaseZone = zone.id === 'releaseSouls';
                        
                        if (!isNaN(soulIndex)) {
                            if (isReleaseZone) {
                                // 添加到出战区并记录顺序
                                this.setSoulMode(soulIndex, 'release');
                                // 如果不在释放顺序中，添加到末尾
                                if (!this.releaseOrder.includes(soulIndex)) {
                                    this.releaseOrder.push(soulIndex);
                                }
                            } else {
                                // 从出战区移除并从顺序记录中删除
                                this.setSoulMode(soulIndex, 'none');
                                this.releaseOrder = this.releaseOrder.filter(idx => idx !== soulIndex);
                            }
                            this.refreshSoulConfig();
                        }
                    });
                });
            }
            
            placeSoulOnTimeline(soul, index, turn) {
                const slot = document.querySelector(`[data-turn="${turn}"] .timeline-soul-slot`);
                if (slot && !slot.classList.contains('occupied')) {
                    slot.classList.add('occupied');
                    slot.innerHTML = `
                        <div class="timeline-soul-card" data-soul-index="${index}" title="点击移除">
                            ${soul}
                        </div>
                    `;
                    
                    const soulCard = slot.querySelector('.timeline-soul-card');
                    if (soulCard) {
                        soulCard.addEventListener('click', () => {
                            this.removeSoulFromTimeline(index);
                        });
                    }
                }
            }
            
            addDragListeners(card) {
                card.addEventListener('dragstart', (e) => {
                    const soulIndex = card.dataset.soulIndex;
                    
                    // Mark the dragging card
                    card.classList.add('dragging');
                    
                    // Hide the original card immediately (the one being dragged)
                    card.style.opacity = '0';
                    card.style.visibility = 'hidden';
                    
                    // Create a visual clone for dragging
                    const dragImage = card.cloneNode(true);
                    dragImage.style.opacity = '0.8';
                    dragImage.style.transform = 'rotate(5deg) scale(1.1)';
                    dragImage.style.position = 'absolute';
                    dragImage.style.top = '-1000px';
                    document.body.appendChild(dragImage);
                    e.dataTransfer.setDragImage(dragImage, 25, 32);
                    
                    // Clean up the clone after drag operation completes
                    const cleanup = () => {
                        if (dragImage && dragImage.parentNode) {
                            dragImage.parentNode.removeChild(dragImage);
                        }
                    };
                    
                    // Multiple cleanup strategies for reliability
                    setTimeout(cleanup, 100);
                    card.addEventListener('dragend', cleanup, { once: true });
                    document.addEventListener('drop', cleanup, { once: true });
                    
                    e.dataTransfer.setData('text/plain', soulIndex);
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                card.addEventListener('dragend', () => {
                    // Show the card again
                    card.style.opacity = '';
                    card.style.visibility = '';
                    card.classList.remove('dragging');
                });
            }
            
            refreshSoulConfig() {
                this.renderSoulCards();
                this.renderTimeline();
                this.updateSoulDisplay();
            }
            
            removeSoulFromTimeline(index) {
                const existingSoulCard = document.querySelector(`[data-soul-index="${index}"]`);
                if (existingSoulCard) {
                    const slot = existingSoulCard.parentElement;
                    slot.classList.remove('occupied');
                    slot.innerHTML = '';
                }
                
                this.setSoulMode(index, 'none');
                this.refreshSoulConfig();
            }
            
            closeSoulConfig() {
                document.getElementById('soulConfigModal').style.display = 'none';
            }
            
            setSoulMode(index, mode) {
                this.soulModes[index] = mode;
                if (mode === 'buff' && !this.soulBuffTurns[index]) {
                    this.soulBuffTurns[index] = 3;
                }
                this.updateSoulDisplay();
            }
            
            setSoulBuffTurn(index, turn) {
                this.soulBuffTurns[index] = parseInt(turn);
            }
            
            removeSoulBuff(index) {
                this.soulModes[index] = 'none';
                this.refreshSoulConfig();
            }
            
            showSettings() {
                const modal = document.getElementById('settingsModal');
                modal.style.display = 'flex';
                
                // 点击背景关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        this.closeSettings();
                    }
                };
            }
            
            closeSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }
            
            showHelp() {
                const modal = document.getElementById('helpModal');
                modal.style.display = 'flex';
                
                // 点击背景关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        this.closeHelp();
                    }
                };
            }
            
            closeHelp() {
                document.getElementById('helpModal').style.display = 'none';
            }
            
            saveGame() {
                const saveData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    gameState: {
                        currentPos: this.currentPos,
                        heroUnit: this.heroUnit,
                        bossNode: this.bossNode,
                        battleCount: this.battleCount,
                        souls: this.souls,
                        soulModes: this.soulModes,
                        soulBuffTurns: this.soulBuffTurns,
                        releaseOrder: this.releaseOrder,
                        conqueredNodes: Array.from(this.conqueredNodes),
                        missionCompleted: this.missionCompleted,
                        maxSouls: this.maxSouls,
                        viewRange: this.viewRange,
                        battleSpeed: this.battleSpeed,
                        soundEnabled: this.soundEnabled
                    }
                };
                
                const dataStr = JSON.stringify(saveData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                
                const exportFileDefaultName = `soulmauge_save_${new Date().getTime()}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                this.showMessage('游戏进度已保存！');
            }
            
            loadGame(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const saveData = JSON.parse(e.target.result);
                        
                        // Validate save data
                        if (!saveData.version || !saveData.gameState) {
                            throw new Error('无效的存档文件');
                        }
                        
                        // Load game state
                        const state = saveData.gameState;
                        this.currentPos = state.currentPos;
                        this.heroUnit = state.heroUnit;
                        this.bossNode = state.bossNode;
                        this.battleCount = state.battleCount;
                        this.souls = state.souls || [];
                        this.soulModes = state.soulModes || [];
                        this.soulBuffTurns = state.soulBuffTurns || [];
                        this.releaseOrder = state.releaseOrder || [];
                        this.conqueredNodes = new Set(state.conqueredNodes || []);
                        this.missionCompleted = state.missionCompleted || false;
                        this.maxSouls = state.maxSouls || 9;
                        this.viewRange = state.viewRange || 2;
                        this.battleSpeed = state.battleSpeed || 1.5;
                        this.soundEnabled = state.soundEnabled !== undefined ? state.soundEnabled : true;
                        
                        // Hide game overlay if it's showing
                        document.getElementById('gameOverlay').style.display = 'none';
                        
                        // Update UI
                        this.updateFriendlyNodes();
                        this.updateSoulDisplay();
                        this.updateSoulCount();
                        this.updateUI();
                        this.renderMap();
                        
                        // Update settings UI if elements exist
                        if (document.getElementById('viewRange')) {
                            document.getElementById('viewRange').textContent = this.viewRange;
                        }
                        if (document.getElementById('viewRangeSlider')) {
                            document.getElementById('viewRangeSlider').value = this.viewRange;
                        }
                        if (document.getElementById('battleSpeedSlider')) {
                            document.getElementById('battleSpeedSlider').value = this.battleSpeed;
                        }
                        if (document.getElementById('soundToggle')) {
                            document.getElementById('soundToggle').checked = this.soundEnabled;
                        }
                        
                        this.showMessage('游戏进度已读取！');
                    } catch (error) {
                        console.error('Failed to load save:', error);
                        this.showMessage('读取存档失败：' + error.message);
                    }
                };
                reader.readAsText(file);
            }
            
            updateUI() {
                document.getElementById('currentPos').textContent = this.currentPos || '-';
                document.getElementById('battleCount').textContent = this.battleCount;
                document.getElementById('heroUnit').textContent = this.heroUnit || '-';
                document.getElementById('bossTarget').textContent = this.bossNode || '-';
                
                if (this.missionCompleted) {
                    document.getElementById('missionStatus').style.display = 'flex';
                }
            }
            
            onGameWin() {
                // 标记任务完成
                this.missionCompleted = true;
                document.getElementById('missionStatus').style.display = 'flex';
                
                setTimeout(() => {
                    const victoryMessage = this.getVictoryMessage();
                    alert(`🎉 恭喜！${victoryMessage}\n\n✅ 使命完成！你可以继续探索数字魂域的奥秘。`);
                }, 2000);
            }
            
            getVictoryMessage() {
                if (this.heroUnit === 23 && this.bossNode === 419) {
                    return '质数之王的挑战已经完成！你掌握了数字域的核心奥秘！';
                } else if (this.heroUnit === 13 && this.bossNode === 203) {
                    return '兵临城下的传说落下帷幕！古老力量-1的威能震撼了整个战场！';
                } else if (this.heroUnit === 3 && this.bossNode === 300) {
                    return '拿破仑的征服之路达到了巅峰！从科西嘉岛到欧洲大陆，传奇永存！';
                } else {
                    return '你的自创传奇已经完成！数字魂域因你的传说而更加辉煌！';
                }
            }
            
            setupEventListeners() {
                // 剧本选择
                document.querySelectorAll('.scenario-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // 移除所有active类
                        document.querySelectorAll('.scenario-item').forEach(i => i.classList.remove('active'));
                        document.querySelectorAll('.scenario-panel').forEach(p => p.classList.remove('active'));
                        
                        // 添加active类
                        item.classList.add('active');
                        const scenario = item.dataset.scenario;
                        document.getElementById(`${scenario}-panel`).classList.add('active');
                    });
                });
                
                // 开始游戏按钮
                document.getElementById('startGameBtn').addEventListener('click', () => {
                    const activeScenario = document.querySelector('.scenario-item.active').dataset.scenario;
                    const soulCapacity = parseInt(document.querySelector('input[name="soulCapacity"]:checked').value);
                    
                    let hero, boss;
                    
                    switch(activeScenario) {
                        case 'classic':
                            hero = 23;
                            boss = 419;
                            break;
                        case 'siege':
                            hero = 13;
                            boss = 203;
                            // 兵临城下剧本：给玩家一个-1的魂
                            this.souls.push(-1);
                            this.soulModes.push('none');
                            this.soulBuffTurns.push(3);
                            break;
                        case 'napoleon':
                            hero = 3;
                            boss = 300;
                            break;
                        case 'custom':
                            hero = parseInt(document.getElementById('customHero').value);
                            boss = parseInt(document.getElementById('customBoss').value);
                            if (!hero || !boss || hero === boss) {
                                alert('请输入有效的英雄和魔王数字！');
                                return;
                            }
                            break;
                    }
                    
                    this.startGame(hero, boss, soulCapacity);
                });
                
                document.getElementById('configureSoulsBtn').addEventListener('click', () => {
                    this.showSoulConfig();
                });
                
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.showSettings();
                });
                
                document.getElementById('closeSoulConfigBtn').addEventListener('click', () => {
                    this.closeSoulConfig();
                });
                
                document.getElementById('closeSettingsBtn').addEventListener('click', () => {
                    this.closeSettings();
                });
                
                document.getElementById('closeHelpBtn').addEventListener('click', () => {
                    this.closeHelp();
                });
                
                // Context menu event listeners
                document.getElementById('contextBattle').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const target = this.selectedTarget;
                    this.closeContextMenu();
                    if (target) {
                        this.selectedTarget = target;
                        this.startBattle();
                    }
                });
                
                document.getElementById('contextCampaign').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const target = this.selectedTarget;
                    this.closeContextMenu();
                    if (target) {
                        // 设置选中的敌人为第一个战役目标
                        this.campaignTargets = [target];
                        this.startCampaignMode();
                    }
                });
                
                document.getElementById('contextMove').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const target = this.selectedTarget;
                    this.closeContextMenu();
                    if (target && this.canReach(target)) {
                        this.moveToNode(target);
                    }
                });
                
                document.getElementById('battleSpeedSelect').addEventListener('change', (e) => {
                    this.battleSpeed = parseFloat(e.target.value);
                });
                
                document.getElementById('viewRangeSlider').addEventListener('input', (e) => {
                    this.viewRange = parseInt(e.target.value);
                    document.getElementById('viewRange').textContent = this.viewRange;
                    this.renderMap();
                });
                
                document.getElementById('soundToggle').addEventListener('change', (e) => {
                    this.soundEnabled = e.target.checked;
                });
                
                document.getElementById('debugToggle').addEventListener('change', (e) => {
                    this.debugMode = e.target.checked;
                    this.updateDebugInfo();
                });
                
                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.zoom = Math.min(this.zoom * 1.2, 3);
                    this.renderMap();
                });
                
                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.zoom = Math.max(this.zoom / 1.2, 0.5);
                    this.renderMap();
                });
                
                document.getElementById('centerBtn').addEventListener('click', () => {
                    this.panX = 0;
                    this.panY = 0;
                    this.zoom = 1;
                    this.renderMap();
                });
                
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.showHelp();
                });
                
                document.getElementById('saveGameBtn').addEventListener('click', () => {
                    this.saveGame();
                });
                
                document.getElementById('loadGameBtn').addEventListener('click', () => {
                    document.getElementById('loadGameInput').click();
                });
                
                document.getElementById('loadGameInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadGame(file);
                        e.target.value = ''; // Reset input
                    }
                });
            }
            
            startGame(hero, boss, soulCapacity = 9) {
                this.heroUnit = hero;
                this.bossNode = boss;
                this.currentPos = hero;
                this.maxSouls = soulCapacity;
                this.conqueredNodes.add(hero);
                this.updateFriendlyNodes();
                
                document.getElementById('heroUnit').textContent = hero;
                document.getElementById('currentPos').textContent = this.currentPos;
                document.getElementById('bossTarget').textContent = boss;
                document.getElementById('gameOverlay').style.display = 'none';
                
                // 更新魂显示
                this.updateSoulDisplay();
                this.updateSoulCount();
                
                requestAnimationFrame(() => this.renderMap());
            }
            
            // Add method to safely add event listeners
            safeAddEventListener(element, event, handler, options = {}) {
                const listener = { element, event, handler, options };
                this.eventListeners.add(listener);
                element.addEventListener(event, handler, options);
                return listener;
            }
            
            // Clean up all event listeners
            cleanup() {
                this.eventListeners.forEach(({ element, event, handler, options }) => {
                    try {
                        element.removeEventListener(event, handler, options);
                    } catch (e) {
                        console.warn('Failed to remove event listener:', e);
                    }
                });
                this.eventListeners.clear();
            }
        }
        
        // 全局实例
        let gameInstance;
        
        window.addEventListener('DOMContentLoaded', () => {
            gameInstance = new SoulMageGame();
            window.gameInstance = gameInstance;
        });
    </script>
</body>
</html>
