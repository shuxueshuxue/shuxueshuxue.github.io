<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul Mage - 数字魂战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 全局隐藏滚动条 */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        *::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        html, body {
            overflow: hidden !important;
            height: 100vh !important;
            width: 100vw !important;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e0e0;
            overflow: hidden;
            position: relative;
        }
        
        html {
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(74, 144, 226, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(226, 74, 74, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
        }
        
        #mapContainer {
            flex: 1;
            background: rgba(26, 26, 26, 0.8);
            position: relative;
            min-width: 0;
            border: 2px solid #333;
            border-radius: 12px 0 0 12px;
        }
        
        #mapSvg {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px 0 0 10px;
        }
        
        #sidePanel {
            width: 350px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid #333;
            border-left: none;
            border-radius: 0 12px 12px 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-header {
            background: linear-gradient(90deg, #4a90e2 0%, #357abd 100%);
            padding: 15px;
            text-align: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border-bottom: 2px solid #333;
        }
        
        .panel-content {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel-section {
            background: rgba(32, 32, 48, 0.8);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(5px);
        }
        
        .section-title {
            color: #4a90e2;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }
        
        .status-item {
            background: rgba(0,0,0,0.3);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-value {
            color: #e2a855;
            font-weight: bold;
        }
        
        .soul-simple-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin: 10px 0;
            min-height: 60px;
            align-items: flex-start;
            align-content: flex-start;
        }
        
        .soul-simple-item {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #fff;
            position: relative;
        }
        
        .soul-simple-item.empty {
            opacity: 0.3;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
        }
        
        .soul-simple-item.release {
            border-color: #e2a855;
            background: linear-gradient(135deg, #3a3025 0%, #2a2015 100%);
        }
        
        .soul-simple-item.buff {
            border-color: #55e285;
            background: linear-gradient(135deg, #253a30 0%, #152a20 100%);
        }
        
        .game-button {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            width: 100%;
            margin: 3px 0;
        }
        
        .game-button:hover {
            background: linear-gradient(135deg, #5aa0f2 0%, #4080cd 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .game-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .stealth-button {
            background: linear-gradient(135deg, #6a4c93 0%, #553a73 100%);
        }
        
        .stealth-button:hover {
            background: linear-gradient(135deg, #7a5ca3 0%, #654a83 100%);
        }
        
        .settings-button {
            background: linear-gradient(135deg, #666 0%, #555 100%);
        }
        
        .settings-button:hover {
            background: linear-gradient(135deg, #777 0%, #666 100%);
        }
        
        /* 弹窗基础样式 */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #4a90e2;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
        }
        
        .modal-header {
            background: linear-gradient(90deg, #4a90e2 0%, #357abd 100%);
            padding: 15px 20px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.3s;
        }
        
        .modal-close:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .modal-body {
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        /* 魂配置界面 */
        .soul-config-container {
            width: 95vw;
            max-width: 1200px;
            height: 85vh;
        }
        
        .soul-management {
            display: flex;
            flex-direction: column;
            height: 100%;
            gap: 20px;
        }
        
        .soul-zones {
            display: flex;
            gap: 20px;
            height: 180px;
        }
        
        .soul-zone {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #444;
        }
        
        .soul-zone h3 {
            color: #4a90e2;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .waiting-zone {
            border-color: #666;
        }
        
        .release-zone {
            border-color: #e2a855;
            background: rgba(226, 168, 85, 0.05);
        }
        
        .release-zone h3 {
            color: #e2a855;
        }
        
        .soul-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 120px;
            align-content: flex-start;
        }
        
        .soul-card {
            width: 60px;
            height: 80px;
            background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
            border: 2px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            user-select: none;
        }
        
        .soul-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.4);
            border-color: #4a90e2;
        }
        
        .soul-card.dragging {
            cursor: grabbing;
            transform: rotate(5deg) scale(1.1);
            z-index: 1000;
            opacity: 0.8;
        }
        
        .soul-card.in-release {
            border-color: #e2a855;
            background: linear-gradient(135deg, #3a3025 0%, #2a2015 100%);
        }
        
        .soul-card.in-timeline {
            border-color: #55e285;
            background: linear-gradient(135deg, #253a30 0%, #152a20 100%);
        }
        
        .soul-number {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }
        
        .soul-mode-indicator {
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
        }
        
        .timeline-container {
            flex: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            padding: 15px;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
        }
        
        .timeline-container h3 {
            color: #55e285;
            margin: 0 0 15px 0;
            font-size: 16px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .timeline-scroll {
            flex: 1;
            overflow-x: auto;
            overflow-y: hidden;
            border: 1px solid #333;
            border-radius: 8px;
            background: rgba(0,0,0,0.2);
            scrollbar-width: thin;
            scrollbar-color: #4a90e2 rgba(0,0,0,0.3);
        }
        
        .timeline-scroll::-webkit-scrollbar {
            height: 8px;
        }
        
        .timeline-scroll::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        
        .timeline-scroll::-webkit-scrollbar-thumb {
            background: #4a90e2;
            border-radius: 4px;
        }
        
        .timeline-scroll::-webkit-scrollbar-thumb:hover {
            background: #5aa0f2;
        }
        
        .timeline-track {
            display: flex;
            align-items: center;
            height: 100%;
            min-width: 100%;
            padding: 10px;
            gap: 5px;
        }
        
        .timeline-label {
            min-width: 80px;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            font-weight: bold;
        }
        
        .timeline-turns {
            display: flex;
            gap: 3px;
            flex: 1;
        }
        
        .timeline-turn {
            min-width: 80px;
            height: 90px;
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px 6px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .timeline-turn.drop-zone {
            border-color: #55e285;
            background: rgba(85, 226, 133, 0.1);
        }
        
        .timeline-turn-number {
            font-size: 11px;
            font-weight: bold;
            color: #4a90e2;
        }
        
        .timeline-hero-value {
            font-size: 16px;
            color: #fff;
            font-weight: bold;
        }
        
        .timeline-soul-slot {
            width: 45px;
            height: 45px;
            border: 2px dashed #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .timeline-soul-slot.occupied {
            border-style: solid;
            border-color: #55e285;
            background: rgba(85, 226, 133, 0.1);
        }
        
        .timeline-soul-card {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #55e285 0%, #45c275 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .timeline-soul-card:hover {
            transform: scale(1.1);
        }
        
        .scroll-hint {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-top: 10px;
        }
        
        /* 行动选择弹窗 */
        .action-modal {
            width: 450px;
            height: 480px;
        }
        
        .action-content {
            text-align: center;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .target-display {
            font-size: 24px;
            color: #e2a855;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 20px;
        }
        
        .action-button {
            padding: 15px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .action-button.battle {
            background: linear-gradient(135deg, #e24a4a 0%, #c73a3a 100%);
            color: white;
        }
        
        .action-button.move {
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
        }
        
        .action-button.stealth {
            background: linear-gradient(135deg, #6a4c93 0%, #553a73 100%);
            color: white;
        }
        
        .action-button.campaign {
            background: linear-gradient(135deg, #e2a855 0%, #c49545 100%);
            color: white;
        }
        
        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .action-button:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
        }
        
        .campaign-mode-indicator {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, #e2a855 0%, #c49545 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(226, 168, 85, 0.4);
            animation: campaignPulse 2s ease-in-out infinite;
            z-index: 100;
        }
        
        @keyframes campaignPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(226, 168, 85, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 6px 20px rgba(226, 168, 85, 0.6);
            }
        }
        
        /* 战役模式样式 */
        .campaign-mode .node {
            transition: all 0.3s ease;
        }
        
        .campaign-mode .node:hover circle {
            r: 28 !important;
            filter: drop-shadow(0 0 10px #e2a855) !important;
        }
        
        .campaign-selectable {
            stroke: #e2a855 !important;
            stroke-width: 3 !important;
            stroke-dasharray: 8,4 !important;
            animation: selectablePulse 1.5s ease-in-out infinite !important;
        }
        
        @keyframes selectablePulse {
            0%, 100% { stroke-opacity: 0.6; }
            50% { stroke-opacity: 1; }
        }
        
        .campaign-selected {
            stroke: #e2a855 !important;
            stroke-width: 4 !important;
            filter: drop-shadow(0 0 15px #e2a855) !important;
        }
        
        .campaign-path {
            stroke: #e2a855 !important;
            stroke-width: 4 !important;
            stroke-dasharray: 10,5 !important;
            animation: campaignPathPulse 2s ease-in-out infinite !important;
        }
        
        @keyframes campaignPathPulse {
            0%, 100% { stroke-opacity: 0.6; }
            50% { stroke-opacity: 1; }
        }
        
        .campaign-info {
            position: absolute;
            top: 60px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e2a855;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }
        
        .campaign-counter {
            color: #e2a855;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .campaign-list {
            color: #ddd;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .campaign-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }
        
        .campaign-btn {
            padding: 5px 10px;
            font-size: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .campaign-btn.confirm {
            background: #e2a855;
            color: white;
        }
        
        .campaign-btn.cancel {
            background: #666;
            color: white;
        }
        
        .campaign-btn:hover {
            transform: translateY(-1px);
        }
        
        .campaign-btn:disabled {
            background: #444;
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }
        
        /* 战斗弹窗 */
        .battle-arena {
            width: 90vw;
            max-width: 1000px;
            height: 80vh;
            display: flex;
            flex-direction: column;
        }
        
        .battle-field {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 40px;
            position: relative;
        }
        
        .battle-team {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .team-label {
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .team-label.player {
            color: #4a90e2;
        }
        
        .team-label.enemy {
            color: #e24a4a;
        }
        
        .battle-units {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 300px;
        }
        
        .battle-unit {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #3a3a3a 0%, #2a2a2a 100%);
            border: 3px solid #5a5a5a;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .battle-unit.player {
            border-color: #4a90e2;
            color: #7ac0ff;
            background: linear-gradient(135deg, #2a3a4a 0%, #1a2a3a 100%);
        }
        
        .battle-unit.enemy {
            border-color: #e24a4a;
            color: #ff7a7a;
            background: linear-gradient(135deg, #4a2a2a 0%, #3a1a1a 100%);
        }
        
        .battle-unit.eliminated {
            opacity: 0.3;
            transform: scale(0.8);
            filter: grayscale(100%);
        }
        
        .battle-unit.winner {
            animation: victoryPulse 0.6s ease;
            box-shadow: 0 0 20px currentColor;
        }
        
        @keyframes victoryPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .battle-vs {
            font-size: 36px;
            font-weight: bold;
            color: #e2a855;
            text-shadow: 0 0 10px rgba(226, 168, 85, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(226, 168, 85, 0.5); }
            to { text-shadow: 0 0 20px rgba(226, 168, 85, 0.8), 0 0 30px rgba(226, 168, 85, 0.4); }
        }
        
        .turn-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            border: 2px solid #4a90e2;
        }
        
        .damage-number {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #e2a855;
            animation: floatUp 1s ease-out;
            pointer-events: none;
        }
        
        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-40px);
            }
        }
        
        .soul-effect {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, #55e285 0%, transparent 70%);
            border-radius: 50%;
            animation: soulGlow 0.4s ease;
        }
        
        @keyframes soulGlow {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }
        
        .battle-controls {
            padding: 15px;
            text-align: center;
            border-top: 1px solid #333;
            background: rgba(0,0,0,0.3);
            flex-shrink: 0;
        }
        
        /* 设置界面 */
        .settings-modal {
            width: 500px;
            height: 400px;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #333;
        }
        
        .setting-slider {
            width: 200px;
        }
        
        /* 开始界面和开场动画 */
        #gameOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(0,0,0,0.98) 0%, rgba(26,26,46,0.98) 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .game-modal {
            background: linear-gradient(135deg, #202040 0%, #16213e 100%);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #4a90e2;
            text-align: center;
            max-width: 600px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            position: relative;
        }
        
        .game-modal::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 144, 226, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .modal-title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 15px;
            background: linear-gradient(90deg, #4a90e2, #e24a4a, #55e285);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .story-text {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            line-height: 1.6;
            color: #ddd;
            border-left: 4px solid #4a90e2;
            position: relative;
            opacity: 0;
            animation: fadeInUp 1s ease 0.5s forwards;
            font-size: 14px;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .opening-animation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 1;
            transition: opacity 1s ease;
            overflow: hidden;
        }
        
        .opening-animation.fade-out {
            opacity: 0;
            pointer-events: none;
        }
        
        .opening-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(90deg, #4a90e2, #e24a4a, #55e285);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 2s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        .opening-subtitle {
            font-size: 18px;
            color: #bbb;
            margin-bottom: 40px;
            opacity: 0;
            animation: fadeIn 1s ease 1s forwards;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .opening-particles {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #4a90e2;
            border-radius: 50%;
            animation: float 6s linear infinite;
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg);
                opacity: 0;
            }
        }
        
        .scenario-select {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            opacity: 0;
            animation: fadeInUp 1s ease 1.5s forwards;
        }
        
        .scenario-option {
            padding: 25px;
            background: linear-gradient(135deg, #3a3a5a 0%, #2a2a4a 100%);
            border: 3px solid #5a5a7a;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }
        
        .scenario-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.6s;
        }
        
        .scenario-option:hover {
            background: linear-gradient(135deg, #4a4a6a 0%, #3a3a5a 100%);
            border-color: #7a7a9a;
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0,0,0,0.4);
        }
        
        .scenario-option:hover::before {
            left: 100%;
        }
        
        .scenario-title {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #e2a855;
        }
        
        .scenario-desc {
            font-size: 14px;
            color: #ccc;
            line-height: 1.6;
        }
        
        .custom-inputs {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
        }
        
        .custom-input {
            width: 90px;
            padding: 10px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.4);
            color: white;
            border-radius: 6px;
            text-align: center;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        .custom-input:focus {
            border-color: #4a90e2;
            outline: none;
        }
        
        /* 地图样式 */
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover circle {
            r: 25;
        }
        
        .edge {
            stroke: #444;
            stroke-width: 2;
            opacity: 0.6;
        }
        
        .current-node {
            stroke: #4a90e2;
            stroke-width: 4;
            filter: drop-shadow(0 0 10px #4a90e2);
        }
        
        .boss-node {
            fill: #e24a4a;
            filter: drop-shadow(0 0 15px #e24a4a);
        }
        
        .friendly-node {
            fill: #4a90e2;
            filter: drop-shadow(0 0 8px #4a90e2);
        }
        
        .conquered-node {
            fill: #666;
            opacity: 0.7;
        }
        
        .reachable-node {
            stroke: #7ac0ff;
            stroke-width: 3;
            stroke-dasharray: 5,5;
            animation: reachablePulse 2s ease-in-out infinite;
        }
        
        @keyframes reachablePulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 1; }
        }
        
        .map-controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0,0,0,0.8);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(5px);
        }
        
        .zoom-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }
        
        .zoom-controls .game-button {
            padding: 6px 10px;
            font-size: 10px;
            width: auto;
            margin: 0;
        }

        /* 战役调试信息 */
        .campaign-debug {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0,0,0,0.9);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            color: #aaa;
            font-size: 11px;
            max-width: 300px;
            display: none;
        }
        
        .campaign-debug.show {
            display: block;
        }
    </style>
</head>
<body>
    <!-- 开场动画 -->
    <div class="opening-animation" id="openingAnimation">
        <div class="opening-particles" id="particles"></div>
        <div class="opening-title">🔮 SOUL MAGE</div>
        <div class="opening-subtitle">数字魂战传奇即将开始...</div>
    </div>

    <div id="gameContainer">
        <div id="mapContainer">
            <div class="map-controls">
                <div class="zoom-controls">
                    <button class="game-button" id="zoomInBtn">放大</button>
                    <button class="game-button" id="zoomOutBtn">缩小</button>
                    <button class="game-button" id="centerBtn">居中</button>
                </div>
                <div style="color: #aaa; font-size: 11px;">
                    视野范围: <span id="viewRange">2</span> 步
                </div>
            </div>
            
            <!-- 战役调试信息 -->
            <div class="campaign-debug" id="campaignDebug">
                <div>战役模式: <span id="debugCampaignMode">否</span></div>
                <div>目标数量: <span id="debugTargetCount">0</span></div>
                <div>目标列表: <span id="debugTargetList">无</span></div>
                <div>当前位置: <span id="debugCurrentPos">-</span></div>
            </div>
            
            <svg id="mapSvg"></svg>
        </div>
        
        <div id="sidePanel">
            <div class="panel-header">
                🔮 SOUL MAGE
            </div>
            
            <div class="panel-content">
                <div class="panel-section">
                    <div class="section-title">⚡ 状态</div>
                    <div class="status-grid">
                        <div class="status-item">
                            <span>当前位置</span>
                            <span class="status-value" id="currentPos">-</span>
                        </div>
                        <div class="status-item">
                            <span>主角单位</span>
                            <span class="status-value" id="heroUnit">-</span>
                        </div>
                        <div class="status-item">
                            <span>目标BOSS</span>
                            <span class="status-value" id="bossTarget">-</span>
                        </div>
                        <div class="status-item">
                            <span>潜行机会</span>
                            <span class="status-value" id="stealthCount">3</span>
                        </div>
                        <div class="status-item">
                            <span>战斗次数</span>
                            <span class="status-value" id="battleCount">0</span>
                        </div>
                        <div class="status-item">
                            <span>收集魂数</span>
                            <span class="status-value" id="soulCount">0/9</span>
                        </div>
                    </div>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">💎 魂库</div>
                    <div class="soul-simple-list" id="soulSimpleList"></div>
                    <button class="game-button" id="configureSoulsBtn">⚙️ 配置魂策略</button>
                </div>
                
                <div class="panel-section">
                    <div class="section-title">🎮 操作</div>
                    <button class="settings-button game-button" id="settingsBtn">⚙️ 游戏设置</button>
                    <button class="game-button" id="helpBtn">❓ 游戏说明</button>
                    <button class="game-button" id="campaignModeBtn">🏛️ 战役模式</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 魂配置弹窗 -->
    <div class="modal-overlay" id="soulConfigModal">
        <div class="modal-content soul-config-container">
            <div class="modal-header">
                <span>💎 魂战略配置</span>
                <button class="modal-close" id="closeSoulConfigBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="soul-management">
                    <div class="soul-zones">
                        <div class="soul-zone waiting-zone">
                            <h3>💤 等待区</h3>
                            <div class="soul-cards" id="waitingSouls"></div>
                        </div>
                        <div class="soul-zone release-zone">
                            <h3>⚔️ 释放区</h3>
                            <div class="soul-cards" id="releaseSouls"></div>
                        </div>
                    </div>
                    <div class="timeline-container">
                        <h3>⏰ 增益时间线</h3>
                        <div class="timeline-scroll" id="timelineScroll">
                            <div class="timeline-track" id="timelineTrack">
                                <div class="timeline-label">主角<br><span id="heroTimeline">23</span></div>
                                <div class="timeline-turns" id="timelineTurns"></div>
                            </div>
                        </div>
                        <div class="scroll-hint">← 向左滑动查看更多回合 →</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 行动选择弹窗 -->
    <div class="modal-overlay" id="actionModal">
        <div class="modal-content action-modal">
            <div class="modal-header">
                <span>🎯 选择行动</span>
                <button class="modal-close" id="closeActionModalBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="action-content">
                    <div>目标节点</div>
                    <div class="target-display" id="actionTarget">-</div>
                    <div class="action-buttons">
                        <button class="action-button battle" id="battleActionBtn">⚔️ 发起战斗</button>
                        <button class="action-button move" id="moveActionBtn">🚶 移动过去</button>
                        <button class="action-button stealth" id="stealthActionBtn">🥷 潜行移动</button>
                        <button class="action-button campaign" id="campaignActionBtn">🏛️ 开始战役</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 战斗弹窗 -->
    <div class="modal-overlay" id="battleModal">
        <div class="modal-content battle-arena">
            <div class="modal-header">
                <span>⚔️ 数字魂战</span>
                <div style="font-size: 14px; opacity: 0.8;">速度: <span id="battleSpeedDisplay">正常</span></div>
            </div>
            <div class="battle-field">
                <div class="turn-display" id="turnDisplay">准备战斗...</div>
                
                <div class="battle-team">
                    <div class="team-label player">👑 我方</div>
                    <div class="battle-units" id="playerBattleUnits"></div>
                </div>
                
                <div class="battle-vs">VS</div>
                
                <div class="battle-team">
                    <div class="team-label enemy">💀 敌方</div>
                    <div class="battle-units" id="enemyBattleUnits"></div>
                </div>
            </div>
            <div class="battle-controls">
                <button class="game-button" id="closeBattleBtn" style="display: none;">关闭</button>
            </div>
        </div>
    </div>
    
    <!-- 游戏帮助弹窗 -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <span>❓ 游戏说明</span>
                <button class="modal-close" id="closeHelpBtn">&times;</button>
            </div>
            <div class="modal-body" style="overflow-y: auto; max-height: 70vh;">
                <div style="line-height: 1.8; color: #ddd;">
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🎯 游戏目标</h3>
                    <p>击败BOSS成为真正的Soul Mage！通过征服数字节点，收集并合理运用魂的力量。</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🏰 节点类型</h3>
                    <p>• <span style="color: #4a90e2;">蓝色发光</span>：友方节点（可自由移动）<br>
                    • <span style="color: #666;">灰色</span>：敌方已征服节点<br>
                    • <span style="color: #e24a4a;">红色发光</span>：BOSS节点<br>
                    • <span style="color: #4a90e2;">蓝色边框</span>：当前位置</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">💎 魂的机制</h3>
                    <p>• <span style="color: #e2a855;">释放模式</span>：魂作为战斗单位参战，胜利后成为友方节点<br>
                    • <span style="color: #55e285;">增益模式</span>：在指定回合为主角提供额外攻击力<br>
                    • <span style="color: #666;">等待模式</span>：暂不使用，保留备用</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">⚔️ 战斗规则</h3>
                    <p>• 每回合比较 (数字 % 回合数) 的最大值<br>
                    • 连续赢3回合随机消灭对方一个单位<br>
                    • 魂增益时取 max(主角攻击力, 魂攻击力)<br>
                    • 所有单位被消灭的一方失败</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🏛️ 战役系统</h3>
                    <p>• <span style="color: #e2a855;">大型战役</span>：可同时宣战多个连续节点（最多7个）<br>
                    • 所有战役目标的敌人和额外单位全部参战<br>
                    • 胜利后同时收获所有目标节点的魂<br>
                    • 直接跳到战役路径的末端位置</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🎮 行动选项</h3>
                    <p>• <span style="color: #e24a4a;">发起战斗</span>：与目标节点及其盟友战斗<br>
                    • <span style="color: #4a90e2;">普通移动</span>：直接移动并征服敌方节点<br>
                    • <span style="color: #6a4c93;">潜行移动</span>：消耗潜行次数，静默征服节点<br>
                    • <span style="color: #e2a855;">开始战役</span>：进入战役模式选择多个目标</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🥷 潜行系统</h3>
                    <p>• 初始有3次潜行机会<br>
                    • 每赢得10场战斗可获得1次额外潜行机会<br>
                    • 潜行可避免战斗直接征服节点</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🗺️ 地图连接</h3>
                    <p>两个数字节点之间存在连接的条件：它们的差值是两数的公共质因数。</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">⚙️ 可配置项</h3>
                    <p>• 战斗速度：0.5x - 2x<br>
                    • 视野范围：1-4步<br>
                    • 魂的战略配置：拖拽管理，支持到回合100</p>
                    
                    <h3 style="color: #4a90e2; margin: 20px 0 10px 0;">🎮 操作技巧</h3>
                    <p>• 点击节点选择行动方式<br>
                    • 拖拽魂卡片到不同区域来设置策略<br>
                    • 时间线可横向滚动查看更多回合<br>
                    • 战役模式：选择连续节点构建战役路径<br>
                    • 合理安排魂的释放和增益时机</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 设置弹窗 -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal-content settings-modal">
            <div class="modal-header">
                <span>⚙️ 游戏设置</span>
                <button class="modal-close" id="closeSettingsBtn">&times;</button>
            </div>
            <div class="modal-body">
                <div class="setting-item">
                    <span>战斗速度</span>
                    <select class="setting-slider" id="battleSpeedSelect">
                        <option value="0.5">慢速 (0.5x)</option>
                        <option value="1" selected>正常 (1x)</option>
                        <option value="1.5">快速 (1.5x)</option>
                        <option value="2">极快 (2x)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>视野范围</span>
                    <input type="range" class="setting-slider" id="viewRangeSlider" min="1" max="4" value="2">
                </div>
                <div class="setting-item">
                    <span>音效开关</span>
                    <input type="checkbox" id="soundToggle" checked>
                </div>
                <div class="setting-item">
                    <span>调试模式</span>
                    <input type="checkbox" id="debugToggle">
                </div>
            </div>
        </div>
    </div>
    
    <!-- 游戏开始界面 -->
    <div id="gameOverlay">
        <div class="game-modal">
            <h1 class="modal-title">🔮 SOUL MAGE</h1>
            <div class="story-text" id="storyText">
                <strong>数字魂域传说</strong><br><br>
                在数字宇宙中，每个数字都蕴含着强大的力量。作为年轻的魂法师学徒，你将通过征服数字节点，收集并释放数字之魂来掌握魂法的奥秘。<br><br>
                <em>现在，选择你的命运...</em>
            </div>
            
            <div class="scenario-select">
                <div class="scenario-option" data-hero="23" data-boss="419">
                    <div class="scenario-title">💫 数字传奇：23与419的宿命对决</div>
                    <div class="scenario-desc">
                        神秘质数23对决数字域霸主419，只有真正的魂法师才能驾驭这股力量！
                    </div>
                </div>
                
                <div class="scenario-option custom-scenario">
                    <div class="scenario-title">🎨 自定义传奇</div>
                    <div class="scenario-desc">选择你的英雄和终极挑战</div>
                    <div class="custom-inputs">
                        <input type="number" class="custom-input" id="customHero" placeholder="英雄" min="2" max="999">
                        <span style="color: #e2a855; font-size: 20px;">⚔️</span>
                        <input type="number" class="custom-input" id="customBoss" placeholder="BOSS" min="2" max="999">
                        <button class="game-button" id="startCustomBtn" style="width: auto; margin: 0; padding: 10px 20px;">开始传奇</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        class SoulMageGame {
            constructor() {
                this.mapSize = 500;
                this.bossNode = 419;
                this.nodes = [];
                this.edges = [];
                this.adjacencyList = {};
                this.currentPos = null;
                this.heroUnit = null;
                this.souls = [];
                this.maxSouls = 9;
                this.conqueredNodes = new Set();
                this.friendlyNodes = new Set();
                this.battleInProgress = false;
                this.stealthCount = 3;
                this.battleCount = 0;
                this.viewRange = 2;
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;
                this.beforeBattleState = null;
                this.selectedTarget = null;
                
                // 战役模式相关
                this.campaignMode = false;
                this.campaignTargets = [];
                this.maxCampaignLength = 7;
                
                this.soulModes = [];
                this.soulBuffTurns = [];
                
                this.battleSpeed = 1;
                this.soundEnabled = true;
                this.debugMode = false;
                
                this.initializeGame();
            }
            
            initializeGame() {
                this.showOpeningAnimation();
                this.setupEventListeners();
                this.generateMap();
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
            }
            
            showOpeningAnimation() {
                try {
                    const particlesContainer = document.getElementById('particles');
                    if (!particlesContainer) {
                        console.warn('Particles container not found');
                        return;
                    }
                    
                    for (let i = 0; i < 50; i++) {
                        setTimeout(() => {
                            const particle = document.createElement('div');
                            particle.className = 'particle';
                            particle.style.left = Math.random() * 100 + '%';
                            particle.style.animationDelay = Math.random() * 6 + 's';
                            particle.style.animationDuration = (4 + Math.random() * 4) + 's';
                            
                            const colors = ['#4a90e2', '#e24a4a', '#55e285', '#e2a855'];
                            particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                            
                            particlesContainer.appendChild(particle);
                        }, i * 100);
                    }
                    
                    setTimeout(() => {
                        const opening = document.getElementById('openingAnimation');
                        if (opening) {
                            opening.classList.add('fade-out');
                            setTimeout(() => {
                                opening.style.display = 'none';
                            }, 1000);
                        }
                    }, 3000);
                } catch (error) {
                    console.error('Error in showOpeningAnimation:', error);
                }
            }
            
            generateMap() {
                console.log('生成地图中...');
                const startTime = performance.now();
                
                for (let i = 2; i <= this.mapSize; i++) {
                    this.nodes.push(i);
                    this.adjacencyList[i] = [];
                }
                
                let edgeCount = 0;
                const maxEdges = 5000;
                
                for (let i = 0; i < this.nodes.length && edgeCount < maxEdges; i++) {
                    for (let j = i + 1; j < this.nodes.length && edgeCount < maxEdges; j++) {
                        const a = this.nodes[i];
                        const b = this.nodes[j];
                        const diff = Math.abs(a - b);
                        
                        if (this.isCommonPrimeFactor(a, b, diff)) {
                            this.edges.push([a, b]);
                            this.adjacencyList[a].push(b);
                            this.adjacencyList[b].push(a);
                            edgeCount++;
                        }
                    }
                }
                
                const endTime = performance.now();
                console.log(`地图生成完成，用时 ${(endTime - startTime).toFixed(2)}ms，共${edgeCount}条边`);
            }
            
            primeCache = new Map();
            
            isCommonPrimeFactor(a, b, diff) {
                if (diff === 1) return false;
                if (!this.isPrime(diff)) return false;
                return a % diff === 0 && b % diff === 0;
            }
            
            isPrime(n) {
                if (this.primeCache.has(n)) {
                    return this.primeCache.get(n);
                }
                
                if (n < 2) {
                    this.primeCache.set(n, false);
                    return false;
                }
                
                for (let i = 2; i * i <= n; i++) {
                    if (n % i === 0) {
                        this.primeCache.set(n, false);
                        return false;
                    }
                }
                
                this.primeCache.set(n, true);
                return true;
            }
            
            updateFriendlyNodes() {
                this.friendlyNodes.clear();
                if (this.heroUnit) {
                    this.friendlyNodes.add(this.heroUnit);
                }
                this.souls.forEach(soul => {
                    this.friendlyNodes.add(soul);
                });
            }
            
            getVisibleNodes() {
                if (!this.currentPos) return [];
                
                const visited = new Set();
                const queue = [{node: this.currentPos, distance: 0}];
                const visibleNodes = [];
                
                if (this.campaignMode && this.campaignTargets.length > 0) {
                    this.campaignTargets.forEach(target => {
                        if (!visited.has(target)) {
                            queue.push({node: target, distance: 0});
                        }
                    });
                }
                
                while (queue.length > 0) {
                    const {node, distance} = queue.shift();
                    
                    if (visited.has(node)) continue;
                    visited.add(node);
                    visibleNodes.push(node);
                    
                    if (distance < this.viewRange) {
                        this.adjacencyList[node].forEach(neighbor => {
                            if (!visited.has(neighbor)) {
                                queue.push({node: neighbor, distance: distance + 1});
                            }
                        });
                    }
                }
                
                return visibleNodes;
            }
            
            renderMap() {
                const svg = document.getElementById('mapSvg');
                const rect = svg.getBoundingClientRect();
                const width = rect.width;
                const height = rect.height;
                
                if (width <= 0 || height <= 0) {
                    setTimeout(() => this.renderMap(), 100);
                    return;
                }
                
                this.manageCampaignModeIndicator();
                this.updateDebugInfo();
                
                if (!this.campaignMode) {
                    const infoDiv = document.getElementById('campaignInfo');
                    if (infoDiv) {
                        infoDiv.remove();
                    }
                }
                
                const visibleNodes = this.getVisibleNodes();
                if (visibleNodes.length === 0) {
                    console.warn('没有可见节点。当前位置:', this.currentPos);
                    return;
                }
                
                const visibleEdges = this.edges.filter(([a, b]) => 
                    visibleNodes.includes(a) && visibleNodes.includes(b)
                );
                
                const positions = this.forceDirectedLayout(visibleNodes, visibleEdges, width, height);
                
                svg.innerHTML = '';
                
                const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                mainGroup.setAttribute('transform', `translate(${width/2 + this.panX}, ${height/2 + this.panY}) scale(${this.zoom})`);
                
                if (this.campaignMode) {
                    svg.classList.add('campaign-mode');
                } else {
                    svg.classList.remove('campaign-mode');
                }
                
                visibleEdges.forEach(([a, b]) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', positions[a].x);
                    line.setAttribute('y1', positions[a].y);
                    line.setAttribute('x2', positions[b].x);
                    line.setAttribute('y2', positions[b].y);
                    line.setAttribute('class', 'edge');
                    mainGroup.appendChild(line);
                });
                
                visibleNodes.forEach(node => {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'node');
                    g.setAttribute('transform', `translate(${positions[node].x},${positions[node].y})`);
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', '20');
                    circle.setAttribute('fill', '#2a2a2a');
                    
                    if (node === this.bossNode) {
                        circle.classList.add('boss-node');
                    } else if (node === this.currentPos) {
                        circle.classList.add('current-node');
                    } else if (this.friendlyNodes.has(node)) {
                        circle.classList.add('friendly-node');
                    } else if (this.conqueredNodes.has(node)) {
                        circle.classList.add('conquered-node');
                    }
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dy', '5');
                    text.setAttribute('fill', 'white');
                    text.setAttribute('font-size', '14');
                    text.textContent = node;
                    
                    g.appendChild(circle);
                    g.appendChild(text);
                    
                    g.addEventListener('click', () => this.onNodeClick(node));
                    
                    mainGroup.appendChild(g);
                });
                
                svg.appendChild(mainGroup);
                this.nodePositions = positions;
                
                if (this.campaignMode) {
                    this.highlightCampaignSelectableNodes();
                    if (this.campaignTargets.length > 0) {
                        this.highlightCampaignPath();
                    }
                } else {
                    this.highlightReachableNodes();
                }
            }
            
            updateDebugInfo() {
                if (this.debugMode) {
                    document.getElementById('campaignDebug').classList.add('show');
                    document.getElementById('debugCampaignMode').textContent = this.campaignMode ? '是' : '否';
                    document.getElementById('debugTargetCount').textContent = this.campaignTargets.length;
                    document.getElementById('debugTargetList').textContent = this.campaignTargets.length > 0 ? this.campaignTargets.join(', ') : '无';
                    document.getElementById('debugCurrentPos').textContent = this.currentPos || '-';
                } else {
                    document.getElementById('campaignDebug').classList.remove('show');
                }
            }
            
            manageCampaignModeIndicator() {
                let indicator = document.getElementById('campaignModeIndicator');
                
                if (this.campaignMode) {
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.id = 'campaignModeIndicator';
                        indicator.className = 'campaign-mode-indicator';
                        document.getElementById('mapContainer').appendChild(indicator);
                    }
                    
                    if (this.campaignTargets.length === 0) {
                        indicator.textContent = '🏛️ 战役模式：选择第一个目标';
                    } else {
                        indicator.textContent = `🏛️ 战役模式：选择下一个目标 (${this.campaignTargets.length}/${this.maxCampaignLength})`;
                    }
                } else {
                    if (indicator) {
                        indicator.remove();
                    }
                }
            }
            
            highlightCampaignSelectableNodes() {
                const selectableNodes = this.getCampaignSelectableNodes();
                console.log('战役可选择节点:', selectableNodes);
                
                selectableNodes.forEach(node => {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach(nodeGroup => {
                        const text = nodeGroup.querySelector('text');
                        if (text && parseInt(text.textContent) === node) {
                            const circle = nodeGroup.querySelector('circle');
                            if (circle) {
                                circle.classList.add('campaign-selectable');
                            }
                        }
                    });
                });
            }
            
            getCampaignSelectableNodes() {
                if (this.campaignTargets.length === 0) {
                    const reachable = this.adjacencyList[this.currentPos] || [];
                    console.log('第一个目标可选择:', reachable);
                    return reachable;
                } else {
                    const lastTarget = this.campaignTargets[this.campaignTargets.length - 1];
                    const selectable = this.adjacencyList[lastTarget].filter(node => 
                        !this.campaignTargets.includes(node) && 
                        node !== this.currentPos
                    );
                    console.log('后续目标可选择 (从', lastTarget, '):', selectable);
                    return selectable;
                }
            }
            
            forceDirectedLayout(nodes, edges, width, height) {
                const positions = {};
                const centerX = 0;
                const centerY = 0;
                const minDistance = 60;
                
                if (this.currentPos && nodes.includes(this.currentPos)) {
                    positions[this.currentPos] = {x: centerX, y: centerY};
                }
                
                const otherNodes = nodes.filter(n => n !== this.currentPos);
                otherNodes.forEach((node, i) => {
                    let attempts = 0;
                    let validPosition = false;
                    
                    while (!validPosition && attempts < 100) {
                        const angle = (i / otherNodes.length) * 2 * Math.PI + attempts * 0.1;
                        const radius = 80 + attempts * 5;
                        const x = centerX + Math.cos(angle) * radius;
                        const y = centerY + Math.sin(angle) * radius;
                        
                        validPosition = true;
                        for (const [existingNode, pos] of Object.entries(positions)) {
                            const dx = x - pos.x;
                            const dy = y - pos.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < minDistance) {
                                validPosition = false;
                                break;
                            }
                        }
                        
                        if (validPosition) {
                            positions[node] = {x, y};
                        }
                        attempts++;
                    }
                    
                    if (!validPosition) {
                        const angle = (i / otherNodes.length) * 2 * Math.PI;
                        const radius = 120 + i * 10;
                        positions[node] = {
                            x: centerX + Math.cos(angle) * radius,
                            y: centerY + Math.sin(angle) * radius
                        };
                    }
                });
                
                for (let iter = 0; iter < 50; iter++) {
                    const forces = {};
                    nodes.forEach(node => {
                        forces[node] = {x: 0, y: 0};
                    });
                    
                    for (let i = 0; i < nodes.length; i++) {
                        for (let j = i + 1; j < nodes.length; j++) {
                            const a = nodes[i];
                            const b = nodes[j];
                            const dx = positions[b].x - positions[a].x;
                            const dy = positions[b].y - positions[a].y;
                            const dist = Math.sqrt(dx*dx + dy*dy) + 0.01;
                            
                            if (dist < minDistance) {
                                const force = (minDistance - dist) * 2;
                                forces[a].x -= dx/dist * force;
                                forces[a].y -= dy/dist * force;
                                forces[b].x += dx/dist * force;
                                forces[b].y += dy/dist * force;
                            } else {
                                const force = 300 / (dist * dist);
                                forces[a].x -= dx/dist * force;
                                forces[a].y -= dy/dist * force;
                                forces[b].x += dx/dist * force;
                                forces[b].y += dy/dist * force;
                            }
                        }
                    }
                    
                    edges.forEach(([a, b]) => {
                        if (positions[a] && positions[b]) {
                            const dx = positions[b].x - positions[a].x;
                            const dy = positions[b].y - positions[a].y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const idealDist = 90;
                            const force = (dist - idealDist) * 0.05;
                            
                            forces[a].x += dx/dist * force;
                            forces[a].y += dy/dist * force;
                            forces[b].x -= dx/dist * force;
                            forces[b].y -= dy/dist * force;
                        }
                    });
                    
                    nodes.forEach(node => {
                        if (node === this.currentPos) return;
                        
                        positions[node].x += forces[node].x * 0.1;
                        positions[node].y += forces[node].y * 0.1;
                        
                        const maxDist = Math.min(width, height) * 0.35;
                        const dist = Math.sqrt(positions[node].x*positions[node].x + positions[node].y*positions[node].y);
                        if (dist > maxDist) {
                            positions[node].x = positions[node].x / dist * maxDist;
                            positions[node].y = positions[node].y / dist * maxDist;
                        }
                    });
                }
                
                return positions;
            }
            
            onNodeClick(node) {
                console.log('节点点击:', node, '战役模式:', this.campaignMode, '战斗中:', this.battleInProgress);
                
                if (this.battleInProgress) {
                    console.log('战斗进行中，忽略节点点击');
                    return;
                }
                
                if (this.campaignMode) {
                    console.log('处理战役模式节点点击');
                    this.handleCampaignNodeClick(node);
                } else if (this.canReach(node)) {
                    console.log('显示行动选择模态框');
                    this.showActionModal(node);
                } else {
                    console.log('节点不可达:', node);
                }
            }
            
            handleCampaignNodeClick(node) {
                console.log('战役模式: 点击节点', node);
                console.log('当前战役目标:', this.campaignTargets);
                console.log('当前位置:', this.currentPos);
                
                const selectableNodes = this.getCampaignSelectableNodes();
                if (!selectableNodes.includes(node)) {
                    console.log('节点', node, '在战役模式下不可选择');
                    this.showMessage('该节点不能作为战役目标！');
                    return;
                }
                
                this.campaignTargets.push(node);
                console.log('添加战役目标:', node, '总目标数:', this.campaignTargets.length);
                
                if (this.campaignTargets.length >= this.maxCampaignLength) {
                    console.log('战役达到最大长度');
                }
                
                this.renderCampaignMode();
            }
            
            showMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(0,0,0,0.9);
                    color: #e2a855;
                    padding: 20px;
                    border-radius: 10px;
                    border: 2px solid #e2a855;
                    z-index: 5000;
                    font-weight: bold;
                    text-align: center;
                    animation: fadeInOut 2s ease;
                `;
                messageDiv.textContent = message;
                
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(messageDiv);
                setTimeout(() => {
                    messageDiv.remove();
                    style.remove();
                }, 2000);
            }
            
            startCampaignMode() {
                console.log('开始战役模式');
                this.campaignMode = true;
                this.campaignTargets = [];
                this.renderCampaignMode();
            }
            
            exitCampaignMode() {
                console.log('退出战役模式');
                this.campaignMode = false;
                this.campaignTargets = [];
                
                const infoDiv = document.getElementById('campaignInfo');
                if (infoDiv) {
                    infoDiv.remove();
                }
                
                const indicator = document.getElementById('campaignModeIndicator');
                if (indicator) {
                    indicator.remove();
                }
                
                this.renderMap();
            }
            
            renderCampaignMode() {
                console.log('渲染战役模式，目标:', this.campaignTargets);
                this.renderMap();
                this.showCampaignInfo();
            }
            
            highlightCampaignPath() {
                this.campaignTargets.forEach(target => {
                    const nodes = document.querySelectorAll('.node');
                    nodes.forEach(nodeGroup => {
                        const text = nodeGroup.querySelector('text');
                        if (text && parseInt(text.textContent) === target) {
                            const circle = nodeGroup.querySelector('circle');
                            if (circle) {
                                circle.classList.add('campaign-selected');
                            }
                        }
                    });
                });
                
                for (let i = 0; i < this.campaignTargets.length - 1; i++) {
                    const from = this.campaignTargets[i];
                    const to = this.campaignTargets[i + 1];
                    
                    if (this.nodePositions[from] && this.nodePositions[to]) {
                        const lines = document.querySelectorAll('line');
                        lines.forEach(line => {
                            const x1 = parseFloat(line.getAttribute('x1'));
                            const y1 = parseFloat(line.getAttribute('y1'));
                            const x2 = parseFloat(line.getAttribute('x2'));
                            const y2 = parseFloat(line.getAttribute('y2'));
                            
                            const pos1 = this.nodePositions[from];
                            const pos2 = this.nodePositions[to];
                            
                            const tolerance = 2;
                            if (((Math.abs(x1 - pos1.x) < tolerance && Math.abs(y1 - pos1.y) < tolerance && 
                                  Math.abs(x2 - pos2.x) < tolerance && Math.abs(y2 - pos2.y) < tolerance) ||
                                 (Math.abs(x1 - pos2.x) < tolerance && Math.abs(y1 - pos2.y) < tolerance && 
                                  Math.abs(x2 - pos1.x) < tolerance && Math.abs(y2 - pos1.y) < tolerance))) {
                                line.classList.add('campaign-path');
                            }
                        });
                    }
                }
            }
            
            showCampaignInfo() {
                let infoDiv = document.getElementById('campaignInfo');
                if (!infoDiv) {
                    infoDiv = document.createElement('div');
                    infoDiv.id = 'campaignInfo';
                    infoDiv.className = 'campaign-info';
                    document.getElementById('mapContainer').appendChild(infoDiv);
                }
                
                const totalEnemies = this.calculateCampaignEnemies();
                const targetsText = this.campaignTargets.length > 0 ? this.campaignTargets.join(' → ') : '无';
                
                infoDiv.innerHTML = `
                    <div class="campaign-counter">战役路径: ${this.campaignTargets.length}/${this.maxCampaignLength}</div>
                    <div class="campaign-list">
                        目标: ${targetsText}<br>
                        预计敌军: ${totalEnemies} 个单位
                    </div>
                    <div class="campaign-controls">
                        ${this.campaignTargets.length > 0 ? 
                            '<button class="campaign-btn confirm" id="confirmCampaignBtn">发起战役</button>' : 
                            '<button class="campaign-btn confirm" disabled>选择目标</button>'
                        }
                        <button class="campaign-btn cancel" id="cancelCampaignBtn">取消</button>
                    </div>
                `;
                
                const confirmBtn = document.getElementById('confirmCampaignBtn');
                const cancelBtn = document.getElementById('cancelCampaignBtn');
                
                if (confirmBtn) {
                    confirmBtn.onclick = () => this.confirmCampaign();
                }
                if (cancelBtn) {
                    cancelBtn.onclick = () => this.exitCampaignMode();
                }
            }
            
            calculateCampaignEnemies() {
                let total = 0;
                const usedEnemies = new Set();
                
                this.campaignTargets.forEach(target => {
                    if (!usedEnemies.has(target) && !this.friendlyNodes.has(target)) {
                        total++;
                        usedEnemies.add(target);
                    }
                    
                    const additionalCount = this.getAdditionalEnemyCount(target);
                    let availableNeighbors = this.adjacencyList[target].filter(n => 
                        n !== this.currentPos && 
                        !this.friendlyNodes.has(n) && 
                        !usedEnemies.has(n) &&
                        !this.campaignTargets.includes(n)
                    );
                    
                    if (availableNeighbors.length < additionalCount) {
                        const distance2Neighbors = new Set();
                        availableNeighbors.forEach(neighbor => {
                            this.adjacencyList[neighbor].forEach(n => {
                                if (n !== target && 
                                    n !== this.currentPos && 
                                    !this.friendlyNodes.has(n) && 
                                    !usedEnemies.has(n) &&
                                    !this.campaignTargets.includes(n)) {
                                    distance2Neighbors.add(n);
                                }
                            });
                        });
                        availableNeighbors = [...availableNeighbors, ...Array.from(distance2Neighbors)];
                    }
                    
                    const actualAdditional = Math.min(additionalCount, availableNeighbors.length);
                    for (let i = 0; i < actualAdditional; i++) {
                        if (availableNeighbors[i] && !usedEnemies.has(availableNeighbors[i])) {
                            total++;
                            usedEnemies.add(availableNeighbors[i]);
                        }
                    }
                });
                
                return total;
            }
            
            async confirmCampaign() {
                if (this.campaignTargets.length === 0) {
                    console.log('没有选择战役目标');
                    this.showMessage('请先选择战役目标！');
                    return;
                }
                
                console.log('确认战役，目标:', this.campaignTargets);
                
                // 保存战役目标，因为exitCampaignMode()会清空它们
                const campaignTargetsCopy = [...this.campaignTargets];
                
                // 清理战役界面
                this.exitCampaignMode();
                
                // 恢复战役目标并启动战役战斗
                this.campaignTargets = campaignTargetsCopy;
                await this.startCampaignBattle();
            }
            
            async startCampaignBattle() {
                console.log('开始战役战斗...');
                this.saveBeforeBattleState();
                this.battleInProgress = true;
                
                const playerUnits = [this.heroUnit];
                const releasedSoulIndices = [];
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'release') {
                        playerUnits.push(soul);
                        releasedSoulIndices.push(index);
                    }
                });
                
                const enemyNodes = this.getCampaignEnemies();
                console.log('战役战斗 - 我方单位:', playerUnits);
                console.log('战役战斗 - 敌方单位:', enemyNodes);
                
                if (enemyNodes.length === 0) {
                    console.error('战役战斗中没有找到敌方单位！');
                    this.showMessage('战役中没有敌人！这可能是一个bug。');
                    this.battleInProgress = false;
                    return;
                }
                
                await this.showBattleModal(playerUnits, enemyNodes);
                
                const result = await this.numbercraftBattle(playerUnits, enemyNodes);
                
                if (result.winner === 'X') {
                    this.onCampaignWin(releasedSoulIndices);
                } else {
                    this.onBattleLose();
                }
                
                this.battleInProgress = false;
            }
            
            getCampaignEnemies() {
                console.log('获取战役敌人，目标:', this.campaignTargets);
                const enemies = [];
                const usedEnemies = new Set();
                
                this.campaignTargets.forEach(target => {
                    console.log('处理目标:', target);
                    
                    if (!usedEnemies.has(target) && !this.friendlyNodes.has(target)) {
                        enemies.push(target);
                        usedEnemies.add(target);
                        console.log('添加目标作为敌人:', target);
                    }
                    
                    const additionalCount = this.getAdditionalEnemyCount(target);
                    console.log('目标', target, '需要额外敌人:', additionalCount);
                    
                    let availableNeighbors = this.adjacencyList[target].filter(n => 
                        n !== this.currentPos && 
                        !this.friendlyNodes.has(n) && 
                        !usedEnemies.has(n) &&
                        !this.campaignTargets.includes(n)
                    );
                    
                    console.log('目标', target, '的可用邻居:', availableNeighbors);
                    
                    if (availableNeighbors.length < additionalCount) {
                        const distance2Neighbors = new Set();
                        availableNeighbors.forEach(neighbor => {
                            this.adjacencyList[neighbor].forEach(n => {
                                if (n !== target && 
                                    n !== this.currentPos && 
                                    !this.friendlyNodes.has(n) && 
                                    !usedEnemies.has(n) &&
                                    !this.campaignTargets.includes(n)) {
                                    distance2Neighbors.add(n);
                                }
                            });
                        });
                        availableNeighbors = [...availableNeighbors, ...Array.from(distance2Neighbors)];
                        console.log('扩展可用邻居:', availableNeighbors);
                    }
                    
                    for (let i = 0; i < additionalCount && availableNeighbors.length > 0; i++) {
                        const randomIndex = Math.floor(Math.random() * availableNeighbors.length);
                        const enemy = availableNeighbors.splice(randomIndex, 1)[0];
                        if (!usedEnemies.has(enemy)) {
                            enemies.push(enemy);
                            usedEnemies.add(enemy);
                            console.log('添加额外敌人:', enemy);
                        }
                    }
                });
                
                console.log('最终战役敌人:', enemies);
                return enemies;
            }
            
            onCampaignWin(releasedSoulIndices) {
                console.log('战役胜利！目标:', this.campaignTargets);
                this.battleCount++;
                
                if (this.battleCount % 10 === 0 && this.stealthCount < 3) {
                    this.stealthCount++;
                }
                
                releasedSoulIndices.sort((a, b) => b - a).forEach(index => {
                    this.souls.splice(index, 1);
                    this.soulModes.splice(index, 1);
                    this.soulBuffTurns.splice(index, 1);
                });
                
                const campaignTargetsCopy = [...this.campaignTargets];
                campaignTargetsCopy.forEach(target => {
                    this.conqueredNodes.add(target);
                    this.collectSoul(target);
                    console.log('征服并收集了魂:', target);
                });
                
                this.currentPos = campaignTargetsCopy[campaignTargetsCopy.length - 1];
                console.log('移动到战役终点位置:', this.currentPos);
                
                this.campaignTargets = [];
                
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
                this.updateUI();
                this.renderMap();
                
                if (this.conqueredNodes.has(this.bossNode)) {
                    this.onGameWin();
                }
            }
            
            canReach(node) {
                if (this.currentPos === null) return false;
                if (node === this.currentPos) return false;
                return this.adjacencyList[this.currentPos].includes(node);
            }
            
            highlightReachableNodes() {
                document.querySelectorAll('.reachable-node').forEach(el => {
                    el.classList.remove('reachable-node');
                });
                
                if (!this.currentPos) return;
                
                const reachableNodes = new Set();
                this.adjacencyList[this.currentPos].forEach(node => {
                    reachableNodes.add(node);
                });
                
                document.querySelectorAll('.node').forEach(g => {
                    const circle = g.querySelector('circle');
                    const text = g.querySelector('text');
                    const nodeNum = parseInt(text.textContent);
                    if (reachableNodes.has(nodeNum)) {
                        circle.classList.add('reachable-node');
                    }
                });
            }
            
            showActionModal(node) {
                this.selectedTarget = node;
                document.getElementById('actionTarget').textContent = node;
                
                const battleBtn = document.getElementById('battleActionBtn');
                const moveBtn = document.getElementById('moveActionBtn');
                const stealthBtn = document.getElementById('stealthActionBtn');
                const campaignBtn = document.getElementById('campaignActionBtn');
                
                // 重置所有按钮显示
                battleBtn.style.display = 'block';
                moveBtn.style.display = 'block';
                stealthBtn.style.display = 'block';
                campaignBtn.style.display = 'block';
                
                if (this.friendlyNodes.has(node)) {
                    // 友方节点只能移动，隐藏其他操作
                    battleBtn.style.display = 'none';
                    stealthBtn.style.display = 'none';
                    campaignBtn.style.display = 'none';
                    moveBtn.textContent = '🚶 移动到友方节点';
                } else {
                    // 敌方节点不能普通移动，隐藏普通移动按钮
                    moveBtn.style.display = 'none';
                    
                    // 检查潜行次数
                    if (this.stealthCount <= 0) {
                        stealthBtn.disabled = true;
                        stealthBtn.textContent = `🥷 潜行移动 (${this.stealthCount})`;
                    } else {
                        stealthBtn.disabled = false;
                        stealthBtn.textContent = `🥷 潜行移动 (${this.stealthCount})`;
                    }
                }
                
                document.getElementById('actionModal').style.display = 'flex';
            }
            
            closeActionModal() {
                document.getElementById('actionModal').style.display = 'none';
                this.selectedTarget = null;
            }
            
            stealthMove(targetNode) {
                if (this.stealthCount <= 0 || !this.canReach(targetNode)) {
                    return false;
                }
                
                this.stealthCount--;
                this.currentPos = targetNode;
                this.conqueredNodes.add(targetNode);
                
                this.updateUI();
                this.renderMap();
                
                return true;
            }
            
            moveToNode(targetNode) {
                if (this.friendlyNodes.has(targetNode)) {
                    this.currentPos = targetNode;
                } else {
                    this.currentPos = targetNode;
                    this.conqueredNodes.add(targetNode);
                }
                
                this.updateUI();
                this.renderMap();
                return true;
            }
            
            saveBeforeBattleState() {
                this.beforeBattleState = {
                    currentPos: this.currentPos,
                    souls: [...this.souls],
                    conqueredNodes: new Set(this.conqueredNodes),
                    friendlyNodes: new Set(this.friendlyNodes),
                    soulModes: [...this.soulModes],
                    soulBuffTurns: [...this.soulBuffTurns]
                };
            }
            
            restoreBeforeBattleState() {
                if (this.beforeBattleState) {
                    this.currentPos = this.beforeBattleState.currentPos;
                    this.souls = [...this.beforeBattleState.souls];
                    this.conqueredNodes = new Set(this.beforeBattleState.conqueredNodes);
                    this.friendlyNodes = new Set(this.beforeBattleState.friendlyNodes);
                    this.soulModes = [...this.beforeBattleState.soulModes];
                    this.soulBuffTurns = [...this.beforeBattleState.soulBuffTurns];
                    
                    this.updateSoulDisplay();
                    this.updateSoulCount();
                    this.updateUI();
                    this.renderMap();
                }
            }
            
            async startBattle() {
                if (!this.selectedTarget) {
                    console.error('没有选择的战斗目标');
                    return;
                }
                
                console.log('开始与目标的战斗:', this.selectedTarget);
                
                this.saveBeforeBattleState();
                this.battleInProgress = true;
                
                const playerUnits = [this.heroUnit];
                const releasedSoulIndices = [];
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'release') {
                        playerUnits.push(soul);
                        releasedSoulIndices.push(index);
                    }
                });
                
                const enemyNodes = this.getBattleEnemies(this.selectedTarget);
                
                console.log('我方单位:', playerUnits);
                console.log('敌方单位:', enemyNodes);
                
                await this.showBattleModal(playerUnits, enemyNodes);
                
                const result = await this.numbercraftBattle(playerUnits, enemyNodes);
                
                if (result.winner === 'X') {
                    this.onBattleWin(this.selectedTarget, enemyNodes, releasedSoulIndices);
                } else {
                    this.onBattleLose();
                }
                
                this.selectedTarget = null;
                this.battleInProgress = false;
            }
            
            getBattleEnemies(targetNode) {
                const enemies = [targetNode];
                const additionalCount = this.getAdditionalEnemyCount(targetNode);
                
                let availableNeighbors = this.adjacencyList[targetNode].filter(n => 
                    n !== this.currentPos && !this.friendlyNodes.has(n)
                );
                
                if (availableNeighbors.length < additionalCount) {
                    const distance2Neighbors = new Set();
                    availableNeighbors.forEach(neighbor => {
                        this.adjacencyList[neighbor].forEach(n => {
                            if (n !== targetNode && n !== this.currentPos && !this.friendlyNodes.has(n)) {
                                distance2Neighbors.add(n);
                            }
                        });
                    });
                    availableNeighbors = [...availableNeighbors, ...distance2Neighbors];
                }
                
                for (let i = 0; i < additionalCount && i < availableNeighbors.length; i++) {
                    const randomIndex = Math.floor(Math.random() * availableNeighbors.length);
                    const enemy = availableNeighbors.splice(randomIndex, 1)[0];
                    enemies.push(enemy);
                }
                
                return enemies;
            }
            
            getAdditionalEnemyCount(node) {
                if (node < 50) return 0;
                if (node < 100) return 1;
                if (node < 200) return 2;
                return 3;
            }
            
            async showBattleModal(playerUnits, enemyUnits) {
                console.log('显示战斗模态框');
                const modal = document.getElementById('battleModal');
                
                const speedTexts = {0.5: '慢速', 1: '正常', 1.5: '快速', 2: '极快'};
                document.getElementById('battleSpeedDisplay').textContent = speedTexts[this.battleSpeed];
                
                const playerDiv = document.getElementById('playerBattleUnits');
                const enemyDiv = document.getElementById('enemyBattleUnits');
                
                playerDiv.innerHTML = '';
                enemyDiv.innerHTML = '';
                
                playerUnits.forEach((unit, index) => {
                    const div = document.createElement('div');
                    div.className = 'battle-unit player';
                    div.textContent = unit;
                    div.id = `battle-player-${unit}-${index}`;
                    playerDiv.appendChild(div);
                });
                
                enemyUnits.forEach((unit, index) => {
                    const div = document.createElement('div');
                    div.className = 'battle-unit enemy';
                    div.textContent = unit;
                    div.id = `battle-enemy-${unit}-${index}`;
                    enemyDiv.appendChild(div);
                });
                
                modal.style.display = 'flex';
                console.log('战斗模态框现在应该可见');
                
                await this.delay(300 / this.battleSpeed);
            }
            
            async numbercraftBattle(groupX, groupY) {
                let aliveX = [...groupX];
                let aliveY = [...groupY];
                let consecutiveWinsX = 0;
                let consecutiveWinsY = 0;
                let turn = 2;
                
                while (aliveX.length > 0 && aliveY.length > 0) {
                    document.getElementById('turnDisplay').textContent = `回合 ${turn}`;
                    
                    let maxX = Math.max(...aliveX.map(x => x % turn));
                    let maxXUnit = aliveX.find(x => x % turn === maxX);
                    
                    let soulBonus = 0;
                    let bonusSoul = null;
                    this.souls.forEach((soul, index) => {
                        if (this.soulModes[index] === 'buff' && this.soulBuffTurns[index] === turn) {
                            const soulValue = soul % turn;
                            if (soulValue > maxX) {
                                maxX = soulValue;
                                maxXUnit = this.heroUnit;
                                soulBonus = soulValue;
                                bonusSoul = soul;
                            }
                        }
                    });
                    
                    const maxY = Math.max(...aliveY.map(y => y % turn));
                    const maxYUnit = aliveY.find(y => y % turn === maxY);
                    
                    await this.showTurnEffects(maxXUnit, maxYUnit, maxX, maxY, bonusSoul, turn);
                    
                    if (maxX > maxY) {
                        consecutiveWinsX++;
                        consecutiveWinsY = 0;
                    } else if (maxY > maxX) {
                        consecutiveWinsY++;
                        consecutiveWinsX = 0;
                    } else {
                        consecutiveWinsX = 0;
                        consecutiveWinsY = 0;
                    }
                    
                    if (consecutiveWinsX === 3) {
                        const randomIndex = Math.floor(Math.random() * aliveY.length);
                        const eliminated = aliveY[randomIndex];
                        aliveY.splice(randomIndex, 1);
                        await this.eliminateUnit('enemy', eliminated, randomIndex);
                        consecutiveWinsX = 0;
                    } else if (consecutiveWinsY === 3) {
                        // 玩家阵亡顺序：魂释放顺序，主角最后
                        let eliminatedIndex = -1;
                        let eliminated = null;
                        
                        // 优先消灭释放的魂（按释放顺序）
                        for (let i = 0; i < aliveX.length; i++) {
                            if (aliveX[i] !== this.heroUnit) {
                                eliminatedIndex = i;
                                eliminated = aliveX[i];
                                break;
                            }
                        }
                        
                        // 如果没有魂，则消灭主角
                        if (eliminatedIndex === -1) {
                            eliminatedIndex = aliveX.indexOf(this.heroUnit);
                            eliminated = this.heroUnit;
                        }
                        
                        if (eliminatedIndex !== -1) {
                            aliveX.splice(eliminatedIndex, 1);
                            await this.eliminateUnit('player', eliminated, eliminatedIndex);
                        }
                        consecutiveWinsY = 0;
                    }
                    
                    turn++;
                    await this.delay(800 / this.battleSpeed); // 调快战斗速度
                }
                
                const result = aliveX.length > 0 ? 'X' : 'Y';
                await this.showBattleResult(result);
                
                return {winner: result, finalTurn: turn};
            }
            
            async showTurnEffects(playerUnit, enemyUnit, playerValue, enemyValue, bonusSoul, turn) {
                const playerUnitEl = document.querySelector(`#battle-player-${playerUnit}-0`) || 
                                   document.querySelector(`[id^="battle-player-${playerUnit}-"]`);
                const enemyUnitEl = document.querySelector(`#battle-enemy-${enemyUnit}-0`) || 
                                  document.querySelector(`[id^="battle-enemy-${enemyUnit}-"]`);
                
                if (playerValue > enemyValue && playerUnitEl) {
                    playerUnitEl.classList.add('winner');
                } else if (enemyValue > playerValue && enemyUnitEl) {
                    enemyUnitEl.classList.add('winner');
                }
                
                if (playerUnitEl) {
                    this.showFloatingNumber(playerUnitEl, playerValue);
                }
                if (enemyUnitEl) {
                    this.showFloatingNumber(enemyUnitEl, enemyValue);
                }
                
                // 增强魂增益特效 - 显示在战斗场景中，而不是数字内部
                if (bonusSoul && playerUnitEl) {
                    // 获取战斗场景容器
                    const battleField = document.querySelector('.battle-field');
                    const unitRect = playerUnitEl.getBoundingClientRect();
                    const fieldRect = battleField.getBoundingClientRect();
                    
                    // 在数字单位上方显示魂增益光环
                    const soulAura = document.createElement('div');
                    soulAura.style.cssText = `
                        position: absolute;
                        left: ${unitRect.left - fieldRect.left - 10}px;
                        top: ${unitRect.top - fieldRect.top - 10}px;
                        width: ${unitRect.width + 20}px;
                        height: ${unitRect.height + 20}px;
                        border: 3px solid #55e285;
                        border-radius: 15px;
                        background: radial-gradient(circle, rgba(85, 226, 133, 0.3) 0%, transparent 70%);
                        z-index: 100;
                        pointer-events: none;
                        animation: soulAura 1.5s ease;
                    `;
                    
                    // 显示魂数字标识 - 浮在数字上方
                    const soulIndicator = document.createElement('div');
                    soulIndicator.style.cssText = `
                        position: absolute;
                        left: ${unitRect.left - fieldRect.left + unitRect.width/2 - 40}px;
                        top: ${unitRect.top - fieldRect.top - 50}px;
                        width: 80px;
                        background: linear-gradient(135deg, #55e285 0%, #45c275 100%);
                        color: white;
                        padding: 8px 12px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: bold;
                        z-index: 200;
                        box-shadow: 0 4px 15px rgba(85, 226, 133, 0.6);
                        animation: soulBonus 1.5s ease;
                        pointer-events: none;
                        text-align: center;
                    `;
                    soulIndicator.textContent = `魂 ${bonusSoul}`;
                    
                    // 添加动画样式（如果还没有）
                    if (!document.getElementById('soulEffectStyles')) {
                        const style = document.createElement('style');
                        style.id = 'soulEffectStyles';
                        style.textContent = `
                            @keyframes soulAura {
                                0% { 
                                    opacity: 0; 
                                    transform: scale(0.5); 
                                    border-color: #55e285;
                                }
                                30% { 
                                    opacity: 1; 
                                    transform: scale(1.1); 
                                    border-color: #7af2a5;
                                }
                                70% { 
                                    opacity: 0.8; 
                                    transform: scale(1); 
                                    border-color: #55e285;
                                }
                                100% { 
                                    opacity: 0; 
                                    transform: scale(1.2); 
                                    border-color: #3ad975;
                                }
                            }
                            @keyframes soulBonus {
                                0% { 
                                    opacity: 0; 
                                    transform: translateY(20px) scale(0.5); 
                                }
                                30% { 
                                    opacity: 1; 
                                    transform: translateY(-5px) scale(1.2); 
                                }
                                70% { 
                                    opacity: 1; 
                                    transform: translateY(0) scale(1); 
                                }
                                100% { 
                                    opacity: 0; 
                                    transform: translateY(-15px) scale(0.8); 
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // 添加到战斗场景中
                    battleField.appendChild(soulAura);
                    battleField.appendChild(soulIndicator);
                    
                    // 清理特效
                    setTimeout(() => {
                        if (soulAura.parentNode) {
                            soulAura.parentNode.removeChild(soulAura);
                        }
                        if (soulIndicator.parentNode) {
                            soulIndicator.parentNode.removeChild(soulIndicator);
                        }
                    }, 1500 / this.battleSpeed);
                }
                
                await this.delay(600 / this.battleSpeed);
                
                document.querySelectorAll('.winner').forEach(el => {
                    el.classList.remove('winner');
                });
            }
            
            showFloatingNumber(element, value) {
                const number = document.createElement('div');
                number.className = 'damage-number';
                number.textContent = value;
                
                const rect = element.getBoundingClientRect();
                number.style.left = rect.left + rect.width/2 - 10 + 'px';
                number.style.top = rect.top - 10 + 'px';
                number.style.position = 'fixed';
                number.style.zIndex = '3000';
                number.style.animationDuration = (1 / this.battleSpeed) + 's';
                
                document.body.appendChild(number);
                
                setTimeout(() => {
                    if (number.parentNode) {
                        number.parentNode.removeChild(number);
                    }
                }, 1000 / this.battleSpeed);
            }
            
            async eliminateUnit(team, unit, index) {
                const unitEl = document.querySelector(`#battle-${team}-${unit}-${index}`) ||
                             document.querySelector(`[id^="battle-${team}-${unit}-"]`);
                if (unitEl) {
                    unitEl.classList.add('eliminated');
                }
                await this.delay(400 / this.battleSpeed);
            }
            
            async showBattleResult(winner) {
                const display = document.getElementById('turnDisplay');
                if (winner === 'X') {
                    display.textContent = '🎉 胜利！';
                    display.style.borderColor = '#4a90e2';
                } else {
                    display.textContent = '💀 失败...';
                    display.style.borderColor = '#e24a4a';
                }
                
                const closeBtn = document.getElementById('closeBattleBtn');
                closeBtn.style.display = 'block';
                
                await new Promise(resolve => {
                    closeBtn.onclick = () => {
                        document.getElementById('battleModal').style.display = 'none';
                        closeBtn.style.display = 'none';
                        resolve();
                    };
                });
            }
            
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            onBattleWin(targetNode, enemies, releasedSoulIndices) {
                this.battleCount++;
                
                if (this.battleCount % 10 === 0 && this.stealthCount < 3) {
                    this.stealthCount++;
                }
                
                releasedSoulIndices.sort((a, b) => b - a).forEach(index => {
                    const soul = this.souls[index];
                    this.souls.splice(index, 1);
                    this.soulModes.splice(index, 1);
                    this.soulBuffTurns.splice(index, 1);
                });
                
                this.conqueredNodes.add(targetNode);
                this.currentPos = targetNode;
                this.collectSoul(targetNode);
                
                this.updateSoulDisplay();
                this.updateSoulCount();
                this.updateFriendlyNodes();
                this.updateUI();
                this.renderMap();
                
                if (targetNode === this.bossNode) {
                    this.onGameWin();
                }
            }
            
            onBattleLose() {
                setTimeout(() => {
                    this.restoreBeforeBattleState();
                }, 800 / this.battleSpeed);
            }
            
            collectSoul(node) {
                if (this.souls.length < this.maxSouls) {
                    this.souls.push(node);
                    this.soulModes.push('none');
                    this.soulBuffTurns.push(3);
                    this.updateSoulDisplay();
                    this.updateSoulCount();
                    this.updateFriendlyNodes();
                }
            }
            
            updateSoulDisplay() {
                const container = document.getElementById('soulSimpleList');
                container.innerHTML = '';
                
                for (let i = 0; i < this.maxSouls; i++) {
                    const item = document.createElement('div');
                    item.className = 'soul-simple-item';
                    
                    if (i < this.souls.length) {
                        const soul = this.souls[i];
                        const mode = this.soulModes[i];
                        
                        item.classList.add(mode);
                        item.textContent = soul;
                    } else {
                        item.classList.add('empty');
                        item.textContent = '-';
                    }
                    
                    container.appendChild(item);
                }
            }
            
            updateSoulCount() {
                document.getElementById('soulCount').textContent = `${this.souls.length}/${this.maxSouls}`;
            }
            
showSoulConfig() {
    document.getElementById('heroTimeline').textContent = this.heroUnit;
    this.renderSoulCards();
    this.renderTimeline();
    
    // 只在第一次打开时添加区域监听器
    if (!this.zoneListenersAdded) {
        this.addZoneDropListeners();
        this.zoneListenersAdded = true;
    }
    
    document.getElementById('soulConfigModal').style.display = 'flex';
}
            
            renderSoulCards() {
                const waitingZone = document.getElementById('waitingSouls');
                const releaseZone = document.getElementById('releaseSouls');
                
                waitingZone.innerHTML = '';
                releaseZone.innerHTML = '';
                
                this.souls.forEach((soul, index) => {
                    const card = this.createSoulCard(soul, index);
                    
                    if (this.soulModes[index] === 'release') {
                        releaseZone.appendChild(card);
                    } else if (this.soulModes[index] === 'none') {
                        waitingZone.appendChild(card);
                    }
                });
            }
            
            createSoulCard(soul, index) {
                const card = document.createElement('div');
                card.className = 'soul-card';
                card.draggable = true;
                card.dataset.soulIndex = index;
                card.dataset.soulValue = soul;
                
                const mode = this.soulModes[index];
                if (mode === 'release') {
                    card.classList.add('in-release');
                } else if (mode === 'buff') {
                    card.classList.add('in-timeline');
                }
                
                card.innerHTML = `
                    <div class="soul-number">${soul}</div>
                    <div class="soul-mode-indicator">${this.getModeText(mode)}</div>
                `;
                
                this.addDragListeners(card);
                return card;
            }
            
            getModeText(mode) {
                switch(mode) {
                    case 'release': return '释放';
                    case 'buff': return '增益';
                    default: return '等待';
                }
            }
            
            renderTimeline() {
                const turnsContainer = document.getElementById('timelineTurns');
                turnsContainer.innerHTML = '';
                
                for (let turn = 2; turn <= 100; turn++) {
                    const turnDiv = document.createElement('div');
                    turnDiv.className = 'timeline-turn';
                    turnDiv.dataset.turn = turn;
                    
                    const heroValue = this.heroUnit % turn;
                    
                    turnDiv.innerHTML = `
                        <div class="timeline-turn-number">T${turn}</div>
                        <div class="timeline-hero-value">${heroValue}</div>
                        <div class="timeline-soul-slot" data-turn="${turn}"></div>
                    `;
                    
                    turnsContainer.appendChild(turnDiv);
                    this.addTimelineDropListeners(turnDiv);
                }
                
                this.souls.forEach((soul, index) => {
                    if (this.soulModes[index] === 'buff') {
                        this.placeSoulOnTimeline(soul, index, this.soulBuffTurns[index]);
                    }
                });
            }
            
            addTimelineDropListeners(element) {
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'move';
                    element.classList.add('drop-zone');
                });
                
                element.addEventListener('dragleave', () => {
                    element.classList.remove('drop-zone');
                });
                
                element.addEventListener('drop', (e) => {
                    e.preventDefault();
                    element.classList.remove('drop-zone');
                    
                    const soulIndex = parseInt(e.dataTransfer.getData('text/plain'));
                    const turn = parseInt(element.dataset.turn);
                    
                    if (turn && !isNaN(soulIndex)) {
                        this.setSoulMode(soulIndex, 'buff');
                        this.setSoulBuffTurn(soulIndex, turn);
                        this.refreshSoulConfig();
                    }
                });
            }
            
            addZoneDropListeners() {
                const zones = document.querySelectorAll('.soul-cards');
                zones.forEach(zone => {
                    zone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        zone.parentElement.style.borderColor = '#4a90e2';
                    });
                    
                    zone.addEventListener('dragleave', () => {
                        zone.parentElement.style.borderColor = '';
                    });
                    
                    zone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        zone.parentElement.style.borderColor = '';
                        
                        const soulIndex = parseInt(e.dataTransfer.getData('text/plain'));
                        const isReleaseZone = zone.id === 'releaseSouls';
                        
                        if (!isNaN(soulIndex)) {
                            if (isReleaseZone) {
                                this.setSoulMode(soulIndex, 'release');
                            } else {
                                this.setSoulMode(soulIndex, 'none');
                            }
                            this.refreshSoulConfig();
                        }
                    });
                });
            }
            
            placeSoulOnTimeline(soul, index, turn) {
                const slot = document.querySelector(`[data-turn="${turn}"] .timeline-soul-slot`);
                if (slot && !slot.classList.contains('occupied')) {
                    slot.classList.add('occupied');
                    slot.innerHTML = `
                        <div class="timeline-soul-card" data-soul-index="${index}" title="点击移除">
                            ${soul}
                        </div>
                    `;
                    
                    const soulCard = slot.querySelector('.timeline-soul-card');
                    if (soulCard) {
                        soulCard.addEventListener('click', () => {
                            this.removeSoulFromTimeline(index);
                        });
                    }
                }
            }
            
            addDragListeners(card) {
                card.addEventListener('dragstart', (e) => {
                    card.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', card.dataset.soulIndex);
                    e.dataTransfer.effectAllowed = 'move';
                });
                
                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                });
            }
            
            refreshSoulConfig() {
                this.renderSoulCards();
                this.renderTimeline();
                this.updateSoulDisplay();
            }
            
            removeSoulFromTimeline(index) {
                const existingSoulCard = document.querySelector(`[data-soul-index="${index}"]`);
                if (existingSoulCard) {
                    const slot = existingSoulCard.parentElement;
                    slot.classList.remove('occupied');
                    slot.innerHTML = '';
                }
                
                this.setSoulMode(index, 'none');
                this.refreshSoulConfig();
            }
            
            closeSoulConfig() {
                document.getElementById('soulConfigModal').style.display = 'none';
            }
            
            setSoulMode(index, mode) {
                this.soulModes[index] = mode;
                if (mode === 'buff' && !this.soulBuffTurns[index]) {
                    this.soulBuffTurns[index] = 3;
                }
                this.updateSoulDisplay();
            }
            
            setSoulBuffTurn(index, turn) {
                this.soulBuffTurns[index] = parseInt(turn);
            }
            
            removeSoulBuff(index) {
                this.soulModes[index] = 'none';
                this.refreshSoulConfig();
            }
            
            showSettings() {
                document.getElementById('settingsModal').style.display = 'flex';
            }
            
            closeSettings() {
                document.getElementById('settingsModal').style.display = 'none';
            }
            
            showHelp() {
                document.getElementById('helpModal').style.display = 'flex';
            }
            
            closeHelp() {
                document.getElementById('helpModal').style.display = 'none';
            }
            
            updateUI() {
                document.getElementById('currentPos').textContent = this.currentPos;
                document.getElementById('battleCount').textContent = this.battleCount;
                document.getElementById('stealthCount').textContent = this.stealthCount;
            }
            
            onGameWin() {
                setTimeout(() => {
                    alert('🎉 恭喜！你击败了BOSS，成为了真正的Soul Mage！\n\n传奇将永远流传！');
                    location.reload();
                }, 2000);
            }
            
            setupEventListeners() {
                document.querySelectorAll('.scenario-option:not(.custom-scenario)').forEach(option => {
                    option.addEventListener('click', (e) => {
                        const hero = parseInt(e.currentTarget.dataset.hero);
                        const boss = parseInt(e.currentTarget.dataset.boss);
                        this.startGame(hero, boss);
                    });
                });
                
                document.getElementById('startCustomBtn').addEventListener('click', () => {
                    const hero = parseInt(document.getElementById('customHero').value);
                    const boss = parseInt(document.getElementById('customBoss').value);
                    if (hero && boss && hero !== boss) {
                        this.startGame(hero, boss);
                    }
                });
                
                document.getElementById('configureSoulsBtn').addEventListener('click', () => {
                    this.showSoulConfig();
                });
                
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.showSettings();
                });
                
                document.getElementById('campaignModeBtn').addEventListener('click', () => {
                    this.startCampaignMode();
                });
                
                document.getElementById('closeSoulConfigBtn').addEventListener('click', () => {
                    this.closeSoulConfig();
                });
                
                document.getElementById('closeActionModalBtn').addEventListener('click', () => {
                    this.closeActionModal();
                });
                
                document.getElementById('closeSettingsBtn').addEventListener('click', () => {
                    this.closeSettings();
                });
                
                document.getElementById('closeHelpBtn').addEventListener('click', () => {
                    this.closeHelp();
                });
                
                document.getElementById('battleActionBtn').addEventListener('click', () => {
                    const target = this.selectedTarget;
                    this.closeActionModal();
                    if (target) {
                        this.selectedTarget = target;
                        this.startBattle();
                    }
                });
                
                document.getElementById('moveActionBtn').addEventListener('click', () => {
                    const target = this.selectedTarget;
                    this.closeActionModal();
                    if (target) {
                        this.moveToNode(target);
                    }
                });
                
                document.getElementById('stealthActionBtn').addEventListener('click', () => {
                    const target = this.selectedTarget;
                    this.closeActionModal();
                    if (target && this.stealthCount > 0) {
                        this.stealthMove(target);
                    }
                });
                
                document.getElementById('campaignActionBtn').addEventListener('click', () => {
                    this.closeActionModal();
                    this.campaignTargets = [this.selectedTarget];
                    this.startCampaignMode();
                });
                
                document.getElementById('battleSpeedSelect').addEventListener('change', (e) => {
                    this.battleSpeed = parseFloat(e.target.value);
                });
                
                document.getElementById('viewRangeSlider').addEventListener('input', (e) => {
                    this.viewRange = parseInt(e.target.value);
                    document.getElementById('viewRange').textContent = this.viewRange;
                    this.renderMap();
                });
                
                document.getElementById('soundToggle').addEventListener('change', (e) => {
                    this.soundEnabled = e.target.checked;
                });
                
                document.getElementById('debugToggle').addEventListener('change', (e) => {
                    this.debugMode = e.target.checked;
                    this.updateDebugInfo();
                });
                
                document.getElementById('zoomInBtn').addEventListener('click', () => {
                    this.zoom = Math.min(this.zoom * 1.2, 3);
                    this.renderMap();
                });
                
                document.getElementById('zoomOutBtn').addEventListener('click', () => {
                    this.zoom = Math.max(this.zoom / 1.2, 0.5);
                    this.renderMap();
                });
                
                document.getElementById('centerBtn').addEventListener('click', () => {
                    this.panX = 0;
                    this.panY = 0;
                    this.zoom = 1;
                    this.renderMap();
                });
                
                document.getElementById('helpBtn').addEventListener('click', () => {
                    this.showHelp();
                });
            }
            
            startGame(hero, boss) {
                this.heroUnit = hero;
                this.bossNode = boss;
                this.currentPos = hero;
                this.conqueredNodes.add(hero);
                this.updateFriendlyNodes();
                
                document.getElementById('heroUnit').textContent = hero;
                document.getElementById('currentPos').textContent = this.currentPos;
                document.getElementById('bossTarget').textContent = boss;
                document.getElementById('gameOverlay').style.display = 'none';
                
                setTimeout(() => this.renderMap(), 100);
            }
        }
        
        // 全局实例
        let gameInstance;
        
        window.addEventListener('DOMContentLoaded', () => {
            gameInstance = new SoulMageGame();
            window.gameInstance = gameInstance;
        });
    </script>
</body>
</html>
