<!DOCTYPE html>
<html lang="en"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⚔️ Numcraft: Epic Battle Arena</title> <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=MedievalSharp&display=swap');
        
        :root {
            --font-primary: 'Cinzel', serif;
            --font-title: 'MedievalSharp', serif;
            --color-gold: #ffd700;
            --color-gold-dark: #b7791f;
            --color-gold-light: #ffed4e;
            --color-text-light: #f4f1de;
            --color-text-neutral: #e6ccb2;
            --color-bg-dark1: #1a1a2e;
            --color-bg-dark2: #16213e;
            --color-bg-dark3: #0f3460;
            --color-accent-purple: #533483;
            --color-accent-purple-dark: #7209b7;
            --border-epic: #8b4513;
            --player-color: #4299e1;
            --player-color-light: #81e6d9;
            --ai-color: #f56565;
            --ai-color-light: #fed7e2;
            --tie-color: #ed8936;
            --tie-color-light: #feebc8;
            --disabled-bg: #2d3748;
            --disabled-border: #718096;
            --disabled-text: #a0aec0;
            --power-bar-player: #3b82f6; /* Blue for player */
            --power-bar-ai: #ef4444;   /* Red for AI */
            --power-bar-bg: #4b5563; /* Neutral gray */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--font-primary);
            background: 
                radial-gradient(circle at 25% 25%, rgba(138, 43, 226, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(255, 140, 0, 0.05) 0%, transparent 40%),
                linear-gradient(135deg, var(--color-bg-dark1) 0%, var(--color-bg-dark2) 25%, var(--color-bg-dark3) 50%, var(--color-accent-purple) 75%, var(--color-accent-purple-dark) 100%);
            min-height: 100vh;
            color: var(--color-text-light);
            overflow-x: hidden;
            padding-top: 10px; 
        }

        .lang-toggle-container {
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 1000;
        }

        .lang-toggle-btn {
            background-color: var(--color-gold-dark);
            color: var(--color-text-light);
            border: 1px solid var(--color-gold);
            padding: 8px 15px;
            font-family: var(--font-primary);
            font-size: 0.9rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .lang-toggle-btn:hover {
            background-color: var(--color-gold);
            color: var(--color-bg-dark1);
        }
        
        .game-container {
            max-width: 1200px;
            margin: 20px auto 0 auto; 
            padding: 20px;
        }
        
        .game-title {
            text-align: center;
            font-family: var(--font-title);
            font-size: 3.2rem; 
            color: var(--color-gold);
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.5);
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        .game-subtitle {
            text-align: center;
            font-size: 1.1rem; 
            color: var(--color-text-neutral);
            margin-bottom: 25px; 
            font-style: italic;
        }
        
        @keyframes glow {
            from { text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.5); }
            to { text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 30px rgba(255,215,0,0.8), 0 0 40px rgba(255,215,0,0.3); }
        }
        
        .game-phase {
            background: linear-gradient(145deg, rgba(26, 26, 46, 0.92), rgba(22, 33, 62, 0.92));
            border: 3px solid var(--border-epic);
            border-radius: 15px;
            padding: 20px; 
            margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.08);
            backdrop-filter: blur(8px); 
        }
        
        .phase-title {
            font-size: 1.7rem; 
            color: var(--color-gold);
            text-align: center;
            margin-bottom: 18px; 
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }

        /* Collapsible Settings */
        #gameSettings .phase-title {
            cursor: pointer;
            position: relative;
        }
        #gameSettings .phase-title::after {
            content: ' ▼'; /* Down arrow for expandable */
            font-size: 0.8em;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.3s ease;
        }
        #gameSettings.collapsed .phase-title::after {
            transform: translateY(-50%) rotate(-90deg); /* Left arrow for collapsed */
        }
        .settings-content {
            max-height: 500px; /* Or enough to show content */
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding 0.5s ease-in-out;
            opacity: 1;
            padding-top: 10px; /* Add some space when expanded */
        }
        #gameSettings.collapsed .settings-content {
            max-height: 0;
            opacity: 0;
            padding-top: 0;
            margin-bottom: 0; /* Remove margin when collapsed */
        }
        
        #gameSettings input[type="number"] {
            background-color: #2a2a3e; 
            color: var(--color-text-light);
            border: 1px solid var(--border-epic);
            border-radius: 5px;
            padding: 7px; 
            width: 70px; 
            font-family: var(--font-primary);
            font-size: 0.85rem; 
            margin-left: 5px;
        }
        #gameSettings label {
            margin-right: 5px;
            font-size: 0.9rem; 
        }
        #gameSettings .settings-grid > div { /* Target direct children of settings-grid for label+input pairs */
            margin-bottom: 8px; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #gameSettings .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); 
            gap: 8px; 
            /* margin-bottom:12px; Removed, handled by .settings-content padding */
        }

        .number-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 8px; 
            justify-content: center;
            margin-bottom: 18px; 
        }
        
        .number-token {
            background: linear-gradient(145deg, #cd853f, var(--border-epic));
            border: 2px solid var(--color-gold);
            border-radius: 10px; 
            padding: 10px 14px; 
            font-size: 1.1rem; 
            font-weight: bold;
            color: #fff;
            cursor: pointer;
            transition: all 0.25s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            position: relative;
            overflow: hidden;
        }
        
        .number-token::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.08), transparent);
            transition: transform 0.5s; 
            transform: rotate(45deg) translate(-100%, -100%);
        }
        
        .number-token:hover::before {
            transform: rotate(45deg) translate(100%, 100%);
        }
        
        .number-token:hover {
            transform: translateY(-2px) scale(1.03); 
            box-shadow: 0 6px 15px rgba(255,215,0,0.35); 
            border-color: var(--color-gold-light);
        }
        
        .number-token.selected {
            background: linear-gradient(145deg, #4a5568, var(--disabled-bg));
            border-color: var(--disabled-border);
            cursor: not-allowed;
            opacity: 0.65; 
        }
        
        .teams-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px; 
            margin-bottom: 18px; 
        }
        
        .team {
            background: linear-gradient(145deg, rgba(15, 52, 96, 0.85), rgba(83, 52, 131, 0.85));
            border: 2px solid;
            border-radius: 12px; 
            padding: 18px; 
            text-align: center;
            position: relative; 
        }
        
        .team.player {
            border-color: var(--player-color);
            box-shadow: 0 0 18px rgba(66, 153, 225, 0.25); 
        }
        
        .team.ai {
            border-color: var(--ai-color);
            box-shadow: 0 0 18px rgba(245, 101, 101, 0.25); 
        }
        
        .team-name {
            font-size: 1.4rem; 
            font-weight: 600;
            margin-bottom: 12px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
        }
        
        .team.player .team-name { color: var(--player-color-light); }
        .team.ai .team-name { color: var(--ai-color-light); }
        
        .team-numbers {
            display: flex;
            flex-wrap: wrap;
            gap: 7px; 
            justify-content: center;
            min-height: 50px; 
            align-items: center;
        }
        
        .team-number {
            background: linear-gradient(145deg, var(--disabled-bg), #4a5568);
            border: 2px solid #e2e8f0;
            border-radius: 7px; 
            padding: 7px 10px; 
            font-size: 1rem; 
            font-weight: bold;
            color: #f7fafc;
            animation: slideIn 0.4s ease-out; 
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            position: relative; 
        }

        .team-number.active-battle-unit {
            transform: scale(1.25) translateY(-3px);
            box-shadow: 0 0 15px var(--color-gold-light);
            z-index: 10;
        }
        
        .floating-value {
            position: absolute;
            font-size: 1.8em; 
            font-weight: bold;
            font-family: var(--font-title);
            opacity: 0;
            animation: floatUpEffect 1.2s ease-out forwards;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            pointer-events: none; 
            z-index: 20;
        }

        @keyframes floatUpEffect {
            0% { transform: translateY(0) scale(0.5); opacity: 1; }
            60% { transform: translateY(-50px) scale(1.1); opacity: 0.9; }
            100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: scale(0.7) translateY(-8px); } 
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        
        .controls {
            text-align: center;
            margin-bottom: 15px; 
        }
        
        .btn {
            background: linear-gradient(145deg, var(--color-gold), var(--color-gold-dark));
            border: 2px solid var(--color-gold-light);
            border-radius: 8px; 
            padding: 10px 20px; 
            font-size: 1rem; 
            font-weight: 600;
            color: var(--color-bg-dark1);
            cursor: pointer;
            transition: all 0.25s ease;
            font-family: var(--font-primary);
            text-transform: uppercase;
            letter-spacing: 0.8px; 
            margin: 4px 8px; 
        }
        
        .btn:hover {
            background: linear-gradient(145deg, var(--color-gold-light), var(--color-gold));
            transform: translateY(-1px); 
            box-shadow: 0 5px 12px rgba(214, 158, 46, 0.35); 
        }
        
        .btn:disabled {
            background: linear-gradient(145deg, #4a5568, var(--disabled-bg));
            border-color: var(--disabled-border);
            color: var(--disabled-text);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .battle-arena {
            background: linear-gradient(145deg, rgba(26, 26, 46, 0.96), rgba(22, 33, 62, 0.96));
            border: 3px solid var(--border-epic);
            border-radius: 15px;
            padding: 20px; 
            backdrop-filter: blur(8px); 
        }

        .battle-teams-display {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            margin-bottom: 18px; 
            padding: 8px; 
            background: rgba(0,0,0,0.25); 
            border-radius: 8px; 
        }
        .team-display {
            width: 46%; 
            text-align: center;
            position: relative; 
        }
        .team-display .team-name {
            font-size: 1.25rem; 
            margin-bottom: 8px; 
        }
        .team-display .team-numbers {
            min-height: auto;
            padding-bottom: 8px; 
        }
        .vs-separator {
            font-size: 1.8rem; 
            font-family: var(--font-title);
            color: var(--color-gold);
            align-self: center;
        }
        
        .battle-log {
            background: rgba(0,0,0,0.65); 
            border: 2px solid #4a5568;
            border-radius: 8px; 
            padding: 15px; 
            max-height: 280px; 
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem; 
            line-height: 1.5; 
            margin-bottom: 18px; 
        }
        
        .log-entry {
            margin-bottom: 8px; 
            padding: 8px; 
            border-radius: 4px; 
            animation: logAppear 0.4s ease-out; 
            border-left: 3px solid transparent; 
        }
        .log-entry .turn-header {
            font-weight: bold;
            color: var(--color-gold);
            margin-bottom: 4px; 
        }
        .log-entry .details {
            margin-left: 8px; 
        }
        .log-entry .details .player-action, .log-entry .details .ai-action {
            display: block;
            margin-bottom: 2px; 
        }
        .log-entry .details .active-number {
            font-weight: bold;
            color: var(--color-gold-light);
            padding: 0 1px; 
            border-radius: 2px; 
            background-color: rgba(255,237,78,0.08); 
        }
        .log-entry .round-result {
            margin-top: 4px; 
            font-weight: bold;
        }
        
        @keyframes logAppear {
            from { opacity: 0; transform: translateX(-15px); } 
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-entry.player-win {
            background: rgba(72, 187, 120, 0.15); 
            border-left-color: #48bb78;
            color: var(--player-color-light);
        }
        
        .log-entry.ai-win {
            background: rgba(245, 101, 101, 0.15); 
            border-left-color: var(--ai-color);
            color: var(--ai-color-light);
        }
        
        .log-entry.tie {
            background: rgba(237, 137, 54, 0.15); 
            border-left-color: var(--tie-color);
            color: var(--tie-color-light);
        }
        
        .battle-result {
            text-align: center;
            font-size: 1.8rem; 
            font-weight: 700;
            margin: 18px 0; 
            padding: 18px; 
            border-radius: 8px; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: resultPulse 0.9s ease-in-out; 
        }
        
        @keyframes resultPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); } 
        }
        
        .battle-result.victory {
            background: linear-gradient(145deg, rgba(72, 187, 120, 0.25), rgba(56, 161, 105, 0.25)); 
            border: 2px solid #48bb78;
            color: var(--player-color-light);
        }
        
        .battle-result.defeat {
            background: linear-gradient(145deg, rgba(245, 101, 101, 0.25), rgba(229, 62, 62, 0.25)); 
            border: 2px solid var(--ai-color);
            color: var(--ai-color-light);
        }
        
        /* AI Taunt - now for floating text */
        .floating-taunt {
            position: absolute; /* Positioned relative to .battle-arena or .team-display.ai */
            font-family: var(--font-title);
            font-size: 1.3em;
            font-style: italic;
            color: var(--ai-color-light);
            background: rgba(100, 60, 150, 0.5); /* Semi-transparent background */
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid var(--ai-color);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            opacity: 0;
            animation: floatAcrossAndFade 2.5s ease-out forwards;
            z-index: 15;
            pointer-events: none;
            white-space: nowrap; /* Keep taunt on one line if possible */
        }

        @keyframes floatAcrossAndFade {
            0% { transform: translate(0, 0) scale(0.7); opacity: 0; }
            10% { transform: translate(-20px, -10px) scale(1); opacity: 1; } /* Appear */
            80% { transform: translate(-100px, -50px) scale(0.9); opacity: 0.8; } /* Drift */
            100% { transform: translate(-150px, -70px) scale(0.7); opacity: 0; } /* Fade out */
        }
        
        /* Power Bar Styles */
        .power-bar-container {
            width: 100%;
            height: 25px;
            background-color: var(--power-bar-bg);
            border-radius: 8px;
            display: flex;
            overflow: hidden;
            margin: 15px 0;
            border: 2px solid var(--border-epic);
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        .power-bar-player, .power-bar-ai {
            height: 100%;
            transition: width 0.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            color: var(--color-text-light);
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
        }
        .power-bar-player {
            background-color: var(--power-bar-player);
            border-top-left-radius: 6px; /* Match container radius */
            border-bottom-left-radius: 6px;
        }
        .power-bar-ai {
            background-color: var(--power-bar-ai);
            border-top-right-radius: 6px;
            border-bottom-right-radius: 6px;
        }
        
        @media (max-width: 768px) {
            .game-title { font-size: 2.2rem; }
            .game-subtitle { font-size: 1rem; }
            .teams-container, .battle-teams-display {
                grid-template-columns: 1fr;
                flex-direction: column;
                align-items: center;
            }
            .team-display { width: 90%; margin-bottom: 8px; } 
            .vs-separator { margin: 8px 0; } 
            .number-pool { gap: 6px; } 
            .number-token { padding: 8px 10px; font-size: 1rem; } 
            #gameSettings .settings-grid { grid-template-columns: 1fr; }
            #gameSettings .settings-grid > div { flex-direction: column; align-items: stretch; }
            #gameSettings input[type="number"] { width: 100%; margin-left: 0; margin-top: 4px; } 
            .lang-toggle-container { top: 5px; right: 10px;}
            .lang-toggle-btn { padding: 6px 10px; font-size: 0.8rem;}
            .power-bar-container { height: 20px; }
            .floating-taunt { font-size: 1.1em; }
        }

    </style>
</head>
<body>
    <div class="lang-toggle-container">
        <button id="langToggleBtn" class="lang-toggle-btn">切换中文</button>
    </div>

    <div class="game-container">
        <h1 class="game-title" data-lang-key="gameTitle">⚔️ Numcraft ⚔️</h1>
        <p class="game-subtitle" data-lang-key="gameSubtitle">Epic Battle Arena - Where Numbers Clash in Ancient Combat</p>
        
        <div id="gameSettings" class="game-phase collapsed"> <h2 class="phase-title" data-lang-key="settingsTitle" id="settingsToggle">⚙️ Game Settings</h2>
            <div class="settings-content">
                <div class="settings-grid">
                    <div>
                        <label for="poolSizeInput" data-lang-key="poolSizeLabel">Pool Size (e.g., 7-15):</label>
                        <input type="number" id="poolSizeInput" value="9" min="6" max="20">
                    </div>
                    <div>
                        <label for="teamSizeInput" data-lang-key="teamSizeLabel">Team Size (e.g., 3-5):</label>
                        <input type="number" id="teamSizeInput" value="3" min="2" max="5">
                    </div>
                    <div>
                        <label for="minNumInput" data-lang-key="minNumLabel">Min Number (e.g., 1):</label>
                        <input type="number" id="minNumInput" value="10" min="1" max="50">
                    </div>
                    <div>
                        <label for="maxNumInput" data-lang-key="maxNumLabel">Max Number (e.g., 100):</label>
                        <input type="number" id="maxNumInput" value="100" min="20" max="200">
                    </div>
                </div>
            </div>
        </div>

        <div id="setupPhase" class="game-phase">
            <h2 class="phase-title" data-lang-key="recruitTitle">🏰 Recruit Your Army</h2>
            <div class="number-pool" id="numberPool"></div>
            <div class="teams-container">
                <div class="team player">
                    <div class="team-name" data-lang-key="playerLegion">⚔️ Your Legion</div>
                    <div class="team-numbers" id="playerTeam"></div>
                </div>
                <div class="team ai">
                    <div class="team-name" data-lang-key="enemyForces">🔥 Enemy Forces</div>
                    <div class="team-numbers" id="aiTeam"></div>
                </div>
            </div>
            <div class="controls">
                <button class="btn" onclick="startBattle()" id="battleBtn" disabled data-lang-key="enterBattleBtn">⚔️ Enter Battle</button>
                <button class="btn" onclick="applySettingsAndNewGame()" data-lang-key="newCampaignBtn">🎲 New Campaign</button>
            </div>
            <div id="aiTauntContainer" style="position: relative; min-height: 30px;"></div> 
        </div>
        
        <div id="battlePhase" class="battle-arena" style="display: none;">
            <h2 class="phase-title" data-lang-key="arenaTitle">🔥 Battle Arena 🔥</h2>

            <div class="battle-teams-display">
                <div class="team-display player-battle-team">
                    <h3 class="team-name" style="color: var(--player-color-light);" data-lang-key="playerLegion">⚔️ Your Legion</h3>
                    <div class="team-numbers" id="playerBattleTeamNumbers"></div>
                </div>
                <div class="vs-separator">VS</div>
                <div class="team-display ai-battle-team">
                    <h3 class="team-name" style="color: var(--ai-color-light);" data-lang-key="enemyForces">🔥 Enemy Forces</h3>
                    <div class="team-numbers" id="aiBattleTeamNumbers"></div>
                </div>
            </div>
            
            <div class="power-bar-container" id="powerBarContainer">
                <div class="power-bar-player" id="powerBarPlayer"></div>
                <div class="power-bar-ai" id="powerBarAi"></div>
            </div>

            <div class="battle-log" id="battleLog"></div>
            <div id="battleResult"></div>
            <div class="controls">
                <button class="btn" onclick="applySettingsAndNewGame()" data-lang-key="returnRecruitBtn">🏰 Return to Recruitment</button>
            </div>
        </div>
    </div>

    <script>
        // --- Language Configuration ---
        const translations = {
            en: {
                gameTitle: "⚔️ Numcraft ⚔️",
                gameSubtitle: "Epic Battle Arena - Where Numbers Clash in Ancient Combat",
                settingsTitle: "⚙️ Game Settings",
                poolSizeLabel: "Pool Size (e.g., 7-15):",
                teamSizeLabel: "Team Size (e.g., 3-5):",
                minNumLabel: "Min Number (e.g., 1):",
                maxNumLabel: "Max Number (e.g., 100):",
                recruitTitle: "🏰 Recruit Your Army",
                playerLegion: "⚔️ Your Legion",
                enemyForces: "🔥 Enemy Forces",
                enterBattleBtn: "⚔️ Enter Battle",
                newCampaignBtn: "🎲 New Campaign",
                arenaTitle: "🔥 Battle Arena 🔥",
                // yourVictories: "Your Victories", // Replaced by power bar
                // enemyVictories: "Enemy Victories", // Replaced by power bar
                returnRecruitBtn: "🏰 Return to Recruitment",
                langToggleToCn: "切换中文",
                langToggleToEn: "Switch to English",
                alertTeamsNotFull: "Both teams must be full before starting the battle!",
                alertPoolSizeError: (poolSize, requiredSize) => `Pool size (${poolSize}) must be at least ${requiredSize} (twice team size). Please adjust.`,
                alertMaxMinError: "Max number must be greater than Min number. Please adjust.",
                alertRangeError: "The range of numbers (Max - Min + 1) is too small for the desired pool size. Please adjust Min/Max numbers or Pool Size.",
                alertConfigError: "Cannot configure a valid game with current number range and pool size.",
                logPlayer: "Player",
                logAI: "AI",
                logValue: "Value",
                logTurn: "Turn",
                logRoundWinPlayer: "🗡️ Player Round Victory!",
                logRoundWinAI: "🔥 AI Round Victory!",
                logRoundTie: "⚡ Round Tie!",
                battleEndVictory: "🏆 GLORIOUS VICTORY! 🏆",
                battleEndDefeat: "💀 CRUSHING DEFEAT 💀",
                battleEndConcluded: (turn) => `Battle concluded at turn ${turn}`,
                battleEndStalemate: "Battle reached max turns. Stalemate!",
                aiTaunts: {
                    confident: [
                        "Your army trembles!", "I shall crush you!", "Prepare for defeat!",
                        "I am sure I can win!", "Great advantage!"
                    ],
                    worried: [
                        "You think you're clever?", "This battle is far from over!", "I must reconsider...",
                        "My army is stronger!", "Need to think twice..."
                    ],
                    desperate: [
                        "Impossible! How?", "My calculations... wrong?!", "You learned too well!",
                        "Seen through my trick?", "I am in trouble..."
                    ]
                }
            },
            cn: {
                gameTitle: "⚔️ 数字战场 ⚔️",
                gameSubtitle: "史诗对决 - 数字在远古战场上碰撞",
                settingsTitle: "⚙️ 游戏设置",
                poolSizeLabel: "数字池大小 (例如 7-15):",
                teamSizeLabel: "队伍大小 (例如 3-5):",
                minNumLabel: "最小数字 (例如 1):",
                maxNumLabel: "最大数字 (例如 100):",
                recruitTitle: "🏰 招募你的军团",
                playerLegion: "⚔️ 你的军团",
                enemyForces: "🔥 敌方部队",
                enterBattleBtn: "⚔️ 进入战场",
                newCampaignBtn: "🎲 新的战役",
                arenaTitle: "🔥 激战竞技场 🔥",
                // yourVictories: "你的胜场", // Replaced by power bar
                // enemyVictories: "敌方胜场", // Replaced by power bar
                returnRecruitBtn: "🏰 返回招募",
                langToggleToCn: "切换中文",
                langToggleToEn: "Switch to English",
                alertTeamsNotFull: "双方队伍必须满员才能开始战斗！",
                alertPoolSizeError: (poolSize, requiredSize) => `数字池大小 (${poolSize}) 必须至少是队伍大小的两倍 (${requiredSize})。请调整。`,
                alertMaxMinError: "最大数字必须大于最小数字。请调整。",
                alertRangeError: "数字范围 (最大值 - 最小值 + 1) 对于期望的数字池大小来说太小了。请调整最小/最大数字或数字池大小。",
                alertConfigError: "无法使用当前的数字范围和数字池大小配置有效的游戏。",
                logPlayer: "玩家",
                logAI: "AI",
                logValue: "值",
                logTurn: "回合",
                logRoundWinPlayer: "🗡️ 玩家回合胜利！",
                logRoundWinAI: "🔥 AI回合胜利！",
                logRoundTie: "⚡ 回合平局！",
                battleEndVictory: "🏆 光荣的胜利！ 🏆",
                battleEndDefeat: "💀 惨痛的失败 💀",
                battleEndConcluded: (turn) => `战斗在第 ${turn} 回合结束`,
                battleEndStalemate: "战斗达到最大回合数，平局！",
                aiTaunts: { 
                    confident: [
                        "你的军队在我强大的力量面前颤抖吧！", "我将以数学般的精度碾压你！", "凡人，准备迎接失败！",
                        "我确信我能赢！", "我现在优势很大！"
                    ],
                    worried: [
                        "你觉得自己很聪明，是吗？", "这场战斗远未结束！", "我必须重新考虑我的策略...",
                        "我的军团更强！", "我可能需要三思而后行..."
                    ],
                    desperate: [
                        "不可能！你是怎么预见到这一切的？", "我的计算…它们不可能是错的！", "你把古老的技艺学得太好了！",
                        "你看穿我的计谋了吗？", "我现在有麻烦了..."
                    ]
                }
            }
        };
        let currentLang = 'en'; 

        function setLanguage(lang) {
            currentLang = lang;
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(element => {
                const key = element.getAttribute('data-lang-key');
                const translation = translations[lang]?.[key];
                if (typeof translation === 'function') {
                    // If it's a function, it might need parameters (though not used here for static keys)
                    // For now, just call it if it's a function, otherwise assign directly
                    // This part is more for future-proofing if parameterized translations are needed for static keys
                    try {
                        element.textContent = translation();
                    } catch (e) {
                        element.textContent = translation; // Fallback if it's not a function or doesn't need params
                    }
                } else if (translation) {
                    element.textContent = translation;
                }
            });
            const langToggleBtn = document.getElementById('langToggleBtn');
            if (lang === 'en') {
                langToggleBtn.textContent = translations.en.langToggleToCn;
            } else {
                langToggleBtn.textContent = translations.cn.langToggleToEn;
            }
        }

        function toggleLanguage() {
            const newLang = currentLang === 'en' ? 'cn' : 'en';
            setLanguage(newLang);
             // After language switch, if AI taunt is visible, re-render it (not implemented here for simplicity)
            // Or, better, make showAiTaunt always use currentLang
        }

        let gameSettings = {
            poolSize: 9,
            teamSize: 3,
            minNum: 10,
            maxNum: 100
        };

        let gameState = {
            numberPool: [],
            playerTeam: [],
            aiTeam: [],
            teamSize: gameSettings.teamSize,
            gamePhase: 'setup',
            isAiThinking: false,
            playerOrder: 1 
        };
        
        function combinations(arr, k) {
            if (k < 0 || k > arr.length) return [];
            if (k === 0) return [[]];
            if (arr.length === k) return [[...arr]];
            if (k === 1) return arr.map(e => [e]);
            const combs = [];
            for (let i = 0; i <= arr.length - k; i++) {
                const head = arr[i];
                const tail = arr.slice(i + 1);
                const subCombs = combinations(tail, k - 1);
                for (const subComb of subCombs) {
                    combs.push([head, ...subComb]);
                }
            }
            return combs;
        }

        function fightLogic(teamA, teamB) { 
            let consecutiveWinsA = 0;
            let consecutiveWinsB = 0;
            let turn = 2;
            const maxTurns = 200; 

            while (consecutiveWinsA < 3 && consecutiveWinsB < 3 && turn <= maxTurns) {
                const maxA = Math.max(...teamA.map(n => n % turn));
                const maxB = Math.max(...teamB.map(n => n % turn));

                if (maxA > maxB) {
                    consecutiveWinsA++;
                    consecutiveWinsB = 0;
                } else if (maxB > maxA) {
                    consecutiveWinsB++;
                    consecutiveWinsA = 0;
                } else { 
                    consecutiveWinsA = 0;
                    consecutiveWinsB = 0;
                }
                if (consecutiveWinsA >= 3 || consecutiveWinsB >= 3) break;
                turn++;
            }
            return { winnerA: consecutiveWinsA >= 3, turns: turn };
        }

        let lookupTableCache = { key: null, value: null };

        function getLookupTableJs(numbersForLookup, teamSize) {
            const cacheKey = numbersForLookup.join(',') + '-' + teamSize;
            if (lookupTableCache.key === cacheKey) {
                return lookupTableCache.value;
            }

            const lookup = new Map();
            const turnLookup = new Map();
            const allNumbersSorted = [...numbersForLookup].sort((a, b) => a - b);
            const allTeam1Combs = combinations(allNumbersSorted, teamSize);

            for (const team1 of allTeam1Combs) {
                const remainingForTeam2 = allNumbersSorted.filter(n => !team1.includes(n));
                if (remainingForTeam2.length < teamSize) continue;
                const allTeam2Combs = combinations(remainingForTeam2, teamSize);

                for (const team2 of allTeam2Combs) {
                    const sortedTeam1 = [...team1].sort((a, b) => a - b);
                    const sortedTeam2 = [...team2].sort((a, b) => a - b);
                    const key = `${sortedTeam1.join(',')}|${sortedTeam2.join(',')}`;
                    
                    const { winnerA, turns } = fightLogic(sortedTeam1, sortedTeam2);
                    lookup.set(key, winnerA); 
                    turnLookup.set(key, turns);
                }
            }
            const result = { lookup, turnLookup };
            lookupTableCache = { key: cacheKey, value: result };
            return result;
        }
        
        function greedyStrategyJs(aiCurrentTeam, playerCurrentTeam, availableNumbers, teamSize) {
            let bestNumber = null;
            let bestWinRate = -1;
            let currentShortestWin = Infinity;
            let currentLongestLose = 0; 

            const allNumbersForLookup = [...new Set([...aiCurrentTeam, ...playerCurrentTeam, ...availableNumbers])].sort((a,b) => a-b);
            if (allNumbersForLookup.length < 2 * teamSize) {
                 return { bestNumber: availableNumbers.length > 0 ? availableNumbers[0] : null, bestWinRate: 0 };
            }

            const { lookup, turnLookup } = getLookupTableJs(allNumbersForLookup, teamSize);

            for (const num of availableNumbers) {
                let winCount = 0;
                let totalCount = 0;
                let shortestWinForThisNum = Infinity;
                let longestLoseForThisNum = 0;

                const newAiTeamAttempt = [...aiCurrentTeam, num];
                const remainingNumbersAfterPick = availableNumbers.filter(n => n !== num);
                
                const slotsToFillAi = teamSize - newAiTeamAttempt.length;
                const slotsToFillPlayer = teamSize - playerCurrentTeam.length;

                if (slotsToFillAi < 0 || slotsToFillPlayer < 0) continue;

                const aiCompletions = combinations(remainingNumbersAfterPick, slotsToFillAi);

                for (const aiCompletion of aiCompletions) {
                    const completedAiTeam = [...newAiTeamAttempt, ...aiCompletion].sort((a,b) => a-b);
                    const remainingForPlayerCompletion = remainingNumbersAfterPick.filter(n => !aiCompletion.includes(n));
                    
                    if (remainingForPlayerCompletion.length < slotsToFillPlayer) continue;
                    const playerCompletions = combinations(remainingForPlayerCompletion, slotsToFillPlayer);

                    for (const playerCompletion of playerCompletions) {
                        const completedPlayerTeam = [...playerCurrentTeam, ...playerCompletion].sort((a,b) => a-b);
                        const key = `${completedAiTeam.join(',')}|${completedPlayerTeam.join(',')}`;
                        
                        if (lookup.has(key)) {
                            totalCount++;
                            const aiWins = lookup.get(key);
                            const turn = turnLookup.get(key);
                            if (aiWins) {
                                winCount++;
                                shortestWinForThisNum = Math.min(shortestWinForThisNum, turn);
                            } else {
                                longestLoseForThisNum = Math.max(longestLoseForThisNum, turn);
                            }
                        }
                    }
                }

                const winRate = totalCount > 0 ? winCount / totalCount : 0;
                const currentDiff = currentShortestWin - currentLongestLose;
                const newDiff = shortestWinForThisNum - longestLoseForThisNum;

                if (winRate > bestWinRate) {
                    bestWinRate = winRate;
                    bestNumber = num;
                    currentShortestWin = shortestWinForThisNum;
                    currentLongestLose = longestLoseForThisNum;
                } else if (winRate === bestWinRate) {
                    if (newDiff < currentDiff) { 
                        bestNumber = num;
                        currentShortestWin = shortestWinForThisNum;
                        currentLongestLose = longestLoseForThisNum;
                    } else if (newDiff === currentDiff && bestNumber === null) {
                         bestNumber = num; 
                    }
                }
            }
            if (bestNumber === null && availableNumbers.length > 0) { 
                bestNumber = availableNumbers[Math.floor(Math.random() * availableNumbers.length)];
            }
            return { bestNumber, bestWinRate };
        }

        function generateNumberPool() {
            const numbers = new Set();
            const requiredPoolSize = gameSettings.poolSize;
            const minVal = gameSettings.minNum;
            const maxVal = gameSettings.maxNum;

            if (maxVal - minVal + 1 < requiredPoolSize) {
                const alertMsg = translations[currentLang].alertRangeError || translations.en.alertRangeError;
                console.error(alertMsg);
                // Attempt to generate what's possible if range is too small
                for (let i = minVal; i <= maxVal; i++) {
                    numbers.add(i);
                }
            } else {
                while (numbers.size < requiredPoolSize) {
                    numbers.add(Math.floor(Math.random() * (maxVal - minVal + 1)) + minVal);
                }
            }
            return Array.from(numbers).sort((a, b) => a - b);
        }


        function applySettingsAndNewGame() {
            gameSettings.poolSize = parseInt(document.getElementById('poolSizeInput').value) || 9;
            gameSettings.teamSize = parseInt(document.getElementById('teamSizeInput').value) || 3;
            gameSettings.minNum = parseInt(document.getElementById('minNumInput').value) || 10;
            gameSettings.maxNum = parseInt(document.getElementById('maxNumInput').value) || 100;

            const alertPoolError = translations[currentLang].alertPoolSizeError || translations.en.alertPoolSizeError;
            const alertMaxMin = translations[currentLang].alertMaxMinError || translations.en.alertMaxMinError;
            const alertRange = translations[currentLang].alertRangeError || translations.en.alertRangeError;
            const alertConfig = translations[currentLang].alertConfigError || translations.en.alertConfigError;


            if (gameSettings.poolSize < 2 * gameSettings.teamSize) {
                alert(alertPoolError(gameSettings.poolSize, 2 * gameSettings.teamSize));
                gameSettings.poolSize = 2 * gameSettings.teamSize; 
                document.getElementById('poolSizeInput').value = gameSettings.poolSize;
            }
            if (gameSettings.maxNum <= gameSettings.minNum) {
                alert(alertMaxMin);
                gameSettings.maxNum = gameSettings.minNum + gameSettings.poolSize; 
                document.getElementById('maxNumInput').value = gameSettings.maxNum;
            }
             if (gameSettings.maxNum - gameSettings.minNum + 1 < gameSettings.poolSize) {
                alert(alertRange);
                gameSettings.maxNum = gameSettings.minNum + gameSettings.poolSize -1;
                if (gameSettings.maxNum > 200) gameSettings.maxNum = 200;
                document.getElementById('maxNumInput').value = gameSettings.maxNum;

                if (gameSettings.maxNum - gameSettings.minNum + 1 < gameSettings.poolSize){
                    console.error(alertConfig);
                    return; 
                }
            }
            
            gameState.teamSize = gameSettings.teamSize;
            lookupTableCache.key = null; 
            initializeGame();
            document.getElementById('gameSettings').style.display = 'block'; 
            document.getElementById('setupPhase').style.display = 'block';
            document.getElementById('battlePhase').style.display = 'none';
        }


        function initializeGame() {
            gameState.numberPool = generateNumberPool();
            gameState.playerTeam = [];
            gameState.aiTeam = [];
            gameState.gamePhase = 'setup';
            gameState.isAiThinking = false;
            
            renderNumberPool();
            renderTeams();
            document.getElementById('battleBtn').disabled = true;
            document.getElementById('aiTauntContainer').innerHTML = ''; // Clear old taunts
            document.getElementById('battleResult').innerHTML = ''; 
            document.getElementById('battleLog').innerHTML = '';   
            updatePowerBar(0,0); // Reset power bar
            setLanguage(currentLang); 
        }

        function renderNumberPool() {
            const pool = document.getElementById('numberPool');
            pool.innerHTML = '';
            gameState.numberPool.forEach(num => {
                const token = document.createElement('div');
                token.className = 'number-token';
                token.textContent = num;
                if (gameState.playerTeam.length < gameState.teamSize && !gameState.isAiThinking) {
                    token.onclick = () => selectNumber(num);
                } else {
                    token.onclick = null;
                }
                pool.appendChild(token);
            });
        }
        
        function markNumberAsSelected(num, isSelected) {
            const tokens = document.querySelectorAll('.number-pool .number-token'); 
            tokens.forEach(token => {
                if (parseInt(token.textContent) === num) {
                    if (isSelected) {
                        token.classList.add('selected');
                        token.onclick = null; 
                    } else { 
                        token.classList.remove('selected');
                    }
                }
            });
        }

        function renderTeams() {
            const playerTeamEl = document.getElementById('playerTeam');
            const aiTeamEl = document.getElementById('aiTeam');
            playerTeamEl.innerHTML = gameState.playerTeam.map(num => `<div class="team-number" data-value="${num}">${num}</div>`).join('');
            aiTeamEl.innerHTML = gameState.aiTeam.map(num => `<div class="team-number" data-value="${num}">${num}</div>`).join('');
        }

        function selectNumber(num) {
            if (gameState.isAiThinking) return; 
            if (gameState.playerTeam.length >= gameState.teamSize) return;
            if (gameState.aiTeam.includes(num) || gameState.playerTeam.includes(num)) return; 
            
            gameState.playerTeam.push(num);
            markNumberAsSelected(num, true);
            renderTeams();
            checkAndProceedToAiPick();
        }

        function checkAndProceedToAiPick() {
            if (gameState.aiTeam.length < gameState.teamSize) {
                 if (gameState.playerTeam.length <= gameState.teamSize) { 
                    gameState.isAiThinking = true;
                    document.getElementById('numberPool').style.opacity = '0.5'; 

                    setTimeout(() => { 
                        aiPickNumber();
                        gameState.isAiThinking = false;
                        document.getElementById('numberPool').style.opacity = '1';
                        if (gameState.playerTeam.length === gameState.teamSize && gameState.aiTeam.length === gameState.teamSize) {
                            document.getElementById('battleBtn').disabled = false;
                        }
                    }, 300); 
                }
            } else if (gameState.playerTeam.length === gameState.teamSize && gameState.aiTeam.length === gameState.teamSize) {
                 document.getElementById('battleBtn').disabled = false; 
            }
        }

        function aiPickNumber() {
            if (gameState.aiTeam.length >= gameState.teamSize) return;
            
            const available = gameState.numberPool.filter(num => 
                !gameState.playerTeam.includes(num) && !gameState.aiTeam.includes(num)
            );
            
            if (available.length === 0) return; 
            
            const strategicChoice = greedyStrategyJs([...gameState.aiTeam], [...gameState.playerTeam], available, gameState.teamSize);
            let choice = strategicChoice.bestNumber;
            let aiWinRate = strategicChoice.bestWinRate;

            if (choice === null && available.length > 0) {
                choice = available[Math.floor(Math.random() * available.length)];
                aiWinRate = 0.1; 
            } else if (choice === null && available.length === 0) {
                 return; 
            }
            
            gameState.aiTeam.push(choice);
            markNumberAsSelected(choice, true);
            renderTeams();
            showAiTaunt(aiWinRate);
        }
        
        function showAiTaunt(winRate) {
            const tauntContainer = document.getElementById('aiTauntContainer');
            tauntContainer.innerHTML = ''; // Clear previous taunts

            const currentTauntsSet = translations[currentLang].aiTaunts;
            let selectedTauntsCategoryKey;

            if (typeof winRate === 'undefined' || winRate === null || isNaN(winRate)) {
                const playerStrength = gameState.playerTeam.reduce((a, b) => a + b, 0);
                const aiStrength = gameState.aiTeam.reduce((a, b) => a + b, 0);
                if (!aiStrength && !playerStrength && gameState.playerTeam.length === 0) { 
                    selectedTauntsCategoryKey = 'worried';
                } else if (aiStrength > playerStrength * 1.2) {
                    selectedTauntsCategoryKey = 'confident';
                } else if (aiStrength < playerStrength * 0.8) {
                    selectedTauntsCategoryKey = 'desperate';
                } else {
                    selectedTauntsCategoryKey = 'worried';
                }
            } else { 
                if (winRate > 0.75) selectedTauntsCategoryKey = 'confident';
                else if (winRate > 0.35) selectedTauntsCategoryKey = 'worried';
                else selectedTauntsCategoryKey = 'desperate';
            }
            const selectedTaunts = currentTauntsSet[selectedTauntsCategoryKey] || currentTauntsSet.worried;
            const tauntText = selectedTaunts[Math.floor(Math.random() * selectedTaunts.length)];
            
            const tauntElement = document.createElement('div');
            tauntElement.className = 'floating-taunt';
            tauntElement.textContent = tauntText;

            // Position taunt to float from AI's side (approximate)
            // This might need adjustment based on actual layout
            const aiTeamDisplay = document.querySelector('.team.ai'); // In setup phase
            const aiBattleTeamDisplay = document.querySelector('.team-display.ai-battle-team'); // In battle phase

            let anchorElement = gameState.gamePhase === 'battle' ? aiBattleTeamDisplay : aiTeamDisplay;
            if (anchorElement) {
                 const anchorRect = anchorElement.getBoundingClientRect();
                 const containerRect = tauntContainer.getBoundingClientRect(); // Position relative to this container

                 tauntElement.style.top = `${anchorRect.top - containerRect.top + anchorRect.height / 2 - 15}px`; // Mid-height of AI team
                 tauntElement.style.left = `${anchorRect.left - containerRect.left + anchorRect.width / 2 - tauntElement.offsetWidth /2 }px`; // Centered on AI team
                 // The animation itself handles the "floating away" part.
            } else { // Fallback if anchor not found
                 tauntElement.style.top = '0px';
                 tauntElement.style.left = '50%';
                 tauntElement.style.transform = 'translateX(-50%)';
            }
            
            tauntContainer.appendChild(tauntElement);

            setTimeout(() => {
                if(tauntElement.parentNode) tauntElement.parentNode.removeChild(tauntElement);
            }, 2450); // Slightly less than animation duration to ensure removal
        }


        function startBattle() {
            if (gameState.playerTeam.length !== gameState.teamSize || gameState.aiTeam.length !== gameState.teamSize) {
                alert(translations[currentLang].alertTeamsNotFull);
                return;
            }
            gameState.gamePhase = 'battle';
            document.getElementById('setupPhase').style.display = 'none';
            document.getElementById('gameSettings').style.display = 'none'; 
            document.getElementById('battlePhase').style.display = 'block';

            document.getElementById('playerBattleTeamNumbers').innerHTML = gameState.playerTeam.map(num => `<div class="team-number" data-value="${num}">${num}</div>`).join('');
            document.getElementById('aiBattleTeamNumbers').innerHTML = gameState.aiTeam.map(num => `<div class="team-number" data-value="${num}">${num}</div>`).join('');
            updatePowerBar(0,0); // Initialize power bar for battle
            simulateBattle();
        }

        function updatePowerBar(playerConsecutiveWins, aiConsecutiveWins) {
            const playerBar = document.getElementById('powerBarPlayer');
            const aiBar = document.getElementById('powerBarAi');
            const totalSegments = 3 * 2; // Max 3 wins for each side for full swing
            
            let playerAdvantage = playerConsecutiveWins - aiConsecutiveWins; // -3 to +3

            // Normalize advantage to a 0-1 scale where 0.5 is neutral
            let playerShare = 0.5 + (playerAdvantage / (gameState.teamSize * 2)); // teamSize here represents max consecutive wins for victory
            playerShare = Math.max(0.05, Math.min(0.95, playerShare)); // Clamp between 5% and 95% to always show both bars

            playerBar.style.width = `${playerShare * 100}%`;
            aiBar.style.width = `${(1 - playerShare) * 100}%`;

            // Optional: Display text inside power bar segments
            // playerBar.textContent = playerConsecutiveWins > 0 ? `${playerConsecutiveWins}` : '';
            // aiBar.textContent = aiConsecutiveWins > 0 ? `${aiConsecutiveWins}` : '';
        }


        function getPowerColor(value, opponentValue, isPlayer) {
            const advantage = value - opponentValue;
            if (value === opponentValue) return 'var(--color-text-neutral)'; // Tie
            
            if (advantage > 0) { // Winning this round
                if (advantage > opponentValue * 0.5 || value > 2 * opponentValue && opponentValue > 0) return 'var(--color-gold-light)'; // Strong win
                return isPlayer ? 'var(--player-color-light)' : 'var(--ai-color-light)'; // Normal win
            } else { // Losing this round
                if (Math.abs(advantage) > value * 0.5 || opponentValue > 2 * value && value > 0) return 'var(--disabled-text)'; // Strong loss
                return 'var(--color-text-light)'; // Normal loss
            }
        }
        
        function animateActiveNumber(teamType, activeNumValue, moduloValue, opponentModuloValue) {
            const teamNumbersContainerId = teamType === 'player' ? 'playerBattleTeamNumbers' : 'aiBattleTeamNumbers';
            const teamNumbersContainer = document.getElementById(teamNumbersContainerId);
            if (!teamNumbersContainer) return;

            const teamNumberElements = teamNumbersContainer.querySelectorAll('.team-number');
            let targetElement = null;

            teamNumberElements.forEach(el => {
                if (parseInt(el.dataset.value) === activeNumValue) {
                    targetElement = el;
                }
            });

            if (targetElement) {
                targetElement.classList.add('active-battle-unit');
                
                const floatText = document.createElement('span');
                floatText.className = 'floating-value';
                floatText.textContent = moduloValue;
                
                let powerColor = getPowerColor(moduloValue, opponentModuloValue, teamType === 'player');
                floatText.style.color = powerColor;

                const teamDisplay = targetElement.closest('.team-display');
                if (teamDisplay) {
                    const targetRect = targetElement.getBoundingClientRect();
                    const teamDisplayRect = teamDisplay.getBoundingClientRect();
                    
                    floatText.style.left = `${targetRect.left - teamDisplayRect.left + targetRect.width / 2 - 10}px`; 
                    floatText.style.top = `${targetRect.top - teamDisplayRect.top - 10}px`; 
                    teamDisplay.appendChild(floatText);

                    setTimeout(() => {
                        if (floatText.parentNode) floatText.parentNode.removeChild(floatText);
                    }, 1150); 
                }

                setTimeout(() => {
                    targetElement.classList.remove('active-battle-unit');
                }, 1000); 
            }
        }


        function simulateBattle() {
            const battleLog = document.getElementById('battleLog');
            const battleResultEl = document.getElementById('battleResult');
            
            battleLog.innerHTML = ''; 
            battleResultEl.innerHTML = ''; 
            
            let consecutivePlayerWins = 0;
            let consecutiveAiWins = 0;
            let turn = 2;
            const maxTurns = 200; 

            const logEntry = (turnNumber, playerActiveNum, playerVal, aiActiveNum, aiVal, resultType, resultText) => {
                const div = document.createElement('div');
                div.className = `log-entry ${resultType}`; 
                
                let playerActionHtml = `${translations[currentLang].logPlayer} <span class="active-number">${playerActiveNum}</span> (${translations[currentLang].logValue}: ${playerVal})`;
                let aiActionHtml = `${translations[currentLang].logAI} <span class="active-number">${aiActiveNum}</span> (${translations[currentLang].logValue}: ${aiVal})`;

                div.innerHTML = `
                    <div class="turn-header">${translations[currentLang].logTurn} ${turnNumber}</div>
                    <div class="details">
                        <span class="player-action">${playerActionHtml}</span>
                        <span class="ai-action">${aiActionHtml}</span>
                    </div>
                    <div class="round-result">${resultText}</div>
                `;
                battleLog.appendChild(div);
                battleLog.scrollTop = battleLog.scrollHeight; 
            };
            
            updatePowerBar(consecutivePlayerWins, consecutiveAiWins);
            
            const battleStep = () => {
                if (turn > maxTurns || consecutivePlayerWins >= 3 || consecutiveAiWins >= 3) {
                    const playerOverallVictory = consecutivePlayerWins >= 3;
                    const battleEndTextKey = playerOverallVictory ? 'battleEndVictory' : 'battleEndDefeat';
                    const battleEndConcludedText = translations[currentLang].battleEndConcluded(turn -1);
                    
                    battleResultEl.innerHTML = `
                        <div class="battle-result ${playerOverallVictory ? 'victory' : 'defeat'}">
                            ${translations[currentLang][battleEndTextKey]}
                            <br>${battleEndConcludedText}
                        </div>`;
                    if (turn > maxTurns && !(consecutivePlayerWins >=3 || consecutiveAiWins >= 3)) {
                         logEntry(turn -1, '-', '-', '-', '-', 'tie', translations[currentLang].battleEndStalemate);
                    }
                    return;
                }
                
                let playerActiveNumberDetails = gameState.playerTeam.reduce((best, current) => {
                    const currentVal = current % turn;
                    return currentVal > best.val ? {num: current, val: currentVal} : best;
                }, {num: gameState.playerTeam[0] || 0, val: (gameState.playerTeam[0] || 0) % turn});
                
                let aiActiveNumberDetails = gameState.aiTeam.reduce((best, current) => {
                    const currentVal = current % turn;
                    return currentVal > best.val ? {num: current, val: currentVal} : best;
                }, {num: gameState.aiTeam[0] || 0, val: (gameState.aiTeam[0] || 0) % turn});

                const playerMax = playerActiveNumberDetails.val;
                const playerActiveNum = playerActiveNumberDetails.num;
                const aiMax = aiActiveNumberDetails.val;
                const aiActiveNum = aiActiveNumberDetails.num;
                
                let roundResultTextKey;
                let roundResultType;
                
                if (playerMax > aiMax) {
                    roundResultTextKey = 'logRoundWinPlayer';
                    consecutivePlayerWins++;
                    consecutiveAiWins = 0;
                    roundResultType = 'player-win';
                    animateActiveNumber('player', playerActiveNum, playerMax, aiMax);
                } else if (aiMax > playerMax) {
                    roundResultTextKey = 'logRoundWinAI';
                    consecutiveAiWins++;
                    consecutivePlayerWins = 0;
                    roundResultType = 'ai-win';
                    animateActiveNumber('ai', aiActiveNum, aiMax, playerMax);
                } else {
                    roundResultTextKey = 'logRoundTie';
                    consecutivePlayerWins = 0; 
                    consecutiveAiWins = 0;
                    roundResultType = 'tie';
                    animateActiveNumber('player', playerActiveNum, playerMax, aiMax);
                    animateActiveNumber('ai', aiActiveNum, aiMax, playerMax);
                }
                
                logEntry(turn, playerActiveNum, playerMax, aiActiveNum, aiMax, roundResultType, translations[currentLang][roundResultTextKey]);
                updatePowerBar(consecutivePlayerWins, consecutiveAiWins);
                
                turn++;
                setTimeout(battleStep, 1300); 
            };
            
            setTimeout(battleStep, 700); 
        }

        window.onload = () => {
            document.getElementById('poolSizeInput').value = gameSettings.poolSize;
            document.getElementById('teamSizeInput').value = gameSettings.teamSize;
            document.getElementById('minNumInput').value = gameSettings.minNum;
            document.getElementById('maxNumInput').value = gameSettings.maxNum;
            
            gameState.teamSize = gameSettings.teamSize; 
            initializeGame(); 
            document.getElementById('gameSettings').style.display = 'block'; 
            // Make settings collapsible
            const settingsToggle = document.getElementById('settingsToggle');
            const gameSettingsDiv = document.getElementById('gameSettings');
            settingsToggle.addEventListener('click', () => {
                gameSettingsDiv.classList.toggle('collapsed');
            });
            // Ensure it starts collapsed (already added 'collapsed' class in HTML)

            document.getElementById('setupPhase').style.display = 'block';
            document.getElementById('battlePhase').style.display = 'none';
            document.getElementById('langToggleBtn').addEventListener('click', toggleLanguage);
            setLanguage('en'); 
        };
    </script>
</body>
</html>
